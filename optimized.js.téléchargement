/* $HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/optimized.js $ *//* $Revision: 18727 $ */if (typeof(optimized_js_loaded) == "undefined"){var optimized_js_loaded = true;// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/trunk/EVO_UNIX/include/javascript/staff/common.js $
// Revision: 13413 $

var re_durationMinutes = /^[ ]*[0-9]+[ ]*m[ ]*$/i;
var re_durationHours = /^[ ]*[0-9]+[ ]*h?[ ]*$/i;
var re_durationHoursMinutes = /^[ ]*[0-9]+[ ]*h[ ]*[0-5]?[0-9][ ]*m?[ ]*$/i;

function validDuration(value, bGetEmpty)
{
  value = value.replace(':', 'h');
  var regSp = new RegExp("([ ])", "g");
  var regM = new RegExp("(m)", "gi");
  var regH = new RegExp("(h)", "gi");
  if (re_durationMinutes.test(value))
  {
    value = parseInt(value.replace(regSp, '').replace(regM, ''));
    var m = String(value % 60);
    if (m.length == 1) m = '0' + m; 
    return Math.floor(value / 60) + ':' + m;
  }
  else if (re_durationHours.test(value))
    return value.replace(regSp, '').replace(regH, '') + ':00';
  else if (re_durationHoursMinutes.test(value))
  {
    value = value.replace(regSp, '').replace(regM, '').toLowerCase();
    pos = value.indexOf('h');
    var m = String(value.substr(pos + 1, value.length - pos - 1));
    if (m.length == 1) m = '0' + m;
    return value.substr(0, pos) + ':' + m;
  }
  else if (value.replace(regSp, '') == '')
    return bGetEmpty === true ? '' : '0:00';
  return false;
}

if (session_id == undefined || session_id == null) var session_id = '';
if (session_uniqid == undefined || session_uniqid == null) var session_uniqid = '';
if (session_name == undefined || session_name == null) var session_name = '';
if (main_directory == undefined || main_directory == null) var main_directory = '';
if (rootUrl == undefined || rootUrl == null) var rootUrl = '';
if (session_lng == undefined || session_lng == null) var session_lng = '';
if (url_atmosphere == undefined || url_atmosphere == null) var url_atmosphere = '';

var tHtmlChrono = new Date().getTime();
var iNbCNAME = 0;

// Indique si on log les erreurs JS
var bLogJSError = false;

// -- On trappe les erreurs Javascript pour les logguer
function smo_js_error_handler(message, URI, line)
{
  if (main_directory != '' && session_id != '' && session_name != '')
  {
    var xhr_object = null;   
    if(window.XMLHttpRequest) // Firefox   
      xhr_object = new XMLHttpRequest();   
    else if(window.ActiveXObject) // Internet Explorer   
      xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
    else 
    {
      // XMLHttpRequest non supporté par le navigateur   
      if (not_initialize != "")
        eval(not_initialize);
      return (false);   
    } 
    
    filename_log = main_directory + "error_js.php?" + session_name + "=" + session_id + "&message=" + message + "&uri=" + URI + "&line=" + line;
    
    xhr_object.open("GET", filename_log, true);
    xhr_object.send(null);
  } 

  // return (true) : n'indique pas l'erreur au navigateur
}

// -- On récupère l'Url des images
function get_atmosphere(){
  return (url_atmosphere);
}

// -- On récupère la Langue courante
function get_lng(){
  return (session_lng);
}

// -- On récupère le session_id
function get_session_id(){
  return (session_id);
}

// On récupère le session_uniqid
function get_session_uniqid(){
  return session_uniqid;
}

// -- On récupère le session_name
function get_session_name(){
  return (session_name);
}

// -- On récupère le main_directory
function get_main_directory(){
  return (main_directory);
}

// -- On récupère l'URL correspondant à  la racine du site
function get_rootUrl(){
  return (rootUrl);
}

// -- Active / désactive le mode wysiwyg sur un textarea
function toggleEditor(id) 
{
  var elm = document.getElementById(id);

  if (elm != null)
  {
    if (tinyMCE.getInstanceById(id) == null)
      tinyMCE.execCommand('mceAddControl', false, id);
    else
    {
      tinyMCE.execCommand('mceRemoveControl', false, id);
      for (n in tinyMCE.instances)
      {
        // On met le focus sur un autre textarea WYSIWYG
        tinyMCE.selectedInstance = tinyMCE.instances[n];
        break;
      }
    }
  }
}

if (bLogJSError)
  window.onerror = smo_js_error_handler;

// gestion de la souris
var glMousePosX = 0;
var glMousePosY = 0;

// Detects Browsers & Mobile Browsers
function parseUA(agent) {

        var numberify = function(s) {
            var c = 0;
            return parseFloat(s.replace(/\./g, function() {
                return (c++ == 1) ? '' : '.';
            }));
        },

        nav = navigator,

        o = {

        /**
         * Internet Explorer version number or 0.  Example: 6
         * @property ie
         * @type float
         * @static
         */
        ie: 0,

        /**
         * Opera version number or 0.  Example: 9.2
         * @property opera
         * @type float
         * @static
         */
        opera: 0,

        /**
         * Gecko engine revision number.  Will evaluate to 1 if Gecko
         * is detected but the revision could not be found. Other browsers
         * will be 0.  Example: 1.8
         * <pre>
         * Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
         * Firefox 1.5.0.9: 1.8.0.9 <-- 1.8
         * Firefox 2.0.0.3: 1.8.1.3 <-- 1.81
         * Firefox 3.0   <-- 1.9
         * Firefox 3.5   <-- 1.91
         * </pre>
         * @property gecko
         * @type float
         * @static
         */
        gecko: 0,

        /**
         * AppleWebKit version.  KHTML browsers that are not WebKit browsers
         * will evaluate to 1, other browsers 0.  Example: 418.9
         * <pre>
         * Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the
         *                                   latest available for Mac OSX 10.3.
         * Safari 2.0.2:         416     <-- hasOwnProperty introduced
         * Safari 2.0.4:         418     <-- preventDefault fixed
         * Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
         *                                   different versions of webkit
         * Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
         *                                   updated, but not updated
         *                                   to the latest patch.
         * Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native
         * SVG and many major issues fixed).
         * Safari 3.0.4 (523.12) 523.12  <-- First Tiger release - automatic
         * update from 2.x via the 10.4.11 OS patch.
         * Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
         *                                   yahoo.com user agent hack removed.
         * </pre>
         * http://en.wikipedia.org/wiki/Safari_version_history
         * @property webkit
         * @type float
         * @static
         */
        webkit: 0,

        /**
         * Chrome will be detected as webkit, but this property will also
         * be populated with the Chrome version number
         * @property chrome
         * @type float
         * @static
         */
        chrome: 0,

        /**
         * The mobile property will be set to a string containing any relevant
         * user agent information when a modern mobile browser is detected.
         * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
         * devices with the WebKit-based browser, and Opera Mini.
         * @property mobile
         * @type string
         * @static
         */
        mobile: null,
		
		/**
         * The device property will be set to a string containing 
         * Desktop/iPhone/iPod/iPad/Android Phone/Android Tablet ...
         * @property device
         * @type string
         * @static
         */
        device: null,

        /**
         * Adobe AIR version number or 0.  Only populated if webkit is detected.
         * Example: 1.0
         * @property air
         * @type float
         */
        air: 0,
        /**
         * Detects Apple iPad's OS version
         * @property ipad
         * @type float
         * @static
         */
        ipad: 0,
        /**
         * Detects Apple iPhone's OS version
         * @property iphone
         * @type float
         * @static
         */
        iphone: 0,
        /**
         * Detects Apples iPod's OS version
         * @property ipod
         * @type float
         * @static
         */
        ipod: 0,
        /**
         * General truthy check for iPad, iPhone or iPod
         * @property ios
         * @type float
         * @static
         */
        ios: null,
        /**
         * Detects Googles Android OS version
         * @property android
         * @type float
         * @static
         */
        android: 0,
        /**
         * Detects Palms WebOS version
         * @property webos
         * @type float
         * @static
         */
        webos: 0,

        /**
         * Google Caja version number or 0.
         * @property caja
         * @type float
         */
        caja: nav && nav.cajaVersion,

        /**
         * Set to true if the page appears to be in SSL
         * @property secure
         * @type boolean
         * @static
         */
        secure: false,

        /**
         * The operating system.  Currently only detecting windows or macintosh
         * @property os
         * @type string
         * @static
         */
        os: null,
        
        /**
         * The original userAgent string
         * @property ua
         * @type string
         * @static
         */
        ua: agent || (navigator && navigator.userAgent)

    },

    ua = o.ua,

    loc = window && window.location,

    href = loc && loc.href,

    m;

    o.secure = href && (href.toLowerCase().indexOf("https") === 0);

    if (ua) {

        o.device = 'Desktop';
		if ((/windows|win32/i).test(ua)) {
            o.os = 'windows';
        } else if ((/macintosh/i).test(ua)) {
            o.os = 'macintosh';
        } else if ((/rhino/i).test(ua)) {
            o.os = 'rhino';
        }

        // Modern KHTML browsers should qualify as Safari X-Grade
        if ((/KHTML/).test(ua)) {
            o.webkit = 1;
        }
        // Modern WebKit browsers are at least X-Grade
        m = ua.match(/AppleWebKit\/([^\s]*)/);
        if (m && m[1]) {
            o.webkit = numberify(m[1]);

            // Mobile browser check
            if (/ Mobile\//.test(ua)) {
                o.mobile = 'Apple'; // iPhone or iPod Touch

                m = ua.match(/OS ([^\s]*)/);
                if (m && m[1]) {
                    m = numberify(m[1].replace('_', '.'));
                }
                o.ios = m;
                o.ipad = o.ipod = o.iphone = 0;

                m = ua.match(/iPad|iPod|iPhone/);
                if (m && m[0]) {
                    o[m[0].toLowerCase()] = o.ios;
					o.device = m[0];
                }
            } else {
                m = ua.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);
                if (m) {
                    // Nokia N-series, Android, webOS, ex: NokiaN95
                    o.mobile = m[0];
					o.device = o.mobile;
                }
                if (/webOS/.test(ua)) {
                    o.mobile = 'WebOS';
					o.device = o.mobile;
                    m = ua.match(/webOS\/([^\s]*);/);
                    if (m && m[1]) {
                        o.webos = numberify(m[1]);
                    }
                }
                if (/ Android/.test(ua)) {
                    o.mobile = 'Android';
                    m = ua.match(/Android ([^\s]*);/);
                    if (m && m[1]) {
                        o.android = numberify(m[1]);
                    }
                    //Android Phone or Android Tablet
                    m = ua.match(/ Mobile /);
                    if (m && m[0]) {
                        o.device = 'Android Phone';
                    }
                    else
                    {
                        o.device = 'Android Tablet';
                    }

                }
            }

            m = ua.match(/Chrome\/([^\s]*)/);
            if (m && m[1]) {
                o.chrome = numberify(m[1]); // Chrome
            } else {
                m = ua.match(/AdobeAIR\/([^\s]*)/);
                if (m) {
                    o.air = m[0]; // Adobe AIR 1.0 or better
                }
            }
        }

        if (!o.webkit) { // not webkit
        // @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
            m = ua.match(/Opera[\s\/]([^\s]*)/);
            if (m && m[1]) {
                o.opera = numberify(m[1]);
                m = ua.match(/Version\/([^\s]*)/);
                if (m && m[1]) {
                    o.opera = numberify(m[1]); // opera 10+
                }
                m = ua.match(/Opera Mini[^;]*/);
                if (m) {
                    o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
					o.device = o.mobile;
                }
            } else { // not opera or webkit
                m = ua.match(/MSIE\s([^;]*)/);
                if (m && m[1]) {
                    o.ie = numberify(m[1]);
                } else { // not opera, webkit, or ie
                    m = ua.match(/Gecko\/([^\s]*)/);
                    if (m) {
                        o.gecko = 1; // Gecko detected, look for revision
                        m = ua.match(/rv:([^\s\)]*)/);
                        if (m && m[1]) {
                            o.gecko = numberify(m[1]);
                        }
                    }
                }
            }
        }
    }

    return o;
};

var oUA = parseUA();
var ua = navigator.userAgent.toLowerCase();
var isOpera = (oUA.opera) > 0;
var isSafari = (oUA.webkit) > 0 && (oUA.chrome) == 0;
var isChrome = (oUA.webkit) > 0 && (oUA.chrome) > 0;
var isGecko = (oUA.gecko) > 0;
var isAndroid = (oUA.android) > 0;
var isAndroidPhone = oUA.android > 0 && oUA.device == 'Android Phone';
var isAndroidTablet = oUA.android > 0 && oUA.device == 'Android Tablet';
var isIE = (oUA.ie) > 0;
var isIE6 = (oUA.ie) == 6;
var isIE7 = (oUA.ie) == 7;
var isIE8 = (oUA.ie) == 8;
var isIE9 = (oUA.ie) == 9;
var isIE9Engine = (ua.indexOf('trident/5.0') > -1);
var isIELess9 = ((isIE6 || isIE7 || isIE8) && !isIE9Engine);

if (!isIE)
{
  // -- Ajout de la fonction contains qui existe sous IE mais pas dans les autres navigateurs
  // -- Cette fonction est utilisée pour le onmouseout d'un div popup
  HTMLElement.prototype.contains = function(child)
  {
    try
    {
      if (typeof(child) == 'string') { child = document.getElementById(child); }
      if (!child) { return false; }
    
      if (child.parentNode === this) { return true; }
      if (child === document.body) { return false; }
    
      return this.contains(child.parentNode);
    }
    
    catch (ex)
    {
      return (false);
    }
  }
}

function getMousePos(e)
{
  if (isIE || isIE7)
  {
    var dd = document.documentElement, db = document.body;
    
    if (dd && (dd.scrollTop || dd.scrollLeft))
    {
      var scrollTop = dd.scrollTop;
      var scrollLeft = dd.scrollLeft;
    }
    else if (db)
    {
      var scrollTop = db.scrollTop;
      var scrollLeft = db.scrollLeft;
      
      //if (isIELess9)
      return [db.scrollTop, db.scrollLeft];
    }
    else
    {
      var scrollTop = 0;
      var scrollLeft = 0;
    }
    

    var x = event.clientX + scrollLeft;
    var y = event.clientY + scrollTop;
  }
  else
  {
    var x = e.pageX;
    var y = e.pageY;
  }
  
  glMousePosX = parseInt(x);
  glMousePosY = parseInt(y);
}

if (document.addEventListener)
  document.addEventListener('mousemove', getMousePos, true);
else
  document.attachEvent('onmousemove', getMousePos, true);

/**
 * Fonction utilisé par la mécanique de recherche globale
 */
function submit_globalSearch(sFilename, sAction, sSuffix, newUrl)
{
  if (sAction == "submit")
  {
    if (document.getElementById("GlobalCurrentQuery" + sSuffix).value == "" || 
    document.getElementById("GlobalCurrentField" + sSuffix).value == "" || 
    document.getElementById("GlobalSearchText" + sSuffix).value == "")
    {
      return;
    }

    // Lancement d une recherche
    sFilename += "&action=set";
    sFilename += "&guid=" + escape_ezv(document.getElementById("GlobalCurrentQuery" + sSuffix).value);
    sFilename += "&field=" + escape_ezv(document.getElementById("GlobalCurrentField" + sSuffix).value);
    sFilename += "&value=" + escape_ezv(document.getElementById("GlobalSearchText" + sSuffix).value);
    var sUrl = sync_url_ajax_eval(sFilename, "");

    if (sUrl != true && sUrl != "")
    {
      // Redirection vers la grille désirée 
      window.location.href = sUrl;
    }
  }
  else if (sAction == "cancel")
  {
    // Annulation de la recherche courante
    sFilename += "&action=clear";
    sync_url_ajax_eval(sFilename, "");

    // Rechargement de la page sans les infos de recherche
    if (typeof(newUrl) != 'undefined')
      window.location.href = newUrl;
    else
      window.location.href = window.location.href.replace("#", "");
  }
  else if (sAction == "select")
  {
    // Gestion des infos de recherche
    sFilename += "&action=select";
    sFilename += "&guid=" + escape_ezv(document.getElementById("GlobalCurrentQuery" + sSuffix).value);
    sFilename += "&name=GlobalCurrentField";
    sync_url_ajax_eval(sFilename, "");
  }  
}

/**
 * Fonction utilisé par la mécanique de recherche globale
 */
function keypress_globalSearch(e)
{
  var keynum;
  var keychar;
  var numcheck;
  
  if(window.event) // IE
  {
    keynum = e.keyCode;
  }
  else if(e.which) // Netscape/Firefox/Opera
  {
    keynum = e.which;
  }

  if (keynum == 13)
    internal_submit_globalSearch("submit");
}

/**
 * Chargement dynamique du menu
 * 
 * @param sMenuPos Position du Menu courant
 */
function loadMenuIframe(sMenuPos, sThemeGUID)
{
  if (getDomElementMenu("menuCell_" + sMenuPos) != null)
  {
    getDomElementMenu("menuCell_" + sMenuPos).className = "tabSelected bottomBar topBar";
  }
  
  if (getDomElementMenu("linkmenuCell_" + sMenuPos) != null)
    getDomElementMenu("linkmenuCell_" + sMenuPos).className = "";
  
  for (i = 0; getDomElementMenu("menuSeparator_" + i) != null; i++)
  {
    if (i == sMenuPos)
    {
      //getDomElementMenu("menuSeparator_" + i).className = "menu_separator_actif " + "bottomBar_" + sThemeGUID;
      getDomElementMenu("menuSeparator_" + i).className = "menu_separator_actif " + "bottomBar";
    }
    else
    {
      //getDomElementMenu("menuSeparator_" + i).className = "menu_separator_inactif " + "bottomBar_" + sThemeGUID;
      getDomElementMenu("menuSeparator_" + i).className = "menu_separator_inactif bottomBar";
    }
  }
  
  //apply_effects();
}

/**
 * Récupération d'une information dynamique
 * 
 * @param sType Type du contenu
 * @param sParam Paramètre à  passer
 * @return La valeur renvoyée par le serveur
 */
function common_get_dynamic_content(sType, sParam)
{
  filename = get_main_directory();
  filename += 'include/javascript/staff/common.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&type=' + encodeURIComponent(sType);
  filename += '&param=' + encodeURIComponent(sParam);
  
  result = sync_url_ajax_get2(filename, "");
  
  return (result);
}

// -- Appel d'un fichier et retourne le résultat
function sync_url_ajax_get2(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    return (xhr_object.responseText); 
  else
    return ("");
}


// Fonction vérifiant une date
function checkDate (Num, write_alert) 
{
  var re_date;
  var res = true;
  
  eval('re_date = ' + common_get_dynamic_content('get_regexp_date', ''));
  if (document.getElementById(Num).value != '' && re_date.test(document.getElementById(Num).value) == false)
  {
    // on teste le format datetime
    eval('re_date = ' + common_get_dynamic_content('get_regexp_datetime', ''));
    if (re_date.test(document.getElementById(Num).value) == false)
    { 
      if (write_alert)
        alert(common_get_dynamic_content('get_js_error_text', "bad_date_format")); 
      
      if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)            
        document.getElementById(Num).style.backgroundColor = 'yellow';
      document.getElementById(Num).select();
      
      res = false;
    }
    else if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
      document.getElementById(Num).style.backgroundColor = 'white';
  }
  else if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
    document.getElementById(Num).style.backgroundColor = 'white';
  
  if (res == true && document.getElementById(Num + '_hide') && document.getElementById(Num + '_hide').value != '' )
  {
      if (document.getElementById(Num).value == '')
      {
          if (write_alert)
            alert(common_get_dynamic_content('get_js_error_text', "bad_date_format"));
          
          if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)        
            document.getElementById(Num).style.backgroundColor = 'yellow';
          document.getElementById(Num).select();
          
          res = false;
          
       } else
        // On vérifie l'heure
        res = checkTime(Num + '_hide', write_alert);
  }
  
  return (res);
}

// Fonction vérifiant une heure
function checkTime (Num, write_alert) 
{
  var re_time;
  var res = true;
  
  eval('re_time = ' + common_get_dynamic_content('get_regexp_time', ''));
  if (document.getElementById(Num).value != '' && re_time.test(document.getElementById(Num).value) == false)
  {
    if (write_alert)
      alert(common_get_dynamic_content('get_js_error_text', "bad_time_format"));
    
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
    document.getElementById(Num).style.backgroundColor = 'white';
  
  return (res);
}

// Fonction vérifiant un nombre
function checkInt (Num, type) 
{
  var res = true;
  
  var re_int_without_zero;
  var re_int;
  var re_signed_int_without_zero;
  var re_signed_int;
  var re_float_without_zero;
  var re_float;
  var re_signed_float_without_zero;
  var re_signed_float;
  
  eval('re_float_without_zero = ' + common_get_dynamic_content('re_float_without_zero', ''));
  eval('re_signed_float_without_zero = ' + common_get_dynamic_content('re_signed_float_without_zero', ''));
  eval('re_float = ' + common_get_dynamic_content('re_float', ''));
  eval('re_signed_float = ' + common_get_dynamic_content('re_signed_float', ''));
  eval('re_int_without_zero = ' + common_get_dynamic_content('re_int_without_zero', ''));
  eval('re_int = ' + common_get_dynamic_content('re_int', ''));
  eval('re_signed_int_without_zero = ' + common_get_dynamic_content('re_signed_int_without_zero', ''));
  eval('re_signed_int = ' + common_get_dynamic_content('re_signed_int', ''));
  
  if (document.getElementById(Num).value != '' && type == 'int_without_zero' && re_int_without_zero.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_int_without_zero_format"));
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null) 
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'int' && re_int.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_int_format"));
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null) 
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'signed_int_without_zero' && re_signed_int_without_zero.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_signed_int_without_zero_format"));
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'signed_int' && re_signed_int.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_signed_int_format"));
    
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null) 
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'float' && re_float.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_int_format"));
    
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'signed_float' && re_signed_float.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_signed_int_format"));
    
    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'float_without_zero' && re_float_without_zero.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_int_without_zero_format"));

    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null) 
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).value != '' && type == 'signed_float_without_zero' && re_signed_float_without_zero.test(document.getElementById(Num).value) == false)
  { 
    alert(common_get_dynamic_content('get_js_error_text', "bad_signed_int_without_zero_format"));

    if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null) 
      document.getElementById(Num).style.backgroundColor = 'yellow';
    document.getElementById(Num).select();
    
    res = false;
  }
  else if (document.getElementById(Num).style != null && document.getElementById(Num).style.backgroundColor != null)
    document.getElementById(Num).style.backgroundColor = 'white';
  
  return (res);
}

/**
 * Ajout des infos de session
 * 
 * @param sURL L'URL de départ
 * @return L'URL contenant les infos de session
 */
function addSession(sUrl)
{
  if (sUrl.indexOf('?') == -1)
    sUrl += '?';
  else
    sUrl += '&';
  
  var sDate = new Date();
  sUrl += session_name + "=" + session_id + "&internalurltime=" + sDate.getTime();
  
  sMemberId = common_get_dynamic_content('arr_mysession', 'MEMBER_ID');
  sUrl = sUrl.replace("@@MEMBER_ID@@", sMemberId);
  sUrl = sUrl.replace("%40%40MEMBER_ID%40%40", sMemberId);
  
  return (sUrl);
}

function checkChangesForMenu(sUrl)
{
  checkChanges(addSession(sUrl), session_lng);
}

function window_open(sUrl, sTitle, sParams)
{
  window.open (addSession(sUrl), sTitle, sParams)
}

function drawHtmlChrono()
{
  if (document.getElementById('divHtmlChrono') == null)
    return;
    
  var tEnd = new Date().getTime() - tHtmlChrono;
  var iMSec = 0;
  var iSec = 0;
  var iMin = 0;
  
  iMin = Math.floor(tEnd / (1000 * 60));
  tEnd -= iMin * 60 * 1000;
  iSec = Math.floor(tEnd / 1000);
  iMSec = tEnd - (iSec * 1000);
  
  var sTime = '';
  
  if (iMin > 0)
  {
    sTime += iMin + ' : ';
  
    if (iSec < 10)
      sTime += '0';
  }
  
  sTime += iSec + '.';
  
  if (iMSec < 10)
    sTime += '00';
  else if (iMSec < 100)
    sTime += '0';
  
  sTime += iMSec;
  
  if (iMin > 0)
    sTime += ' minutes';
  else
    sTime += ' seconds';
  
  $('#divHtmlUA').text('User-Agent in JS : ' + $.browserInformation.UA.ua);
  document.getElementById('divHtmlChrono').innerHTML = '<b>Time taken to draw this page was ' + sTime + '</b>';
}

/**
 * Définition du nombre de CNAME utilisable
 */
function setCNameMaxValue(iMaxValue)
{
  if (typeof(iMaxValue) != "number")
  {
    var reg = new RegExp("^[0-9]+$", "g")
    if (!isNaN(iMaxValue))
      iNbCNAME = parseInt(iMaxValue);
  }
  else
    iNbCNAME = iMaxValue;
}

/**
 * Indique le numéro du CNAME courant
 */
var iCurrentCNameStep = 0;

/**
 * Parallélisation des noms de domaine
 * @return La nouvelle adresse
 * @param L'adresse a traité
 */
function translateUrl(Url)
{
  // Utilise-t-on la méthode des CNAME ? 
  if (iNbCNAME <= 0)
    return (Url);
    
  // Position du premier . dans la racine du site
  var iPoint = rootUrl.indexOf('.', 0);
  
  if (iCurrentCNameStep > 0 && iPoint > 0)
  {
    // Le point a été trouvé
    
    // Construction de la nouvelle racine
    var sNewRootUrl = rootUrl.substring(0, iPoint) + iCurrentCNameStep + rootUrl.substring(iPoint);
    
    // Changement de l'URL
    if (Url.indexOf('//') == -1)
    {
      // On préfixe l'url car il n'y a pas de préfixe
      Url = sNewRootUrl + main_directory + Url;
    }
    else
    {
      // L'url est déjà  préfixée
      var reg = new RegExp(rootUrl, "g"); 
      Url = Url.replace(reg, sNewRootUrl);
    }
  }
  
  iCurrentCNameStep = (iCurrentCNameStep + 1) % (iNbCNAME + 1);
  
  return (Url);
}


function insertAtCaret(obj, text) 
{
  if(document.selection) 
  {
    obj.focus();
    var orig = obj.value.replace(/\r\n/g, "\n");
    var range = document.selection.createRange();

    if(range.parentElement() != obj) 
    {
      return false;
    }

    range.text = text;
    
    var actual = tmp = obj.value.replace(/\r\n/g, "\n");

    for(var diff = 0; diff < orig.length; diff++) 
    {
      if(orig.charAt(diff) != actual.charAt(diff)) break;
    }

    for(var index = 0, start = 0; 
      tmp.match(text) 
        && (tmp = tmp.replace(text, "")) 
        && index <= diff; 
      index = start + text.length
    ) 
    {
      start = actual.indexOf(text, index);
    }
  } 
  else if(obj.selectionStart) 
  {
    var start = obj.selectionStart;
    var end   = obj.selectionEnd;

    obj.value = obj.value.substr(0, start) 
      + text 
      + obj.value.substr(end, obj.value.length);
  }
  
  if(start != null) 
  {
    setCaretTo(obj, start + text.length);
  } 
  else 
  {
    obj.value += text;
  }
}

function setCaretTo(obj, pos) 
{
  if(obj.createTextRange) 
  {
    var range = obj.createTextRange();
    range.move('character', pos);
    range.select();
  } 
  else if(obj.selectionStart) 
  {
    obj.focus();
    obj.setSelectionRange(pos, pos);
  }
}

/**
 * Application des différents effets de styles
 */
function apply_effects() { 
  $(document).ready(function(){ _apply_effects(); }); 
}

/**
 * Retourne un objet indiquant si il y a une scrollbar horizontale et/ou verticale
 */
function _getScrollBarsState()
{
	var _scrollBarHorizontalState = false;
	var _scrollBarVerticalState = false;
	if ($(document).width() > $(window).width()) _scrollBarHorizontalState = true;
	if ($(document).height() > $(window).height()) _scrollBarVerticalState = true;
	
	return (
		{
		"scrollBarHorizontalState": _scrollBarHorizontalState,
		"scrollBarVerticalState": _scrollBarVerticalState,
		"scrollBarHorizontalDelta": $(document).width() - $(window).width(),
		"scrollBarVerticalDelta": $(document).height() - $(window).height()
		}
		
	);
}

/**
 * Marge appliquée à droite
 */
function _getBodyGeneralMarge() {
	var iMarge = 0;
	var _scrollBarsState = _getScrollBarsState();
	
	//if (_scrollBarsState.scrollBarHorizontalDelta > 0) iMarge += _scrollBarsState.scrollBarHorizontalDelta;
	if (!_scrollBarsState.scrollBarVerticalState && _scrollBarsState.scrollBarHorizontalDelta > 0 && _scrollBarsState.scrollBarHorizontalDelta <= 3) iMarge += _scrollBarsState.scrollBarHorizontalDelta;
	
	if (_scrollBarsState.scrollBarHorizontalDelta == 21 && $.browserInformation.isIE8())
	{
		//-- If horizontal scrollbar visible && IE8 
		iMarge += _scrollBarsState.scrollBarHorizontalDelta;
	}
	
	if (_scrollBarsState.scrollBarHorizontalDelta == 17 && $.browserInformation.isIE9())
	{
		//-- If horizontal scrollbar visible && IE9 
		iMarge += _scrollBarsState.scrollBarHorizontalDelta;
	}
	
	return iMarge; 
}

/**
 * Récupération de la taille de la zone BODY_GENERAL à partir du document
 */
function _getBodyGeneralWidth() {
	var sResult = $(document).width() - _getBodyGeneralMarge();
	if ( $("#mainContent").length == 1 ) sResult -= $("#mainContent").position().left;
	return (sResult); 
}

/**
 * Récupération de la taille de la zone BODY_GENERAL à partir de la zone window
 */
function _getBodyGeneralWidthFromWindow() { 
	var sResult = $(window).width() - _getBodyGeneralMarge();
	if ( $("#mainContent").length == 1 ) sResult -= $("#mainContent").position().left;
	return (sResult);
}

/**
 * Application des différents effets de styles
 */
function _apply_effects()
{ 
  //-- Pour tablette
  if ($.browserInformation.UA.mobile != null)
  $("body").addClass("body_device");
  
  if (typeof(bNoComboBoxUI) == "undefined" || !bNoComboBoxUI)
  {
    //-- Application de la combobox jQuery
    $("select:not(.keepselect)").combobox();
  }
  // Add extended functions in select jquery to change combobox-ui selectedIndex or CSS
	$.extend($.fn, {
		setCSSComboboxUI: function(prop, val) {
			var result = false;
			if ( this.prop( "combobox-ui" ) )
			{
				this.data().combobox.input.css( prop, val );
				result = true;
			}
			return (result);
		},
		selectItemIndexComboboxUIByIndex: function(index, stopPropagation) {
			var result = false;
			if ( this.prop( "combobox-ui" ) )
			{
				this.data().combobox.selectItemByIndex( index, stopPropagation );
				result = true;
			}
			return (result);
		}
	});
  
  //-- Pb alignement image datepicker
  if (typeof($.datepicker) != "undefined")
  $("img." + $.datepicker._triggerClass).css("vertical-align", "middle");
  
  //-- PlaceHolder sur les inputs
  $(function(){    $("input[placeholder], textarea[placeholder]").textPlaceholder();  });
  
  /*******************************/
  /** [BEGIN] Block Dialog **/
  /*******************************/
  if ($("#DIV_DIALOG_BODY").length == 1)
  {
    if ($("#modulesContent").is(':visible'))
    $("#DIV_DIALOG_BODY").css("width", "800px");
    else
    $("#DIV_DIALOG_BODY").css("width", (800 + $("#modulesContent").width()) + "px");
    
    $('#DIV_DIALOG_CAPTION').addClass("block_caption_bg_gradient");
    if (!$.browserInformation.isLtIE8())
    {
        /** new_logo **/
        $('#DIV_DIALOG_CAPTION').add_layer("url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAAAbCAYAAABIiqyBAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACVpJREFUeNrsWwtsFFUUvbPbdrdAS5dCqYgKLZ8qgmLxA4IKtGgiqICo+BdiQSTBD9iqaMJHlBBEiEa7UQExCBStSq0fEE38RS1itIKotCgtUBW3gHT72d3xvu555DLOtnysNLA3OdntzJs3b94979x732wN0zQpalFryoxTlSSPfTK8xfqOddTTTn86vbhjNs9ww/F214ZxI2ME4wxGDaOUsZbxeUvPkzkxnWKi66RV2zmMFxkDLcezGVMZrzCmM6pbchBRkrQeG8LIZNQx3mMcZBQyekUSLMZEhocxnlEfJcnJa/GMxYy7hD9+Y+xsgiDSxjBGM1a31AAdUR+dcJvMuNuyYM9kXHoUfQxvyQFGleTEWE/gAELF0doexi5GD0YiYyzjbISo15HHmFGStHILmU52E0+voVIFQ1YqC0GM9sfY9TJVnDEqGRkML2MwoOxKhKlcNYxouGmlFmRypLp/o87xP7Ob3Ie2G5B7TD4OgpQz7mVUQCm2MqbYJK2q4ukbVZJWrSIOauM4SJd2KKY3KmawO3lBG0EmRuiK4yxXv8Q+iTRmIv3A6C6OKUJ2FH+7EZoqjuX+UZK0kNWFXJTRbjMN7byMNlVfQQcCSX+bwcQR5PA7yAgc7k/TUCSSYcnODOQcVlMqch1KYmkV4rsKS5uQIL8cJUkrMZMjeYzRQMM6FtJgVpQdNb0DFf6M8pJ9g+lAfWcO9PXhnIV973Lup7pgIvKXoxculMxNWT1Si2A03By79aHwRpZard8wvrdpozat1A4oe5j8kHg751zM6M34K0SOzXUhd6VBZuce7UpP752wecvADu/UFlXdTlv3DaEkVwUNSX6LkmJ9tLR8TlvTWd8H4cMXYZzq/mqf/w9GN8ZPIvy0R9mczNiB51DKk8rohzbdkavEMXajQlKWjmS3DY5/K8Paqf7uph1jAWOCcipIkgxJno4SVdlcRg4jAU5y4/MZxmwK75IqEr3EuBp9ubF6VzLeZaxiPOw0AotV5XMwkESxzhpKjKlm1TFSV+580L1l/6DPORx9xO1usRnyuYwvGDNBglWoaFQYGYiqJxXOTQCRHgOZHkc4CkBVnHim5yn8DugSKFIIRFHkm8b4QL27OZWrGyfIMAGxui8cMRnHlojqT63IF+CUPlCL5YxHGA+gzaOMq5AfqL7OZ8xidGF8xihRE8+VT2O5kxC7l1yOOvIH25JpGgsGdijuzmxRhLoJjrWa2pGNB+lcIGEQqrCCUYVxqXtfxtjASEOJPAl9qAUxjMIvC5cikpRReHu/P55tNCqn15HLhJXE6/V6wH5p6uIbwNTWYGp82Tbj+QuTUNBcBzk5OVJJ1GS8wbiN8aql6X2MRSDFZ010+RYmV0n1pyDT5RHa6vuNxae2rg4j+EtDKC7PWz6vcG9Dp3JObJUCPCHaJGF1q3c6tzNuBTH64p7a0ZGS0gyUy3bPamdqx3c7Yw4ryWy9UjJFBq2hmDiulRAkDZ9WgmRC5jccQ5+3QbbtJi0foeZqcawL/r6DcT3IoeJ+CiR6I1bwU8hJrFbE2Ma430oe03S4XA7/hiTXrl/JdL6P0OYWba5ldGI8Z6OGVdg/mYOxdbK5dzw+XRHmQj3LjSDglbi3yo16ys20NLBROiULx9IglSagl2MJSJQmjmtF0tdvx7ntwtFrGOvFNbmi7/ViDFnoy4TTymweLgtJXollbPnol8Q4PJZrk3GsCDmDxFrE9R5aeJDMqhg+A2FkBTa2aiH5syDhDzG2UPi3HlOQ9xBymIVQp4uEkzmMmOuDZlxp4y6tYS7GSs4WC3cS8pGvbAqPGuQwlchLfqTwy77sI1goPaBOHyK3mgEFfRvn6iRJPMLZ2qkFiGf5WMEGws9TIhx5QBQfvufgOh/IMB/XFQgHStUqgzMH4G/dnwfX54nNAzu1yEQfAzCRcmxpgjDzbSoGA2rxMeMTC1SIeRArdyImcDFW3LmQeeWEV0CQGMi+ymXORp4SwPXviI0t5bw/kRQSxt2fy+X8eOcBah/Lp0znRoSWe9DmAiSmSyjy+xhFoEFQMhVyLlRJJxJWinCdC+M5j3GNeK5MhMZf8WyHSuBMTGSeTdmnVmIHMfnafHDEOJBJk2QArvHAQflo7xVkvEGscg+UwHrPMlyj7+WLQJI8m/NlGFeupR9p2xGrFzWzfzAPyjDbsjexG+Eq1uKEbYAi1RgkgGMxD/txXDlvKiS+MqxeOso3Vh9LgNMYN1P4ZwPrmlGFgCC56v9ZfOZDxcjynBkg4BTkU9r8yF9q9YBkuPE1kxNopxcIR2jl0E4pEEQqs+Q4k0R4kLmF19LOK8iiiTfORkk04bRi5IqxbcLxXBvia3se8XuBzbkUqEI8FKKdXlXC2iIHCGAeh9uEtA/h9Dbi2FI4YC7Is9xpBGuqG5Jpt7+b/rnjaszTkxR+GZgfYbc1iHsOsxz3I0dyitJXWaJo8zc+U236HYVKp04qSVqEKsaHSS4Rkp8nznng1Cz0MR/ndHgxxXWT0GaDhSBrRDuvqFRykJOU2aiYzEdyEGbk2MrE2CJVZ1+hbH0CJafad9gL+b0XE7wOK78IiqC+/44VeAvCSD2U9mUojNor+RoEmwaHvS/uWwmn632YZUHORRJiqqmjq5KqatOZKIE/0d8MPONym4RVq476RdubCC+FCFU9oYDFuF8CwsfDInxvwzPPBAHXI2FVyflIjM0lS+CTbQ8kC+RLlwppKYH115uQbPYWK0zH83IcG48J7oZVqSb8aazk+zGxKchjhiIpVoQpBRE/tilJS0HC0Y3lh/Mgra6cSt9Vsyg4/Hp3dR0cP91y/Ugo0XhUIaMQNvqBnLUg5nRUPwS1WYh+q3FuLZ5jDAhRC4LPxPmdXAI/cjJuy+dDXbKbCaHaVkG5umIlVdG/35S+hgntgpW4C6tYJ+UBKIze8EpBHrA7QtKYATU4bHUGzFix0BvzoH5QIqsVgwQB9F8IeLCnss9m32sjqqoUKId+xnuwADpCPTSpJoDo0X+p+B93dzlRNdjhZjxU4CPsfzQ6wOWopS98I6h4z510+FviE2vRf6loYTM4GkEX4sgwhhgUGh4ynYZJRhHylUMrVOUlvdp+S+8a9XzQSf/hrw+bHuIR3ChKkhY0hxHiskcptuE3DbrTSYGzGsjN6m1stSu7A2YcNfObkv+aIC5UME0S5R8BBgDQGdvu4s6yiAAAAABJRU5ErkJggg==) top right no-repeat");
        /** old_logo **/
        //$('#DIV_DIALOG_CAPTION').add_layer("url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAAAQCAYAAADXs9fyAAAAFnRFWHRDcmVhdGlvbiBUaW1lADA0LzA4LzExQTrqSwAAAAd0SU1FB9sECwg5Kk2AclkAAAAJcEhZcwAACvAAAArwAUKsNJgAAAAEZ0FNQQAAsY8L/GEFAAAMLklEQVR42uVYCVRVVRfe9943weO9EAnkOZCUUibhBIoIiqgopP5/gwPmVFk5JdrwO+GQJg6p5F9qKk6V/paVOIYjmhoaqTnggIID4wPecN9w77vjfw5d+p+Erb+1WrJW7rXOuufus88+++79nX32uQQ84jTz3UWBGp1qAEGSo2na4W+z2W9eLri+Xm8w5h09ssPV2PY9bCIa24DGok8yNxhdTvdIg9HYy2QyhTYJ8CdJgoKqGiucP3+FO3w091pltXlvUeGpbxvb1odJjyQgFi9c1QJ9+ZLOXTqFd45qD35GESSiCjy8HUhKBpkLhts3ZVj80aeQvX//waciwuf/krvL09h2Pwy6DxCh7eIjvN/vFJy41NgGKnaFIVuK6vH06KFHfPOf0bVofmZTnhc+6zsg8YmY7uFQ7TwHDlc5cDwNbs4Mbk8JsFwJmILD4emg2TDyjQ/gy+07c8B9e9aDdE6ZPLsjw3qIdeuXnfPmL1zwsZ+luqaX0Wi4Pm/Be4XeY/96b+EzHo4PHTGkX25UbCw7bdpcLQGEyUE77q7bsFzEMq++Pq15WbHkmLfhFumyaw2JHXbew/zvzycQWjLwSZL0LQFS9hNFt6r3czsr8NihX573YfnKOI0q4GZSh5yig5cGBJCyqjshk26S1LCSxDYVJE9NUseDp88WTtRW2n6Kp1TG28kdDxfeBwjsdPQYh1odCLDDcSBmNDIYgtAjFdmRWY8/GD2ciH/kz+h7e+Ksd3r27DH8hZfjoahiL4iSALLMoexgQYAoQ4DA4KiAUssxiA3fCm1Nr0Bc/5fh3IUrs5jqqzneujJmLVPfKq9YK0pyrCgIMuPxXDT4Gsds3LKMmTB+en+adq1UqSibiiJbyDLxSdam5UvwvLGjp871cNwYHx9tlcPl1uk0Pv+0O2yMRq3eh3j9t279dyWW69Mv9QuW0Z3O/OpqUUUpzGqii0+Ibb9EyLnYX8tzjlwV4ZcmA5cgSKxpYNSPbx+40Kcrz9myCIJ0yiCGUKRvulpl/NnDmdfKhNwMZMkfQL5FEb4XVNRj/2F58yfomHTLMgRTlHplSueTmaTX97VG7TBy8Dalra8fGO8MgneoEqy6flgD/KD6WQfLKTIRD5LxksN6sN6GsgC219yQ/oZsxDQ4eXQztVoTH9crCsqsh8HFViAg1IDdfQNs7kKg3dfB6bkBNFMCvrpWUF1phNXrdsC0ya+CKPAvIhXe/oKbZWXprIfrJBOQ5GfwTbLRjuaFd4uX4jGrjTaJkrh085bMGK1a16faYh2XMnhM99ThE5Noh3Os0c83MWvjimiHw7XrWnHRNtrJPOZys830Pj6qOv1IH8ETjqCgZo7TkiyE2Ji8SMwnZDUhSZwOAVklyh6tJHmI3CupBkGg15OEJmtg1NluFKFPEURHhsdjDRkY9VOcmtQvQHPODYo63y2ly6m3RMkdShE+awZGnYnWkE36IR2v7c2PSfX+QOzI4nqOdSn9NPR4A7VuqJ/hJd9H6afCr9kFFF4wkhun8CO85mBKU/hBD5JR1huEY6i0ho6uMGWsmyJfR+O8+lO9J7g5z0um5s1D/AM5KLPkITBUITAUoHYZZYZrCCB3oNpSCuVVxRAXMQ8KLogwZ94c6PRcBLQLf+pZpKKltz4ZiAFody3fvGnFndVrFt/lOH4xz/NJeGz79tUbabvz5KB/jJ2OKpRE2uXmb98rbeNyMWE1NM1dKynt37lrypss69ktSNIVF8c5UKrKLSy+tzU6dlB8l67JnTwC31QEnmtFXKZRKr8tEXws/IoItDTBo46EmojyvFsUGIMkyyZOssnfnmk7SQbWR6s2rqcoXe0GUVE+IkmQv50IyZ1zt/jpA/btOvPcRFYqjBREwelhtCmqeg7Gu7LuHYNhmwIMP5QxFirBGod3Ja4v0DO1gUB1UwIYjFq2wqvLArgOwOf+ekVvTAMytSCsOyIUoFQ2sI7ey6aM+oOKLqd3jSHJ0ogmAU1Jj1QEtOsmEKSE6oUqcLNW1MzAMhw8HtAenu+2EX7M9YH3Z04CDrnc4XJCqxYh2gtnoDk27TdAyDLjpB0Uco96yLBRIUX3St4VJan2VhLb+6Wx5VbLhyqSOFJVZSu3OO1+1VarvHZOetYbCxbqnW4mIjjA31Rhs85AyJp49fyeEjRteHSPQWs4UVyl1WhsLqs1GhW5e2oxQBDHJInvjbqrgFTLv7IAJSd87JOGxMjvyvbnJ44SRc1ojZoUWNY1URL53CE9T8zD80WRUHk8xG8JIOdCQqqVLv0IRL88tbpJDbLN4GEIhzcgoKF6QQl6dj22y2s8ET3yFDBhMBxWQOHEO18RMytBxSCoO/MfJNPHS6bOrvuODCXYD6odihSw4eyx0nug2mYjGZZHdYMNZYVzyEk+UF2N+nYaIp8ZDE+3GwE1ZSb4IP0ArM1aC1qUvSmSwoFH+5D/3UKl5iq6rNK8qE2H6LcuFRY2UVFUgVpNfhYZNaBptc0+E91j37yaf7A2oG0jez2Jzp2mo9PnGEwtgjZdPXCwBleI4R0TUznWs/TpyN4XSK1af/bk7vHNI+M1bYLbEExpSZZep25WuxihOoaSwuizRS9qffUthaI7pcguAA8HwLKS/NXBFI3V7L46IvnUUCz+eU6vQIaxHvp0R5fhE4fmb3fQElhRqwXDz0mBDodlqSBopwxLOPU15i3dFP6RVi22JhUHhym7tyHCwQ/ykovwqvj1yntdSo9Qijw85xKuRRSwBClBjfBa50Ey3utFPMCmMGXtOhnvDILn4+OmCOm778fS9cJb2y5evSGpiVCwO51gNjuAYTQwLGknUNZJMGFcNiQkDYPVWauhSaA/TikQ7O8DjxkMUFRczGEMeOu7V2k2igTxlSkk+HUgyZ4s4/zCZrVvsDgcgTzPiT2io/LqZAWOD9T56JwkyCMslZYtdXw1Sf0gSSLp8jCtOY/naERMiqn0lxNcbnaWR6OmQtxutxXLkYIuXxRlZ7n53vD2wZmik5Y4q0Uka8yiXFMpOFFWCbY76eObs5NrfTcyKbfaZpHL0We2we+0TZLtFqkWES4XabDZBcpOO0/X2SFKqidcDOuuyxCt/wAQeMfPRo7vozjbu9rH78X13uvPwVRXoIYpY38kg/kZXus1ZBe21+V1VCz0GsPgTENgeK3+JJYu++bQsaOJNvM4UxNdDFwryIYJQ0/Cvm/MMGHSKCB9NeDvb4RAfQDwaOu5LDdh4qwVcOPGTbhy+cJlpKLEWx9JkptdbteMKwWVu0gZmmq1GnyrWHHv2o/Xn2zfoyDn8OGdoW2iF4kyxKEC09SmdYucyhpa53I554a27TqHIKmfaId9tlqlOv7O5LFnV3y69SxdU/Nly6eilqKbQj9ZklpTFLUDr5Xc9Si380R8hsvt/Hj11xFEZSX3OAW+KEMIWoYRA3R6vsThkC9brHd3rPwiKkPg2R4IZ205TjsJz0eg06Aj04D7fWPT72zLTjvGsOyXyzZFLyYorjtKgB1cLP/C3+7HlHLE4eyQ16CArsX706ZMHjJ//iD4PHs8pMRsgvYRfYGnCDAa9LVA8LAsuG1F0DuhF+zesw+SkwfBD6fy0mXRdaC+umc6JoxnGHYyz/GSj06z7mbB6VWYHx3T189cY1/C80JPkiJLjb76qVcuHi/AY+0i46PQdXMJyvjB+KrZzGCcc/psDhsTl+xXZbFnoEKzN0kQ9wID/KeeO3voqvd667+LG4pAkY7KmmqKaDnMw5cnCrzQbEHa+eUfftbfKAiVS4DielCgNht8m02dMur7i3jemh0JiW7GMfCdMfm1BfjXu8f63K65tNjtZvpQKqrKX9/83UmvHMhv7Pj91WDIqHfj+L1M2+gglSH0u8xVm/Jl2ZJvsZfnt2vfFTmCQs2ImjpfrfbNT0ubks8wTP7IkaOwkzJQHfHAzVOcd4o6kXOAauzv/yvob5ch/h9qFRYVVlZWtvitca+GzZwxGUhCgL379kNVpQVahZqgU+cugK6QMH36TDhwYM8RUvfsXIm9wja23Q+DHklAYAqL6BFQdKlgdEjLFgkD+vc2de0SCX5+vlBRUQ55eXnS3r0HrzMMvVuW+W/Q/U5qbHsfFj2ygPgfBbQCsOCrM67GfVCzoXbeYHjiuMNx297Y1j1s+i8vdASz4BxtHgAAAABJRU5ErkJggg==) top right no-repeat");
    }
    
    //-- Fusion des boutons Add sur les fiches
    if ($("#btn_dialog_new img").length == 1 && $("#btn_tab_new img").length == 1)
    {
      $("#btn_dialog_new img").removeAttr("onclick");
      $("#btn_dialog_new img").click(function(){
        $("#btn_tab_new img").click();
      });
      $("#btn_tab_new").hide();
    }

    $.dialog.init();
  }   
  /*******************************/
  /** [END] Block Dialog **/
  /*******************************/
   
  /*******************************/
  /** [BEGIN] Block Caption Bar **/
  /*******************************/
  /** Backgrounds **/
  if ($("#DIV_GRID_CAPTION").length == 1)
  {
    $('#DIV_GRID_CAPTION').addClass("block_caption_bg_gradient");
    if (!$.browserInformation.isLtIE8())
    {
        /** new_logo **/
        $('#DIV_GRID_CAPTION').add_layer("url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAAAbCAYAAABIiqyBAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACVpJREFUeNrsWwtsFFUUvbPbdrdAS5dCqYgKLZ8qgmLxA4IKtGgiqICo+BdiQSTBD9iqaMJHlBBEiEa7UQExCBStSq0fEE38RS1itIKotCgtUBW3gHT72d3xvu555DLOtnysNLA3OdntzJs3b94979x732wN0zQpalFryoxTlSSPfTK8xfqOddTTTn86vbhjNs9ww/F214ZxI2ME4wxGDaOUsZbxeUvPkzkxnWKi66RV2zmMFxkDLcezGVMZrzCmM6pbchBRkrQeG8LIZNQx3mMcZBQyekUSLMZEhocxnlEfJcnJa/GMxYy7hD9+Y+xsgiDSxjBGM1a31AAdUR+dcJvMuNuyYM9kXHoUfQxvyQFGleTEWE/gAELF0doexi5GD0YiYyzjbISo15HHmFGStHILmU52E0+voVIFQ1YqC0GM9sfY9TJVnDEqGRkML2MwoOxKhKlcNYxouGmlFmRypLp/o87xP7Ob3Ie2G5B7TD4OgpQz7mVUQCm2MqbYJK2q4ukbVZJWrSIOauM4SJd2KKY3KmawO3lBG0EmRuiK4yxXv8Q+iTRmIv3A6C6OKUJ2FH+7EZoqjuX+UZK0kNWFXJTRbjMN7byMNlVfQQcCSX+bwcQR5PA7yAgc7k/TUCSSYcnODOQcVlMqch1KYmkV4rsKS5uQIL8cJUkrMZMjeYzRQMM6FtJgVpQdNb0DFf6M8pJ9g+lAfWcO9PXhnIV973Lup7pgIvKXoxculMxNWT1Si2A03By79aHwRpZard8wvrdpozat1A4oe5j8kHg751zM6M34K0SOzXUhd6VBZuce7UpP752wecvADu/UFlXdTlv3DaEkVwUNSX6LkmJ9tLR8TlvTWd8H4cMXYZzq/mqf/w9GN8ZPIvy0R9mczNiB51DKk8rohzbdkavEMXajQlKWjmS3DY5/K8Paqf7uph1jAWOCcipIkgxJno4SVdlcRg4jAU5y4/MZxmwK75IqEr3EuBp9ubF6VzLeZaxiPOw0AotV5XMwkESxzhpKjKlm1TFSV+580L1l/6DPORx9xO1usRnyuYwvGDNBglWoaFQYGYiqJxXOTQCRHgOZHkc4CkBVnHim5yn8DugSKFIIRFHkm8b4QL27OZWrGyfIMAGxui8cMRnHlojqT63IF+CUPlCL5YxHGA+gzaOMq5AfqL7OZ8xidGF8xihRE8+VT2O5kxC7l1yOOvIH25JpGgsGdijuzmxRhLoJjrWa2pGNB+lcIGEQqrCCUYVxqXtfxtjASEOJPAl9qAUxjMIvC5cikpRReHu/P55tNCqn15HLhJXE6/V6wH5p6uIbwNTWYGp82Tbj+QuTUNBcBzk5OVJJ1GS8wbiN8aql6X2MRSDFZ010+RYmV0n1pyDT5RHa6vuNxae2rg4j+EtDKC7PWz6vcG9Dp3JObJUCPCHaJGF1q3c6tzNuBTH64p7a0ZGS0gyUy3bPamdqx3c7Yw4ryWy9UjJFBq2hmDiulRAkDZ9WgmRC5jccQ5+3QbbtJi0foeZqcawL/r6DcT3IoeJ+CiR6I1bwU8hJrFbE2Ma430oe03S4XA7/hiTXrl/JdL6P0OYWba5ldGI8Z6OGVdg/mYOxdbK5dzw+XRHmQj3LjSDglbi3yo16ys20NLBROiULx9IglSagl2MJSJQmjmtF0tdvx7ntwtFrGOvFNbmi7/ViDFnoy4TTymweLgtJXollbPnol8Q4PJZrk3GsCDmDxFrE9R5aeJDMqhg+A2FkBTa2aiH5syDhDzG2UPi3HlOQ9xBymIVQp4uEkzmMmOuDZlxp4y6tYS7GSs4WC3cS8pGvbAqPGuQwlchLfqTwy77sI1goPaBOHyK3mgEFfRvn6iRJPMLZ2qkFiGf5WMEGws9TIhx5QBQfvufgOh/IMB/XFQgHStUqgzMH4G/dnwfX54nNAzu1yEQfAzCRcmxpgjDzbSoGA2rxMeMTC1SIeRArdyImcDFW3LmQeeWEV0CQGMi+ymXORp4SwPXviI0t5bw/kRQSxt2fy+X8eOcBah/Lp0znRoSWe9DmAiSmSyjy+xhFoEFQMhVyLlRJJxJWinCdC+M5j3GNeK5MhMZf8WyHSuBMTGSeTdmnVmIHMfnafHDEOJBJk2QArvHAQflo7xVkvEGscg+UwHrPMlyj7+WLQJI8m/NlGFeupR9p2xGrFzWzfzAPyjDbsjexG+Eq1uKEbYAi1RgkgGMxD/txXDlvKiS+MqxeOso3Vh9LgNMYN1P4ZwPrmlGFgCC56v9ZfOZDxcjynBkg4BTkU9r8yF9q9YBkuPE1kxNopxcIR2jl0E4pEEQqs+Q4k0R4kLmF19LOK8iiiTfORkk04bRi5IqxbcLxXBvia3se8XuBzbkUqEI8FKKdXlXC2iIHCGAeh9uEtA/h9Dbi2FI4YC7Is9xpBGuqG5Jpt7+b/rnjaszTkxR+GZgfYbc1iHsOsxz3I0dyitJXWaJo8zc+U236HYVKp04qSVqEKsaHSS4Rkp8nznng1Cz0MR/ndHgxxXWT0GaDhSBrRDuvqFRykJOU2aiYzEdyEGbk2MrE2CJVZ1+hbH0CJafad9gL+b0XE7wOK78IiqC+/44VeAvCSD2U9mUojNor+RoEmwaHvS/uWwmn632YZUHORRJiqqmjq5KqatOZKIE/0d8MPONym4RVq476RdubCC+FCFU9oYDFuF8CwsfDInxvwzPPBAHXI2FVyflIjM0lS+CTbQ8kC+RLlwppKYH115uQbPYWK0zH83IcG48J7oZVqSb8aazk+zGxKchjhiIpVoQpBRE/tilJS0HC0Y3lh/Mgra6cSt9Vsyg4/Hp3dR0cP91y/Ugo0XhUIaMQNvqBnLUg5nRUPwS1WYh+q3FuLZ5jDAhRC4LPxPmdXAI/cjJuy+dDXbKbCaHaVkG5umIlVdG/35S+hgntgpW4C6tYJ+UBKIze8EpBHrA7QtKYATU4bHUGzFix0BvzoH5QIqsVgwQB9F8IeLCnss9m32sjqqoUKId+xnuwADpCPTSpJoDo0X+p+B93dzlRNdjhZjxU4CPsfzQ6wOWopS98I6h4z510+FviE2vRf6loYTM4GkEX4sgwhhgUGh4ynYZJRhHylUMrVOUlvdp+S+8a9XzQSf/hrw+bHuIR3ChKkhY0hxHiskcptuE3DbrTSYGzGsjN6m1stSu7A2YcNfObkv+aIC5UME0S5R8BBgDQGdvu4s6yiAAAAABJRU5ErkJggg==) top right no-repeat");
        /** old_logo **/
        //$('#DIV_GRID_CAPTION').add_layer("url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAAAQCAYAAADXs9fyAAAAFnRFWHRDcmVhdGlvbiBUaW1lADA0LzA4LzExQTrqSwAAAAd0SU1FB9sECwg5Kk2AclkAAAAJcEhZcwAACvAAAArwAUKsNJgAAAAEZ0FNQQAAsY8L/GEFAAAMLklEQVR42uVYCVRVVRfe9943weO9EAnkOZCUUibhBIoIiqgopP5/gwPmVFk5JdrwO+GQJg6p5F9qKk6V/paVOIYjmhoaqTnggIID4wPecN9w77vjfw5d+p+Erb+1WrJW7rXOuufus88+++79nX32uQQ84jTz3UWBGp1qAEGSo2na4W+z2W9eLri+Xm8w5h09ssPV2PY9bCIa24DGok8yNxhdTvdIg9HYy2QyhTYJ8CdJgoKqGiucP3+FO3w091pltXlvUeGpbxvb1odJjyQgFi9c1QJ9+ZLOXTqFd45qD35GESSiCjy8HUhKBpkLhts3ZVj80aeQvX//waciwuf/krvL09h2Pwy6DxCh7eIjvN/vFJy41NgGKnaFIVuK6vH06KFHfPOf0bVofmZTnhc+6zsg8YmY7uFQ7TwHDlc5cDwNbs4Mbk8JsFwJmILD4emg2TDyjQ/gy+07c8B9e9aDdE6ZPLsjw3qIdeuXnfPmL1zwsZ+luqaX0Wi4Pm/Be4XeY/96b+EzHo4PHTGkX25UbCw7bdpcLQGEyUE77q7bsFzEMq++Pq15WbHkmLfhFumyaw2JHXbew/zvzycQWjLwSZL0LQFS9hNFt6r3czsr8NihX573YfnKOI0q4GZSh5yig5cGBJCyqjshk26S1LCSxDYVJE9NUseDp88WTtRW2n6Kp1TG28kdDxfeBwjsdPQYh1odCLDDcSBmNDIYgtAjFdmRWY8/GD2ciH/kz+h7e+Ksd3r27DH8hZfjoahiL4iSALLMoexgQYAoQ4DA4KiAUssxiA3fCm1Nr0Bc/5fh3IUrs5jqqzneujJmLVPfKq9YK0pyrCgIMuPxXDT4Gsds3LKMmTB+en+adq1UqSibiiJbyDLxSdam5UvwvLGjp871cNwYHx9tlcPl1uk0Pv+0O2yMRq3eh3j9t279dyWW69Mv9QuW0Z3O/OpqUUUpzGqii0+Ibb9EyLnYX8tzjlwV4ZcmA5cgSKxpYNSPbx+40Kcrz9myCIJ0yiCGUKRvulpl/NnDmdfKhNwMZMkfQL5FEb4XVNRj/2F58yfomHTLMgRTlHplSueTmaTX97VG7TBy8Dalra8fGO8MgneoEqy6flgD/KD6WQfLKTIRD5LxksN6sN6GsgC219yQ/oZsxDQ4eXQztVoTH9crCsqsh8HFViAg1IDdfQNs7kKg3dfB6bkBNFMCvrpWUF1phNXrdsC0ya+CKPAvIhXe/oKbZWXprIfrJBOQ5GfwTbLRjuaFd4uX4jGrjTaJkrh085bMGK1a16faYh2XMnhM99ThE5Noh3Os0c83MWvjimiHw7XrWnHRNtrJPOZys830Pj6qOv1IH8ETjqCgZo7TkiyE2Ji8SMwnZDUhSZwOAVklyh6tJHmI3CupBkGg15OEJmtg1NluFKFPEURHhsdjDRkY9VOcmtQvQHPODYo63y2ly6m3RMkdShE+awZGnYnWkE36IR2v7c2PSfX+QOzI4nqOdSn9NPR4A7VuqJ/hJd9H6afCr9kFFF4wkhun8CO85mBKU/hBD5JR1huEY6i0ho6uMGWsmyJfR+O8+lO9J7g5z0um5s1D/AM5KLPkITBUITAUoHYZZYZrCCB3oNpSCuVVxRAXMQ8KLogwZ94c6PRcBLQLf+pZpKKltz4ZiAFody3fvGnFndVrFt/lOH4xz/NJeGz79tUbabvz5KB/jJ2OKpRE2uXmb98rbeNyMWE1NM1dKynt37lrypss69ktSNIVF8c5UKrKLSy+tzU6dlB8l67JnTwC31QEnmtFXKZRKr8tEXws/IoItDTBo46EmojyvFsUGIMkyyZOssnfnmk7SQbWR6s2rqcoXe0GUVE+IkmQv50IyZ1zt/jpA/btOvPcRFYqjBREwelhtCmqeg7Gu7LuHYNhmwIMP5QxFirBGod3Ja4v0DO1gUB1UwIYjFq2wqvLArgOwOf+ekVvTAMytSCsOyIUoFQ2sI7ey6aM+oOKLqd3jSHJ0ogmAU1Jj1QEtOsmEKSE6oUqcLNW1MzAMhw8HtAenu+2EX7M9YH3Z04CDrnc4XJCqxYh2gtnoDk27TdAyDLjpB0Uco96yLBRIUX3St4VJan2VhLb+6Wx5VbLhyqSOFJVZSu3OO1+1VarvHZOetYbCxbqnW4mIjjA31Rhs85AyJp49fyeEjRteHSPQWs4UVyl1WhsLqs1GhW5e2oxQBDHJInvjbqrgFTLv7IAJSd87JOGxMjvyvbnJ44SRc1ojZoUWNY1URL53CE9T8zD80WRUHk8xG8JIOdCQqqVLv0IRL88tbpJDbLN4GEIhzcgoKF6QQl6dj22y2s8ET3yFDBhMBxWQOHEO18RMytBxSCoO/MfJNPHS6bOrvuODCXYD6odihSw4eyx0nug2mYjGZZHdYMNZYVzyEk+UF2N+nYaIp8ZDE+3GwE1ZSb4IP0ArM1aC1qUvSmSwoFH+5D/3UKl5iq6rNK8qE2H6LcuFRY2UVFUgVpNfhYZNaBptc0+E91j37yaf7A2oG0jez2Jzp2mo9PnGEwtgjZdPXCwBleI4R0TUznWs/TpyN4XSK1af/bk7vHNI+M1bYLbEExpSZZep25WuxihOoaSwuizRS9qffUthaI7pcguAA8HwLKS/NXBFI3V7L46IvnUUCz+eU6vQIaxHvp0R5fhE4fmb3fQElhRqwXDz0mBDodlqSBopwxLOPU15i3dFP6RVi22JhUHhym7tyHCwQ/ykovwqvj1yntdSo9Qijw85xKuRRSwBClBjfBa50Ey3utFPMCmMGXtOhnvDILn4+OmCOm778fS9cJb2y5evSGpiVCwO51gNjuAYTQwLGknUNZJMGFcNiQkDYPVWauhSaA/TikQ7O8DjxkMUFRczGEMeOu7V2k2igTxlSkk+HUgyZ4s4/zCZrVvsDgcgTzPiT2io/LqZAWOD9T56JwkyCMslZYtdXw1Sf0gSSLp8jCtOY/naERMiqn0lxNcbnaWR6OmQtxutxXLkYIuXxRlZ7n53vD2wZmik5Y4q0Uka8yiXFMpOFFWCbY76eObs5NrfTcyKbfaZpHL0We2we+0TZLtFqkWES4XabDZBcpOO0/X2SFKqidcDOuuyxCt/wAQeMfPRo7vozjbu9rH78X13uvPwVRXoIYpY38kg/kZXus1ZBe21+V1VCz0GsPgTENgeK3+JJYu++bQsaOJNvM4UxNdDFwryIYJQ0/Cvm/MMGHSKCB9NeDvb4RAfQDwaOu5LDdh4qwVcOPGTbhy+cJlpKLEWx9JkptdbteMKwWVu0gZmmq1GnyrWHHv2o/Xn2zfoyDn8OGdoW2iF4kyxKEC09SmdYucyhpa53I554a27TqHIKmfaId9tlqlOv7O5LFnV3y69SxdU/Nly6eilqKbQj9ZklpTFLUDr5Xc9Si380R8hsvt/Hj11xFEZSX3OAW+KEMIWoYRA3R6vsThkC9brHd3rPwiKkPg2R4IZ205TjsJz0eg06Aj04D7fWPT72zLTjvGsOyXyzZFLyYorjtKgB1cLP/C3+7HlHLE4eyQ16CArsX706ZMHjJ//iD4PHs8pMRsgvYRfYGnCDAa9LVA8LAsuG1F0DuhF+zesw+SkwfBD6fy0mXRdaC+umc6JoxnGHYyz/GSj06z7mbB6VWYHx3T189cY1/C80JPkiJLjb76qVcuHi/AY+0i46PQdXMJyvjB+KrZzGCcc/psDhsTl+xXZbFnoEKzN0kQ9wID/KeeO3voqvd667+LG4pAkY7KmmqKaDnMw5cnCrzQbEHa+eUfftbfKAiVS4DielCgNht8m02dMur7i3jemh0JiW7GMfCdMfm1BfjXu8f63K65tNjtZvpQKqrKX9/83UmvHMhv7Pj91WDIqHfj+L1M2+gglSH0u8xVm/Jl2ZJvsZfnt2vfFTmCQs2ImjpfrfbNT0ubks8wTP7IkaOwkzJQHfHAzVOcd4o6kXOAauzv/yvob5ch/h9qFRYVVlZWtvitca+GzZwxGUhCgL379kNVpQVahZqgU+cugK6QMH36TDhwYM8RUvfsXIm9wja23Q+DHklAYAqL6BFQdKlgdEjLFgkD+vc2de0SCX5+vlBRUQ55eXnS3r0HrzMMvVuW+W/Q/U5qbHsfFj2ygPgfBbQCsOCrM67GfVCzoXbeYHjiuMNx297Y1j1s+i8vdASz4BxtHgAAAABJRU5ErkJggg==) top right no-repeat");
    }
    $("#DIV_GRID_CAPTION").width(_getBodyGeneralWidth());
    $("#tbl_grid_caption").width(_getBodyGeneralWidth() - 137);
  }
  
  /*
  if ($(".DIV_WIZARD_CAPTION").length > 0)
  { 
    // -- Codeless
    if ($.browserInformation.isLtIE8())
    $('.DIV_WIZARD_CAPTION').add_layer("url('" + get_main_directory() + get_atmosphere() + "/codeless.png') top right no-repeat");
    else
    $('.DIV_WIZARD_CAPTION').add_layer("url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41Ljg3O4BdAAAQ0ElEQVRYR6VXB1RU2ZbF7vW/M/+P69urFRS1tcXQSBCJioBQRKGAogiF5JwFFAEFAQkCVVtbxWyrbWgVKAkm1DZnRaVBTORUVAGmzjnMOa+/3T3rz5rpWcNad1H13q13991n733u09L6k3/96emj+kNC/jLg6jpW5eQ0ZUDsadYnErn029nJeh0ckvpEDml9jo5pfc7OSSpXV9mAh4eLSio1U0l9pg7IZG/3hoWN7o6MHPUnl/vfp7UFyEZ1ODqO7rG01O6fv8BYZTVfojI3Txk0Nl6tNjQsVBsZFatNTEo1pmZlGguLMo2VVemQtXXxkI1NocbBIU/tvnj5oMRbNiiRmKp9fHQGQoJH98bF/v8AtlovePOJpcW4LmNj89733gsb0NPLHZw+fa1ab4ZcPXOmYnD2bKgMDNBvYoI+Cwv0WVlhYP58qGhoFiwAgcOw/SLFsKOodNjFJXfIwyNMLZXOHwgL1R1ISfmrurDw/wawSeQ4qtnUbHSrkeGMp7Nn+XZPm7qqf/LkMtXkyYqBqVPRo6+PThtbdPpI0Rkdjc5ly9CRk4OO1avRuXIlutLS0B0VjR4/f/S7uoKYw7BIpBhxdi4jcHlqf/8IdUT4PFVCwpje1LQ/B67Ry2vU/QULxrTo65s+mj49rn3SpOJuXV1Fz+TJ6CB22ry80E6Ld+7fj/5r1zDc3o5XGg0+f/6cxgt8OjyMkZ4eqO7fR8+xY+jauFEA2uvrBw2BHHF1VYyIxWXD/v4rNIGBdoNBQf/oDw19438U1W0Hh1GNpqZj7hsY2D2YNi39ia5uWZuuLp5O18NDt8V4UlyMvosX8Uqtxndff42ffvgBP//0E37++ed/GT/9+CO+//ZbfPHiBdSffIKeAwfQlZGBAakUwx4eGPH0lA9LfLKG/PxEg0uWvNUbFfXfg2uKixt1x8ry742zZy1omjp1xYOJE8sfEqgWQ0N8EheHjro6vBgcxPfffSeA+OWXX34bf/z+GuTr+/z9RwL51atPobpzB20KBfoDAhgYRry95SNS35WaoCAXTUrK20Ola/8V3C0Hh3+7bWZm3jh1aloTgWoiUI3z5uH+qlXouXULn796he8I1A/EEo/XC3766afQUCn53jfffAOVSoVhKuf3338vzOG5DOxH+v9qYABtu3ahLzAQw2ICRrJ4JvGRD/sHrNREhDuo42L/oz85+XfNXbazefP6XOOpN/X0Yu9M1C27O3Eibhkb4XZuDrrv3cPLF8/x1Vdf4YsvvkA7aerKlStQUzk7OjpwgErEgwE1NjZiw4YN2Lp1Kz6h8g0QkPPnz+MuXdfQ3L5Dh9AXEwOVjw+6wsPRExSEIfr8TCIpHw4ISFNHRBgOJCePFvR2bUngqEvz5v3jyuxZnjd0ddfcmjABN2bNwtWkJDy+dhUd7W24ffs2ekjQra2t2Lx5MxRUDgbV0tKC999/H2VlZcK9vXv3oqioCOvWrROuHz16FMn0nDIyy3l2LTHV6+6OR3StU1mNth070E8AR7y8MeLjs3YoODhck5g4UVNc/IbWFS/Pv16yMJ9z6Z13ll/T0ZFfmzIFFzzFaKqvwz3a6fbt24XBQJ48eYKKigoBHDPGJTx48KAAghliQMxWTU0NEhISALkcEd7eOBgcjBZyJAU1zpH4K1KX4mFTEzSPHqG9vBwUH3jm5aUY8fPLVUdGWqsSE/+mdd7C4q1z+vqeFyZOLLyio4OLxsa4CqDj4UNcvXoVBQUFqK2txdDQEDo7O4XFjxw5gpcvX+I5RQSzxMCam5uFe8yeUqlECJVpQ24utjg5ocnODo8XLsR5Pz/cpHJupOfv2b0H/VSFXnJ5d0IihkhvxFqpJjg4gsBN0LpgYzPj7IwZaecmTJBfILbOSCRoIV10dXUJgPLy8gQ2GAiXLodKcubMGXz++ecYGRnBDioHs8iMMqDExERkUODKFi1CpdQHLdbWaDYzw2YjIyRRTLTSBlijycnJuEighuh3T2ljg69Z8/fP0kRHmWqdtbYWNUyatPqstjY+phbzcX4e2h88EMrGi+7cuRPd3d0CMGaFS8UAv6YcY0deuHBBWIA/D1Kc7CcGcyMisJlaVIu5GTpsbVFPbMQtXox82hTPYVOUlJRgI4VvHxHQdfo0+ug3wxQhz3yla4ajImVax/X1g07q6BQ2ELBT9LBrpJkemsxlY0c1kRa4jAyMNcUgX1F0fEvhyU7lRdiRHBXfkGt7L1/BfdLXU3MLdNvbo5MY77x6Dc30nP7+fiFGeFPsYDYHa3WIjNNOLGtIjyMSSelQSPAyrboZeunHdbRLT1BEHHNxxZ1Tp9BCzDCoY9RSbt68ib6+PsF1x48fF4TNC7ygRL9x44bAKrN4meb3nD+HjtRUdNMGn1Aj71izBj3k6HNU+t27dwul5g2zDLgirGH+P9zZgcelazFIxqBskw8FBBRp1erp5dfr6JQfmzwFNf4BuFRXjy1btiCD2kdKSgqysrKEBxw+fBixsbEIDQ0Vdsu6S6MeyJqKj4rCStLmDc4nMs+1GTOwl1z4lHrpLQIvk8ngTxry9fUV4oSlsG3bNoSEhCA/Px/tLc14RJsbJHM8E4sxIpUqtKqnT1fUkhvr33kH1WTrI5TMvDhnFYs6gNoHU3758mVBF0HktuvXrwvs+RCQD+iBVfTwI9S6qOmj2WQe5MRYsJsb7lILYgc7OzsL7i2mXiumhXmjp0lXvFEG10zzHu7ZAxUbgAzyXOIDrSoCVkPAaglYJS26j9jyI+Sc4Lwrb6o7l4BLuX79egEog6yuroYrOW8XhWWjhxjtM2eR0O1whyIii3qrhH7HwcxdgYFVVlYKceJGgPk6yyOX5jKwT+h7KwMjRkfIJM/ptwTs3TVHtbXlNVMmo4oQn/joI2RmZiIyMlJgjsvArnv69KkAVkIl4+8XGxqQRtl0dM4cPCSmWulQ2EWb6qDjTiFpi3/HLua57pT2cQQ2mCqSyhokA7E7OYqWL1+Oh9T2Wum3A/TsEQI+7OWpYMaWKbW1S5Uk/kpXF1ym7Dp79qygs3JK5UMUiG1tbUJL4vJxOa6fO4dGSv/TlE9N06ahmdz3cFMFXvaRKSh0q6qqBHbZsezoDz/8UGCH5XGLDgTsys8++0woKRto4MljtNJz6T0Bw66uco2XV7FWpZ5eaJW2diGBQzVp42N6SDMJm3fKrrxHu2HaeZHHjx/jOoG+ScndSInePHMm7tP/1u07oCG3fcuRQYNdy6zwZ44HjpkHlI38HL7GccPmuUbmePbsGQbp3iMymopKPuzsXKr29l6hVWNmvrhywoQ85bhxUM6ehRo6Hl8gYa6hcnApeeesr8fU1w5RNOyno/RlioK75LwbBOoktawjJOzbxAQv8ojm8YbuU0k5Fvg0wr2V5cHMcVxwdLC2+K+XMrOt4RQ6SLuaRfYYdnIqVPv6hmods7U1qqKDoXL8eIWSjs+HKUsuUFbV0cFwFZ3Fwqn7XyL2rpw4gbXUhI+QSS5OmoRT1GpOlZYikbTI4uYeyW5dunQpnAgw5xuDZDm8jhl+Fgc2O5QdzWv0U461ULPvc3HBkK2tYsjRMZvyzFKr3tp6vFJ/TmC1jk7J0fHjUTl3LurL5bhHTqmvr0cICXYnaeNEWjrq6Th0lsDvmv0eUkQigVnWYCAdZ1jInE/79u0TgDIw7ql8b9OmTVhJR59llO53797Ftu3bBIe2k6HaKZgfE3sqMhK9VZWpnV1iVGKxrlaNre1opYGBcdWEiZlHx41TVNPChzy9cIEEfJ2arYJYK6HTQR2BOk1s7bO0hJzyx50WZ5NwyThoufRcJtYNRwwD5iORkHUffID09HQhMjgq2N33CGAfSaSZuwOZR2NpqSBgeWqx2IHybIxWjchhVJW+/ltV777rSwYoUo4fhyMk6sPx8WigXSsp1ZV6ejhF4xCxtJQacjLdcyHqOSQ5ErKzswVgHCnnyLFSkkMDxQl3i8WUS6wvbltsiN7eXmEDKhoPCHAbRckguZtfltWL7GNJ+JPVyclvCqdYpfXCv1QbGelX03mftFZerT0eHxFDByibagjkMRqnie6rtNABEnAShSozwGxxr+PzGJeGgfFpg4EwYNYTa4/ZY1fz+Z+b/wg1/Va61kob6Dc1hcbERK62tMzsd3Sy6pNI/v23V7mjjk6jjtnbj6kzNxcpp0zJqSYjVLNLdbRxlM5o1RR81yn92wgEn7sEl1J08KmCF+Rs4jzi0ORzHEcMHyL59MHR8OWXXwovJN8RqCHKwwe0uRYqcR/pWW1gqFCbmhYM2NqK+9xc3+oJCf6vL8D10XFv1Nvbj1Pq64srJ0zMrXx7nLzq7bcFF+6nN+oGeth90gXbn0vyOtsYDA8+vnBcPKdTx4sXL4UAZUAM7ksaz0eeoZ30dZdc2uTkjC56mx+YPVsxYGRcNLDQZkmvWDzpaXjEryV8/ReUuPpN7/AVbzl4RE+LtPMyzzO0iM97Z2Zp/mQ9FEyZgVx9E6zyCURpYTl27D6I/UdqcEh5HJU1J1FdewrK+tOoOX4WdSfP4VjDeZw4cxGnzl5Gw7krwqin6/v3HMTWpRnYa+eM6rkWqJlrjlqzBfJaB7eMnSEJi1JT1rwbs7xsTEKW/Pd3SxdZ6t/tpUl2pi6RUfOcI5Lmi4Kybaw8y2wtPLDIyhP2872waKEPbJxDIJImwnVJGjxCMuAZlgnviGz4RK6ENHoV/GJyEBCXi8CEPCxJzEdQUoEwZHTNNyQdgd4xCPWMRDiNCO8oRErj5GFhGXmBcfkpgcnFEXFZ6+YvXb3xb78xZitJGDvfI1ZmJAorNnAIVRg4hCkMReGw9IilBQoQt0JOILJh7h6PeW5xMF0cTyMBNtI0+McXQCTLwEKfNNj5LYM4fBVkiWvgEpwFx8AVcFqSKXx2DcmGGw2PsFU0JwfiiBx4RubCOypPIYnJV/glFBbHZa8PSM2vGPsbMBvvhLFWHjEyQ4eQkjmLgjHHPhQmzhHwCs9EVlEF4jPLEJFWDC9iJyajHKGpJfCKXIWMwi3YtLsKYanFSMp5Hym5GxCXKUdu+Q6k5W9CekEF3SsR5mWVbEPkslKsKt2BzOJtkMbmw50AekTkEsDVkMYVlMRmrZMtzdv0R2DxY63co2UG9sEl+nZLwODMXCMRkpSH1BwFXKh0QVSaFWs2IrNwI9ZvP4iidbuwduMeHKg+iQLFDuw5VIe9NFaXb0PFB0dQWXcGO/ZVQ755Hw7XNmB/5TGsUexEZe1p7P6oDkuSi35lMXQl3MNy4B2dVxKVIZcl5Wz4HdhCz5ixlosjZQaLlpTo2waCwRmJQuARnI788q3E2iYB0MriChTIt2Pz7sO0yHas23oA+yqPI2ftFuw6oMS2vZVYlrce5RUf4iPlKVTsOkTzfgW9n+YptuzDgaoT2E8jPG0tnIOyhOESTCWOyC0JSy+TxWev+x2YtTh6rIVbuGyOnazkPZsAvPdPcCZOoXD2T4Z7UBoc/VJABoE4ZDncaYjouyQyC9KolRD5L4V3ZDY8w7Pg4JcKt+AVkETnwIeGS1AGfGNXIyi5EJKoXPpfJEiB2bIPyIAD6dMxMJOZKwlJXSuLyVT8gTFx5FhL1zDZHNuAktkL/SGAs5GB2ZtD7BnYB1F5g2BAJSaDwNAhlEYYjJ0ihGFEY65zFI1oGNOY6xIDE9dYwSTz3OJh5p4AC3ESjWQs8F4Ka59UGmlknnTBMPb+y5m5kqCUIllURrkA7D8B0cQ5f2B7sDsAAAAASUVORK5CYII=) top right no-repeat");
  }
  */
   
  /** Espacements **/
  $("#tbl_dialog_caption tr:first > td").each(function (){
      $(this).css("padding", "0px 5px");
  });
  $(".tbl_wizard_caption").css("padding", "5px 10px");
  $(".tbl_wizard_caption").css("margin-left", "15px");
  if ($(".DIV_WIZARD_CAPTION").length > 0)
  {
    $("body").css("margin-left", "5px");
  }
   
  /*******************************/
  /** [END] Block Caption Bar **/
  /*******************************/
     
  $("#INFOSTACK").css('width', '95%');
  
  /*********************************/
  /** [BEGIN] SlideToolbox Tools & Wizard **/
  /*********************************/
  if ($.slideToolboxTools != null && (!$.browserInformation.isIE7() && (typeof(bNoSlideToolBox) == "undefined" || !bNoSlideToolBox)) && ($("#DIV_GRID_CAPTION").length == 1 || $("#DIV_DIALOG_CAPTION").length == 1))
    $.slideToolboxTools.create();
  if ($.slideToolboxWizard != null && (!$.browserInformation.isIE7() && (typeof(bNoSlideToolBox) == "undefined" || !bNoSlideToolBox)))
    $.slideToolboxWizard.create();
  /*********************************/
  /** [END] SlideToolbox Tools & Wizard **/
  /*********************************/
  
  /*******************************/
  /** [BEGIN] Apply Corner **/
  /*******************************/
  var supportBorderRadius = jQuery.support.borderRadius;
  /** Quickcall bar **/
  if ($("#DIV_DIALOG_CAPTION").length != 1)
    $("#header").css("width", $(window).width());
  if (supportBorderRadius || (typeof(bNoCorner) == "undefined" || !bNoCorner))
  {
    $("#div_quickcall_bar").corner("bottom");
    $("#quickcall_input").corner();
  }
   
  /** Wizard Caption **/ 
  if (supportBorderRadius || (typeof(bNoCorner) == "undefined" || !bNoCorner))
  {
    $(".tbl_wizard_caption").corner("top");
  }
  
  /** Picto buttons **/
  if (supportBorderRadius || (typeof(bNoCorner) == "undefined" || !bNoCorner))
  {
    $(".pictoButton").corner("5px");
    $(".bottomWizButtons").corner("top");
  }
  var iMarginWizard = 40;
  var iAssistTableWidth = $("#AssistTable").width() - _getBodyGeneralMarge() - iMarginWizard;
  if ( iAssistTableWidth > $(window).width() ) iAssistTableWidth = $(window).width() - iMarginWizard;
  $(".bottomWizButtons").width(iAssistTableWidth);
  $(window).resize(function(e) {
    var iAssistTableWidth = $("#AssistTable").width() - _getBodyGeneralMarge() - iMarginWizard;
    if ( iAssistTableWidth > $(window).width() ) iAssistTableWidth = $(window).width() - iMarginWizard;
    $(".bottomWizButtons").width(iAssistTableWidth);
  });
  $("#cache").hide();
  
  /** Menu **/
  if (supportBorderRadius || (typeof(bNoCorner) == "undefined" || !bNoCorner))
  {
    $("#menuNiv0 td").corner("top 5px");
  }
  if ($(".menuNiv0 .tabUnSelected").length == 1) $(".menuNiv0 .tabSelected").hide();
  if (!supportBorderRadius && (typeof(bNoCorner) == "undefined" || !bNoCorner))
  {
    //-- Delete border-bottom default value added by jQuery Corner for browsers that don't support borderRadius CSS 3
    $("#menuNiv0 td").each(function (){
        var tdStyle = this.style.cssText;
        var arr = tdStyle.split(";");
        var arrNew = Array();
        var patt1=new RegExp("border-bottom", "i");
        for (i=0;i<=arr.length;i++)
        {
          if (!patt1.test(arr[i]))
          arrNew.push(arr[i]);
        }
        this.style.cssText = arrNew.join(";");
     });
  }
   
  /** Apply corner to tabsheets **/
  if (supportBorderRadius)
    $(".dialog_sections_header_selected").corner("top");

  /*******************************/
  /** [END] Apply Corner **/
  /*******************************/
}

function applyEffectWidthForDialog()
{
  $("#DIV_DIALOG_CAPTION").width(_getBodyGeneralWidth());
  //$("#DIV_DIALOG_CAPTION").width(_getBodyGeneralWidthFromWindow());
  $("#header").css("width", $(window).width());
}

function applyEffectDefaultWidthForDialog()
{
  $("#DIV_DIALOG_CAPTION").width(_getBodyGeneralWidthFromWindow());
  $("#header").css("width", $(window).width());
}

function applyEffectsModules()
{
  var supportBorderRadius = jQuery.support.borderRadius;
  /** Modules **/
  if (supportBorderRadius || (typeof(bNoCorner) == "undefined" || !bNoCorner))
  { 
    $(".modules_header").corner("5px");
    $(".modules_content").corner("5px");
  }
}

/**
 * Chargement ajax via url dans un div (GET et POST)
 * @param url de chargement du contenu
 * @param nom du div dont le contenu va être remplacé
 * @param (optional) data : objet json passé en POST
 */
function loadAjaxBlock(strURL, divName, data)
{
  tHtmlChrono = new Date().getTime();
  $('#'+divName).css('cursor', 'wait');
  $('#'+divName).load(strURL, data, function (){
      $('#'+divName).css('cursor', 'default');
      apply_effects();
  });
}

/**
 * Delete parameter in URL
 * @param url String : URL to clean
 * @param param String : Parameters to delete
 */
function delete_param_url (url, param)
{
  var reg = new RegExp("([?]" + param + "=[^&]*&*)", "g");
  url = url.replace(reg, "?");
  
  reg = new RegExp("(&" + param + "=[^&]*)", "g");
  while (url.match(reg)) 
  {
    url = url.replace(reg, "");
  }

  return (url);
}

/**
 * Delete parameters in URL
 * @param url String : URL to clean
 * @param param Array : Parameters to delete
 */
function delete_params_url (url, params)
{
  if (!$.isArray(params) || params.length == 0) return (url);
  
  var len = params.length;
  for(var i=0; i<len; i++)
  {
    var param = params[i];
    var reg = new RegExp("&?"+param+"=([^&]$|[^&]*)", "i");
    url=url.replace(reg, "");
  }

  return (url);
}


function ezv_debug_js()
{
	var _debug;
}

// -- Return max length of text to show hint. Take the number of uppercase to calculate the max length
// -- Function equals to getMaxLengthForHint in evo_include.php
function getMaxLengthForHint(sText)
{
	var max_length = 20;
	var max_length_lower = 14;
	var max_length_upper = 14;

	var nb_lower = 0;
	var nb_upper = 0;
	var length = sText.length;
	for (var i = 0 ; i < length ; i++)
	{
		var code = sText.charCodeAt(i);
		if ((code >= 65) && (code <= 90)) 
		nb_upper++;
		else
		nb_lower++;
	}

	if (nb_upper > max_length_upper)
	return (max_length_upper);
  else if (nb_lower > max_length_lower)
  return (max_length_lower);
	else if (length > max_length)
	return (max_length);
	else
	return (length);
}/*! jQuery v1.6.4 http://jquery.com/ | http://jquery.org/license */
(function(a,b){function cu(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cr(a){if(!cg[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ch||(ch=c.createElement("iframe"),ch.frameBorder=ch.width=ch.height=0),b.appendChild(ch);if(!ci||!ch.createElement)ci=(ch.contentWindow||ch.contentDocument).document,ci.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),ci.close();d=ci.createElement(a),ci.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ch)}cg[a]=e}return cg[a]}function cq(a,b){var c={};f.each(cm.concat.apply([],cm.slice(0,b)),function(){c[this]=a});return c}function cp(){cn=b}function co(){setTimeout(cp,0);return cn=f.now()}function cf(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ce(){try{return new a.XMLHttpRequest}catch(b){}}function b$(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function bZ(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function bY(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bA.test(a)?d(a,e):bY(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)bY(a+"["+e+"]",b[e],c,d);else d(a,b)}function bX(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bW(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bP,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bW(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bW(a,c,d,e,"*",g));return l}function bV(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bL),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function by(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bt:bu;if(d>0){c!=="border"&&f.each(e,function(){c||(d-=parseFloat(f.css(a,"padding"+this))||0),c==="margin"?d+=parseFloat(f.css(a,c+this))||0:d-=parseFloat(f.css(a,"border"+this+"Width"))||0});return d+"px"}d=bv(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0,c&&f.each(e,function(){d+=parseFloat(f.css(a,"padding"+this))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+this+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+this))||0)});return d+"px"}function bl(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bd,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bk(a){f.nodeName(a,"input")?bj(a):"getElementsByTagName"in a&&f.grep(a.getElementsByTagName("input"),bj)}function bj(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bi(a){return"getElementsByTagName"in a?a.getElementsByTagName("*"):"querySelectorAll"in a?a.querySelectorAll("*"):[]}function bh(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bg(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c=f.expando,d=f.data(a),e=f.data(b,d);if(d=d[c]){var g=d.events;e=e[c]=f.extend({},d);if(g){delete e.handle,e.events={};for(var h in g)for(var i=0,j=g[h].length;i<j;i++)f.event.add(b,h+(g[h][i].namespace?".":"")+g[h][i].namespace,g[h][i],g[h][i].data)}}}}function bf(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function V(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(Q.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function U(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function M(a,b){return(a&&a!=="*"?a+".":"")+b.replace(y,"`").replace(z,"&")}function L(a){var b,c,d,e,g,h,i,j,k,l,m,n,o,p=[],q=[],r=f._data(this,"events");if(!(a.liveFired===this||!r||!r.live||a.target.disabled||a.button&&a.type==="click")){a.namespace&&(n=new RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)")),a.liveFired=this;var s=r.live.slice(0);for(i=0;i<s.length;i++)g=s[i],g.origType.replace(w,"")===a.type?q.push(g.selector):s.splice(i--,1);e=f(a.target).closest(q,a.currentTarget);for(j=0,k=e.length;j<k;j++){m=e[j];for(i=0;i<s.length;i++){g=s[i];if(m.selector===g.selector&&(!n||n.test(g.namespace))&&!m.elem.disabled){h=m.elem,d=null;if(g.preType==="mouseenter"||g.preType==="mouseleave")a.type=g.preType,d=f(a.relatedTarget).closest(g.selector)[0],d&&f.contains(h,d)&&(d=h);(!d||d!==h)&&p.push({elem:h,handleObj:g,level:m.level})}}}for(j=0,k=p.length;j<k;j++){e=p[j];if(c&&e.level>c)break;a.currentTarget=e.elem,a.data=e.handleObj.data,a.handleObj=e.handleObj,o=e.handleObj.origHandler.apply(e.elem,arguments);if(o===!1||a.isPropagationStopped()){c=e.level,o===!1&&(b=!1);if(a.isImmediatePropagationStopped())break}}return b}}function J(a,c,d){var e=f.extend({},d[0]);e.type=a,e.originalEvent={},e.liveFired=b,f.event.handle.call(c,e),e.isDefaultPrevented()&&d[0].preventDefault()}function D(){return!0}function C(){return!1}function m(a,c,d){var e=c+"defer",g=c+"queue",h=c+"mark",i=f.data(a,e,b,!0);i&&(d==="queue"||!f.data(a,g,b,!0))&&(d==="mark"||!f.data(a,h,b,!0))&&setTimeout(function(){!f.data(a,g,b,!0)&&!f.data(a,h,b,!0)&&(f.removeData(a,e,!0),i.resolve())},0)}function l(a){for(var b in a)if(b!=="toJSON")return!1;return!0}function k(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(j,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNaN(d)?i.test(d)?f.parseJSON(d):d:parseFloat(d)}catch(g){}f.data(a,c,d)}else d=b}return d}var c=a.document,d=a.navigator,e=a.location,f=function(){function K(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(K,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/\d/,n=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,o=/^[\],:{}\s]*$/,p=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,q=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,r=/(?:^|:|,)(?:\s*\[)+/g,s=/(webkit)[ \/]([\w.]+)/,t=/(opera)(?:.*version)?[ \/]([\w.]+)/,u=/(msie) ([\w.]+)/,v=/(mozilla)(?:.*? rv:([\w.]+))?/,w=/-([a-z]|[0-9])/ig,x=/^-ms-/,y=function(a,b){return(b+"").toUpperCase()},z=d.userAgent,A,B,C,D=Object.prototype.toString,E=Object.prototype.hasOwnProperty,F=Array.prototype.push,G=Array.prototype.slice,H=String.prototype.trim,I=Array.prototype.indexOf,J={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=n.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.6.4",length:0,size:function(){return this.length},toArray:function(){return G.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?F.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),B.done(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(G.apply(this,arguments),"slice",G.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:F,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;B.resolveWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").unbind("ready")}},bindReady:function(){if(!B){B=e._Deferred();if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",C,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",C),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&K()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNaN:function(a){return a==null||!m.test(a)||isNaN(a)},type:function(a){return a==null?String(a):J[D.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!E.call(a,"constructor")&&!E.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||E.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw a},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(o.test(b.replace(p,"@").replace(q,"]").replace(r,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(x,"ms-").replace(w,y)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:H?function(a){return a==null?"":H.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?F.call(c,a):e.merge(c,a)}return c},inArray:function(a,b){if(!b)return-1;if(I)return I.call(b,a);for(var c=0,d=b.length;c<d;c++)if(b[c]===a)return c;return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=G.call(arguments,2),g=function(){return a.apply(c,f.concat(G.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=s.exec(a)||t.exec(a)||u.exec(a)||a.indexOf("compatible")<0&&v.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){J["[object "+b+"]"]=b.toLowerCase()}),A=e.uaMatch(z),A.browser&&(e.browser[A.browser]=!0,e.browser.version=A.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?C=function(){c.removeEventListener("DOMContentLoaded",C,!1),e.ready()}:c.attachEvent&&(C=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",C),e.ready())});return e}(),g="done fail isResolved isRejected promise then always pipe".split(" "),h=[].slice;f.extend({_Deferred:function(){var a=[],b,c,d,e={done:function(){if(!d){var c=arguments,g,h,i,j,k;b&&(k=b,b=0);for(g=0,h=c.length;g<h;g++)i=c[g],j=f.type(i),j==="array"?e.done.apply(e,i):j==="function"&&a.push(i);k&&e.resolveWith(k[0],k[1])}return this},resolveWith:function(e,f){if(!d&&!b&&!c){f=f||[],c=1;try{while(a[0])a.shift().apply(e,f)}finally{b=[e,f],c=0}}return this},resolve:function(){e.resolveWith(this,arguments);return this},isResolved:function(){return!!c||!!b},cancel:function(){d=1,a=[];return this}};return e},Deferred:function(a){var b=f._Deferred(),c=f._Deferred(),d;f.extend(b,{then:function(a,c){b.done(a).fail(c);return this},always:function(){return b.done.apply(b,arguments).fail.apply(this,arguments)},fail:c.done,rejectWith:c.resolveWith,reject:c.resolve,isRejected:c.isResolved,pipe:function(a,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[c,"reject"]},function(a,c){var e=c[0],g=c[1],h;f.isFunction(e)?b[a](function(){h=e.apply(this,arguments),h&&f.isFunction(h.promise)?h.promise().then(d.resolve,d.reject):d[g+"With"](this===b?d:this,[h])}):b[a](d[g])})}).promise()},promise:function(a){if(a==null){if(d)return d;d=a={}}var c=g.length;while(c--)a[g[c]]=b[g[c]];return a}}),b.done(c.cancel).fail(b.cancel),delete b.cancel,a&&a.call(b,b);return b},when:function(a){function i(a){return function(c){b[a]=arguments.length>1?h.call(arguments,0):c,--e||g.resolveWith(g,h.call(b,0))}}var b=arguments,c=0,d=b.length,e=d,g=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred();if(d>1){for(;c<d;c++)b[c]&&f.isFunction(b[c].promise)?b[c].promise().then(i(c),g.reject):--e;e||g.resolveWith(g,b)}else g!==a&&g.resolveWith(g,d?[a]:[]);return g.promise()}}),f.support=function(){var a=c.createElement("div"),b=c.documentElement,d,e,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u;a.setAttribute("className","t"),a.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=a.getElementsByTagName("*"),e=a.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=a.getElementsByTagName("input")[0],k={leadingWhitespace:a.firstChild.nodeType===3,tbody:!a.getElementsByTagName("tbody").length,htmlSerialize:!!a.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55$/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:a.className!=="t",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,k.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,k.optDisabled=!h.disabled;try{delete a.test}catch(v){k.deleteExpando=!1}!a.addEventListener&&a.attachEvent&&a.fireEvent&&(a.attachEvent("onclick",function(){k.noCloneEvent=!1}),a.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),k.radioValue=i.value==="t",i.setAttribute("checked","checked"),a.appendChild(i),l=c.createDocumentFragment(),l.appendChild(a.firstChild),k.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,a.innerHTML="",a.style.width=a.style.paddingLeft="1px",m=c.getElementsByTagName("body")[0],o=c.createElement(m?"div":"body"),p={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},m&&f.extend(p,{position:"absolute",left:"-1000px",top:"-1000px"});for(t in p)o.style[t]=p[t];o.appendChild(a),n=m||b,n.insertBefore(o,n.firstChild),k.appendChecked=i.checked,k.boxModel=a.offsetWidth===2,"zoom"in a.style&&(a.style.display="inline",a.style.zoom=1,k.inlineBlockNeedsLayout=a.offsetWidth===2,a.style.display="",a.innerHTML="<div style='width:4px;'></div>",k.shrinkWrapBlocks=a.offsetWidth!==2),a.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",q=a.getElementsByTagName("td"),u=q[0].offsetHeight===0,q[0].style.display="",q[1].style.display="none",k.reliableHiddenOffsets=u&&q[0].offsetHeight===0,a.innerHTML="",c.defaultView&&c.defaultView.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",a.appendChild(j),k.reliableMarginRight=(parseInt((c.defaultView.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0),o.innerHTML="",n.removeChild(o);if(a.attachEvent)for(t in{submit:1,change:1,focusin:1})s="on"+t,u=s in a,u||(a.setAttribute(s,"return;"),u=typeof a[s]=="function"),k[t+"Bubbles"]=u;o=l=g=h=m=j=a=i=null;return k}(),f.boxModel=f.support.boxModel;var i=/^(?:\{.*\}|\[.*\])$/,j=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!l(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i=f.expando,j=typeof c=="string",k=a.nodeType,l=k?f.cache:a,m=k?a[f.expando]:a[f.expando]&&f.expando;if((!m||e&&m&&l[m]&&!l[m][i])&&j&&d===b)return;m||(k?a[f.expando]=m=++f.uuid:m=f.expando),l[m]||(l[m]={},k||(l[m].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?l[m][i]=f.extend(l[m][i],c):l[m]=f.extend(l[m],c);g=l[m],e&&(g[i]||(g[i]={}),g=g[i]),d!==b&&(g[f.camelCase(c)]=d);if(c==="events"&&!g[c])return g[i]&&g[i].events;j?(h=g[c],h==null&&(h=g[f.camelCase(c)])):h=g;return h}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e=f.expando,g=a.nodeType,h=g?f.cache:a,i=g?a[f.expando]:f.expando;if(!h[i])return;if(b){d=c?h[i][e]:h[i];if(d){d[b]||(b=f.camelCase(b)),delete d[b];if(!l(d))return}}if(c){delete h[i][e];if(!l(h[i]))return}var j=h[i][e];f.support.deleteExpando||!h.setInterval?delete h[i]:h[i]=null,j?(h[i]={},g||(h[i].toJSON=f.noop),h[i][e]=j):g&&(f.support.deleteExpando?delete a[f.expando]:a.removeAttribute?a.removeAttribute(f.expando):a[f.expando]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d=null;if(typeof a=="undefined"){if(this.length){d=f.data(this[0]);if(this[0].nodeType===1){var e=this[0].attributes,g;for(var h=0,i=e.length;h<i;h++)g=e[h].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),k(this[0],g,d[g]))}}return d}if(typeof a=="object")return this.each(function(){f.data(this,a)});var j=a.split(".");j[1]=j[1]?"."+j[1]:"";if(c===b){d=this.triggerHandler("getData"+j[1]+"!",[j[0]]),d===b&&this.length&&(d=f.data(this[0],a),d=k(this[0],a,d));return d===b&&j[1]?this.data(j[0]):d}return this.each(function(){var b=f(this),d=[j[0],c];b.triggerHandler("setData"+j[1]+"!",d),f.data(this,a,c),b.triggerHandler("changeData"+j[1]+"!",d)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,c){a&&(c=(c||"fx")+"mark",f.data(a,c,(f.data(a,c,b,!0)||0)+1,!0))},_unmark:function(a,c,d){a!==!0&&(d=c,c=a,a=!1);if(c){d=d||"fx";var e=d+"mark",g=a?0:(f.data(c,e,b,!0)||1)-1;g?f.data(c,e,g,!0):(f.removeData(c,e,!0),m(c,d,"mark"))}},queue:function(a,c,d){if(a){c=(c||"fx")+"queue";var e=f.data(a,c,b,!0);d&&(!e||f.isArray(d)?e=f.data(a,c,f.makeArray(d),!0):e.push(d));return e||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e;d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),d.call(a,function(){f.dequeue(a,b)})),c.length||(f.removeData(a,b+"queue",!0),m(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(){var c=this;setTimeout(function(){f.dequeue(c,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f._Deferred(),!0))h++,l.done(m);m();return d.promise()}});var n=/[\n\t\r]/g,o=/\s+/,p=/\r/g,q=/^(?:button|input)$/i,r=/^(?:button|input|object|select|textarea)$/i,s=/^a(?:rea)?$/i,t=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,u,v;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(o);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(o);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(n," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(o);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ";for(var c=0,d=this.length;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(n," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e=this[0];if(!arguments.length){if(e){c=f.valHooks[e.nodeName.toLowerCase()]||f.valHooks[e.type];if(c&&"get"in c&&(d=c.get(e,"value"))!==b)return d;d=e.value;return typeof d=="string"?d.replace(p,""):d==null?"":d}return b}var g=f.isFunction(a);return this.each(function(d){var e=f(this),h;if(this.nodeType===1){g?h=a.call(this,d,e.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c=a.selectedIndex,d=[],e=a.options,g=a.type==="select-one";if(c<0)return null;for(var h=g?c:0,i=g?c+1:e.length;h<i;h++){var j=e[h];if(j.selected&&(f.support.optDisabled?!j.disabled:j.getAttribute("disabled")===null)&&(!j.parentNode.disabled||!f.nodeName(j.parentNode,"optgroup"))){b=f(j).val();if(g)return b;d.push(b)}}if(g&&!d.length&&e.length)return f(e[c]).val();return d},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attrFix:{tabindex:"tabIndex"},attr:function(a,c,d,e){var g=a.nodeType;if(!a||g===3||g===8||g===2)return b;if(e&&c in f.attrFn)return f(a)[c](d);if(!("getAttribute"in a))return f.prop(a,c,d);var h,i,j=g!==1||!f.isXMLDoc(a);j&&(c=f.attrFix[c]||c,i=f.attrHooks[c],i||(t.test(c)?i=v:u&&(i=u)));if(d!==b){if(d===null){f.removeAttr(a,c);return b}if(i&&"set"in i&&j&&(h=i.set(a,d,c))!==b)return h;a.setAttribute(c,""+d);return d}if(i&&"get"in i&&j&&(h=i.get(a,c))!==null)return h;h=a.getAttribute(c);return h===null?b:h},removeAttr:function(a,b){var c;a.nodeType===1&&(b=f.attrFix[b]||b,f.attr(a,b,""),a.removeAttribute(b),t.test(b)&&(c=f.propFix[b]||b)in a&&(a[c]=!1))},attrHooks:{type:{set:function(a,b){if(q.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(u&&f.nodeName(a,"button"))return u.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(u&&f.nodeName(a,"button"))return u.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e=a.nodeType;if(!a||e===3||e===8||e===2)return b;var g,h,i=e!==1||!f.isXMLDoc(a);i&&(c=f.propFix[c]||c,h=f.propHooks[c]);return d!==b?h&&"set"in h&&(g=h.set(a,d,c))!==b?g:a[c]=d:h&&"get"in h&&(g=h.get(a,c))!==null?g:a[c]},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):r.test(a.nodeName)||s.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabIndex=f.propHooks.tabIndex,v={get:function(a,c){var d;return f.prop(a,c)===!0||(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},f.support.getSetAttribute||(u=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&d.nodeValue!==""?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})})),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var w=/\.(.*)$/,x=/^(?:textarea|input|select)$/i,y=/\./g,z=/ /g,A=/[^\w\s.|`]/g,B=function(a){return a.replace(A,"\\$&")};f.event={add:function(a,c,d,e){if(a.nodeType!==3&&a.nodeType!==8){if(d===!1)d=C;else if(!d)return;var g,h;d.handler&&(g=d,d=g.handler),d.guid||(d.guid=f.guid++);var i=f._data(a);if(!i)return;var j=i.events,k=i.handle;j||(i.events=j={}),k||(i.handle=k=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.handle.apply(k.elem,arguments):b}),k.elem=a,c=c.split(" ");var l,m=0,n;while(l=c[m++]){h=g?f.extend({},g):{handler:d,data:e},l.indexOf(".")>-1?(n=l.split("."),l=n.shift(),h.namespace=n.slice(0).sort().join(".")):(n=[],h.namespace=""),h.type=l,h.guid||(h.guid=d.guid);var o=j[l],p=f.event.special[l]||{};if(!o){o=j[l]=[];if(!p.setup||p.setup.call(a,e,n,k)===!1)a.addEventListener?a.addEventListener(l,k,!1):a.attachEvent&&a.attachEvent("on"+l,k)}p.add&&(p.add.call(a,h),h.handler.guid||(h.handler.guid=d.guid)),o.push(h),f.event.global[l]=!0}a=null}},global:{},remove:function(a,c,d,e){if(a.nodeType!==3&&a.nodeType!==8){d===!1&&(d=C);var g,h,i,j,k=0,l,m,n,o,p,q,r,s=f.hasData(a)&&f._data(a),t=s&&s.events;if(!s||!t)return;c&&c.type&&(d=c.handler,c=c.type);if(!c||typeof c=="string"&&c.charAt(0)==="."){c=c||"";for(h in t)f.event.remove(a,h+c);return}c=c.split(" ");while(h=c[k++]){r=h,q=null,l=h.indexOf(".")<0,m=[],l||(m=h.split("."),h=m.shift(),n=new RegExp("(^|\\.)"+f.map(m.slice(0).sort(),B).join("\\.(?:.*\\.)?")+"(\\.|$)")),p=t[h];if(!p)continue;if(!d){for(j=0;j<p.length;j++){q=p[j];if(l||n.test(q.namespace))f.event.remove(a,r,q.handler,j),p.splice(j--,1)}continue}o=f.event.special[h]||{};for(j=e||0;j<p.length;j++){q=p[j];if(d.guid===q.guid){if(l||n.test(q.namespace))e==null&&p.splice(j--,1),o.remove&&o.remove.call(a,q);if(e!=null)break}}if(p.length===0||e!=null&&p.length===1)(!o.teardown||o.teardown.call(a,m)===!1)&&f.removeEvent(a,h,s.handle),g=null,delete 
t[h]}if(f.isEmptyObject(t)){var u=s.handle;u&&(u.elem=null),delete s.events,delete s.handle,f.isEmptyObject(s)&&f.removeData(a,b,!0)}}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){var h=c.type||c,i=[],j;h.indexOf("!")>=0&&(h=h.slice(0,-1),j=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if(!!e&&!f.event.customEvent[h]||!!f.event.global[h]){c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.exclusive=j,c.namespace=i.join("."),c.namespace_re=new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)");if(g||!e)c.preventDefault(),c.stopPropagation();if(!e){f.each(f.cache,function(){var a=f.expando,b=this[a];b&&b.events&&b.events[h]&&f.event.trigger(c,d,b.handle.elem)});return}if(e.nodeType===3||e.nodeType===8)return;c.result=b,c.target=e,d=d!=null?f.makeArray(d):[],d.unshift(c);var k=e,l=h.indexOf(":")<0?"on"+h:"";do{var m=f._data(k,"handle");c.currentTarget=k,m&&m.apply(k,d),l&&f.acceptData(k)&&k[l]&&k[l].apply(k,d)===!1&&(c.result=!1,c.preventDefault()),k=k.parentNode||k.ownerDocument||k===c.target.ownerDocument&&a}while(k&&!c.isPropagationStopped());if(!c.isDefaultPrevented()){var n,o=f.event.special[h]||{};if((!o._default||o._default.call(e.ownerDocument,c)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)){try{l&&e[h]&&(n=e[l],n&&(e[l]=null),f.event.triggered=h,e[h]())}catch(p){}n&&(e[l]=n),f.event.triggered=b}}return c.result}},handle:function(c){c=f.event.fix(c||a.event);var d=((f._data(this,"events")||{})[c.type]||[]).slice(0),e=!c.exclusive&&!c.namespace,g=Array.prototype.slice.call(arguments,0);g[0]=c,c.currentTarget=this;for(var h=0,i=d.length;h<i;h++){var j=d[h];if(e||c.namespace_re.test(j.namespace)){c.handler=j.handler,c.data=j.data,c.handleObj=j;var k=j.handler.apply(this,g);k!==b&&(c.result=k,k===!1&&(c.preventDefault(),c.stopPropagation()));if(c.isImmediatePropagationStopped())break}}return c.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),fix:function(a){if(a[f.expando])return a;var d=a;a=f.Event(d);for(var e=this.props.length,g;e;)g=this.props[--e],a[g]=d[g];a.target||(a.target=a.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),!a.relatedTarget&&a.fromElement&&(a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement);if(a.pageX==null&&a.clientX!=null){var h=a.target.ownerDocument||c,i=h.documentElement,j=h.body;a.pageX=a.clientX+(i&&i.scrollLeft||j&&j.scrollLeft||0)-(i&&i.clientLeft||j&&j.clientLeft||0),a.pageY=a.clientY+(i&&i.scrollTop||j&&j.scrollTop||0)-(i&&i.clientTop||j&&j.clientTop||0)}a.which==null&&(a.charCode!=null||a.keyCode!=null)&&(a.which=a.charCode!=null?a.charCode:a.keyCode),!a.metaKey&&a.ctrlKey&&(a.metaKey=a.ctrlKey),!a.which&&a.button!==b&&(a.which=a.button&1?1:a.button&2?3:a.button&4?2:0);return a},guid:1e8,proxy:f.proxy,special:{ready:{setup:f.bindReady,teardown:f.noop},live:{add:function(a){f.event.add(this,M(a.origType,a.selector),f.extend({},a,{handler:L,guid:a.handler.guid}))},remove:function(a){f.event.remove(this,M(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}}},f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!this.preventDefault)return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?D:C):this.type=a,b&&f.extend(this,b),this.timeStamp=f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=D;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=D;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=D,this.stopPropagation()},isDefaultPrevented:C,isPropagationStopped:C,isImmediatePropagationStopped:C};var E=function(a){var b=a.relatedTarget,c=!1,d=a.type;a.type=a.data,b!==this&&(b&&(c=f.contains(this,b)),c||(f.event.handle.apply(this,arguments),a.type=d))},F=function(a){a.type=a.data,f.event.handle.apply(this,arguments)};f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={setup:function(c){f.event.add(this,b,c&&c.selector?F:E,a)},teardown:function(a){f.event.remove(this,b,a&&a.selector?F:E)}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(a,b){if(!f.nodeName(this,"form"))f.event.add(this,"click.specialSubmit",function(a){var b=a.target,c=f.nodeName(b,"input")||f.nodeName(b,"button")?b.type:"";(c==="submit"||c==="image")&&f(b).closest("form").length&&J("submit",this,arguments)}),f.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,c=f.nodeName(b,"input")||f.nodeName(b,"button")?b.type:"";(c==="text"||c==="password")&&f(b).closest("form").length&&a.keyCode===13&&J("submit",this,arguments)});else return!1},teardown:function(a){f.event.remove(this,".specialSubmit")}});if(!f.support.changeBubbles){var G,H=function(a){var b=f.nodeName(a,"input")?a.type:"",c=a.value;b==="radio"||b==="checkbox"?c=a.checked:b==="select-multiple"?c=a.selectedIndex>-1?f.map(a.options,function(a){return a.selected}).join("-"):"":f.nodeName(a,"select")&&(c=a.selectedIndex);return c},I=function(c){var d=c.target,e,g;if(!!x.test(d.nodeName)&&!d.readOnly){e=f._data(d,"_change_data"),g=H(d),(c.type!=="focusout"||d.type!=="radio")&&f._data(d,"_change_data",g);if(e===b||g===e)return;if(e!=null||g)c.type="change",c.liveFired=b,f.event.trigger(c,arguments[1],d)}};f.event.special.change={filters:{focusout:I,beforedeactivate:I,click:function(a){var b=a.target,c=f.nodeName(b,"input")?b.type:"";(c==="radio"||c==="checkbox"||f.nodeName(b,"select"))&&I.call(this,a)},keydown:function(a){var b=a.target,c=f.nodeName(b,"input")?b.type:"";(a.keyCode===13&&!f.nodeName(b,"textarea")||a.keyCode===32&&(c==="checkbox"||c==="radio")||c==="select-multiple")&&I.call(this,a)},beforeactivate:function(a){var b=a.target;f._data(b,"_change_data",H(b))}},setup:function(a,b){if(this.type==="file")return!1;for(var c in G)f.event.add(this,c+".specialChange",G[c]);return x.test(this.nodeName)},teardown:function(a){f.event.remove(this,".specialChange");return x.test(this.nodeName)}},G=f.event.special.change.filters,G.focus=G.beforeactivate}f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){function e(a){var c=f.event.fix(a);c.type=b,c.originalEvent={},f.event.trigger(c,null,c.target),c.isDefaultPrevented()&&a.preventDefault()}var d=0;f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.each(["bind","one"],function(a,c){f.fn[c]=function(a,d,e){var g;if(typeof a=="object"){for(var h in a)this[c](h,d,a[h],e);return this}if(arguments.length===2||d===!1)e=d,d=b;c==="one"?(g=function(a){f(this).unbind(a,g);return e.apply(this,arguments)},g.guid=e.guid||f.guid++):g=e;if(a==="unload"&&c!=="one")this.one(a,d,e);else for(var i=0,j=this.length;i<j;i++)f.event.add(this[i],a,g,d);return this}}),f.fn.extend({unbind:function(a,b){if(typeof a=="object"&&!a.preventDefault)for(var c in a)this.unbind(c,a[c]);else for(var d=0,e=this.length;d<e;d++)f.event.remove(this[d],a,b);return this},delegate:function(a,b,c,d){return this.live(b,c,d,a)},undelegate:function(a,b,c){return arguments.length===0?this.unbind("live"):this.die(b,null,c,a)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f.data(this,"lastToggle"+a.guid)||0)%d;f.data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var K={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};f.each(["live","die"],function(a,c){f.fn[c]=function(a,d,e,g){var h,i=0,j,k,l,m=g||this.selector,n=g?this:f(this.context);if(typeof a=="object"&&!a.preventDefault){for(var o in a)n[c](o,d,a[o],m);return this}if(c==="die"&&!a&&g&&g.charAt(0)==="."){n.unbind(g);return this}if(d===!1||f.isFunction(d))e=d||C,d=b;a=(a||"").split(" ");while((h=a[i++])!=null){j=w.exec(h),k="",j&&(k=j[0],h=h.replace(w,""));if(h==="hover"){a.push("mouseenter"+k,"mouseleave"+k);continue}l=h,K[h]?(a.push(K[h]+k),h=h+k):h=(K[h]||h)+k;if(c==="live")for(var p=0,q=n.length;p<q;p++)f.event.add(n[p],"live."+M(h,m),{data:d,selector:m,handler:e,origType:h,origHandler:e,preType:l});else n.unbind("live."+M(h,m),e)}return this}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.bind(b,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0)}),function(){function u(a,b,c,d,e,f){for(var g=0,h=d.length;g<h;g++){var i=d[g];if(i){var j=!1;i=i[a];while(i){if(i.sizcache===c){j=d[i.sizset];break}if(i.nodeType===1){f||(i.sizcache=c,i.sizset=g);if(typeof b!="string"){if(i===b){j=!0;break}}else if(k.filter(b,[i]).length>0){j=i;break}}i=i[a]}d[g]=j}}}function t(a,b,c,d,e,f){for(var g=0,h=d.length;g<h;g++){var i=d[g];if(i){var j=!1;i=i[a];while(i){if(i.sizcache===c){j=d[i.sizset];break}i.nodeType===1&&!f&&(i.sizcache=c,i.sizset=g);if(i.nodeName.toLowerCase()===b){j=i;break}i=i[a]}d[g]=j}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d=0,e=Object.prototype.toString,g=!1,h=!0,i=/\\/g,j=/\W/;[0,0].sort(function(){h=!1;return 0});var k=function(b,d,f,g){f=f||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return f;var i,j,n,o,q,r,s,t,u=!0,w=k.isXML(d),x=[],y=b;do{a.exec(""),i=a.exec(y);if(i){y=i[3],x.push(i[1]);if(i[2]){o=i[3];break}}}while(i);if(x.length>1&&m.exec(b))if(x.length===2&&l.relative[x[0]])j=v(x[0]+x[1],d);else{j=l.relative[x[0]]?[d]:k(x.shift(),d);while(x.length)b=x.shift(),l.relative[b]&&(b+=x.shift()),j=v(b,j)}else{!g&&x.length>1&&d.nodeType===9&&!w&&l.match.ID.test(x[0])&&!l.match.ID.test(x[x.length-1])&&(q=k.find(x.shift(),d,w),d=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]);if(d){q=g?{expr:x.pop(),set:p(g)}:k.find(x.pop(),x.length===1&&(x[0]==="~"||x[0]==="+")&&d.parentNode?d.parentNode:d,w),j=q.expr?k.filter(q.expr,q.set):q.set,x.length>0?n=p(j):u=!1;while(x.length)r=x.pop(),s=r,l.relative[r]?s=x.pop():r="",s==null&&(s=d),l.relative[r](n,s,w)}else n=x=[]}n||(n=j),n||k.error(r||b);if(e.call(n)==="[object Array]")if(!u)f.push.apply(f,n);else if(d&&d.nodeType===1)for(t=0;n[t]!=null;t++)n[t]&&(n[t]===!0||n[t].nodeType===1&&k.contains(d,n[t]))&&f.push(j[t]);else for(t=0;n[t]!=null;t++)n[t]&&n[t].nodeType===1&&f.push(j[t]);else p(n,f);o&&(k(o,h,f,g),k.uniqueSort(f));return f};k.uniqueSort=function(a){if(r){g=h,a.sort(r);if(g)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},k.matches=function(a,b){return k(a,null,null,b)},k.matchesSelector=function(a,b){return k(b,null,null,[a]).length>0},k.find=function(a,b,c){var d;if(!a)return[];for(var e=0,f=l.order.length;e<f;e++){var g,h=l.order[e];if(g=l.leftMatch[h].exec(a)){var j=g[1];g.splice(1,1);if(j.substr(j.length-1)!=="\\"){g[1]=(g[1]||"").replace(i,""),d=l.find[h](g,b,c);if(d!=null){a=a.replace(l.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},k.filter=function(a,c,d,e){var f,g,h=a,i=[],j=c,m=c&&c[0]&&k.isXML(c[0]);while(a&&c.length){for(var n in l.filter)if((f=l.leftMatch[n].exec(a))!=null&&f[2]){var o,p,q=l.filter[n],r=f[1];g=!1,f.splice(1,1);if(r.substr(r.length-1)==="\\")continue;j===i&&(i=[]);if(l.preFilter[n]){f=l.preFilter[n](f,j,d,i,e,m);if(!f)g=o=!0;else if(f===!0)continue}if(f)for(var s=0;(p=j[s])!=null;s++)if(p){o=q(p,f,s,j);var t=e^!!o;d&&o!=null?t?g=!0:j[s]=!1:t&&(i.push(p),g=!0)}if(o!==b){d||(j=i),a=a.replace(l.match[n],"");if(!g)return[];break}}if(a===h)if(g==null)k.error(a);else break;h=a}return j},k.error=function(a){throw"Syntax error, unrecognized expression: "+a};var l=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!j.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&k.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!j.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&k.filter(b,a,!0)}},"":function(a,b,c){var e,f=d++,g=u;typeof b=="string"&&!j.test(b)&&(b=b.toLowerCase(),e=b,g=t),g("parentNode",b,f,a,e,c)},"~":function(a,b,c){var e,f=d++,g=u;typeof b=="string"&&!j.test(b)&&(b=b.toLowerCase(),e=b,g=t),g("previousSibling",b,f,a,e,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(i,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(i,"")},TAG:function(a,b){return a[1].replace(i,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||k.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&k.error(a[0]);a[0]=d++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(i,"");!f&&l.attrMap[g]&&(a[1]=l.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(i,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=k(b[3],null,null,c);else{var g=k.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(l.match.POS.test(b[0])||l.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!k(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=l.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||k.getText([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}k.error(e)},CHILD:function(a,b){var c=b[1],d=a;switch(c){case"only":case"first":while(d=d.previousSibling)if(d.nodeType===1)return!1;if(c==="first")return!0;d=a;case"last":while(d=d.nextSibling)if(d.nodeType===1)return!1;return!0;case"nth":var e=b[2],f=b[3];if(e===1&&f===0)return!0;var g=b[0],h=a.parentNode;if(h&&(h.sizcache!==g||!a.nodeIndex)){var i=0;for(d=h.firstChild;d;d=d.nextSibling)d.nodeType===1&&(d.nodeIndex=++i);h.sizcache=g}var j=a.nodeIndex-f;return e===0?j===0:j%e===0&&j/e>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=l.attrHandle[c]?l.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=l.setFilters[e];if(f)return f(a,c,b,d)}}},m=l.match.POS,n=function(a,b){return"\\"+(b-0+1)};for(var o in l.match)l.match[o]=new RegExp(l.match[o].source+/(?![^\[]*\])(?![^\(]*\))/.source),l.leftMatch[o]=new RegExp(/(^(?:.|\r|\n)*?)/.source+l.match[o].source.replace(/\\(\d+)/g,n));var p=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(q){p=function(a,b){var c=0,d=b||[];if(e.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var f=a.length;c<f;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var r,s;c.documentElement.compareDocumentPosition?r=function(a,b){if(a===b){g=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(r=function(a,b){if(a===b){g=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],h=a.parentNode,i=b.parentNode,j=h;if(h===i)return s(a,b);if(!h)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return s(e[k],f[k]);return k===c?s(a,f[k],-1):s(e[k],b,1)},s=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),k.getText=function(a){var b="",c;for(var d=0;a[d];d++)c=a[d],c.nodeType===3||c.nodeType===4?b+=c.nodeValue:c.nodeType!==8&&(b+=k.getText(c.childNodes));return b},function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(l.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},l.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(l.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(l.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=k,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){k=function(b,e,f,g){e=e||c;if(!g&&!k.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return p(e.getElementsByTagName(b),f);if(h[2]&&l.find.CLASS&&e.getElementsByClassName)return p(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return p([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return p([],f);if(i.id===h[3])return p([i],f)}try{return p(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var m=e,n=e.getAttribute("id"),o=n||d,q=e.parentNode,r=/^\s*[+~]/.test(b);n?o=o.replace(/'/g,"\\$&"):e.setAttribute("id",o),r&&q&&(e=e.parentNode);try{if(!r||q)return p(e.querySelectorAll("[id='"+o+"'] "+b),f)}catch(s){}finally{n||m.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)k[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}k.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(a))try{if(e||!l.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return k(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;l.order.splice(1,0,"CLASS"),l.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?k.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?k.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:k.contains=function(){return!1},k.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var v=function(a,b){var c,d=[],e="",f=b.nodeType?[b]:b;while(c=l.match.PSEUDO.exec(a))e+=c[0],a=a.replace(l.match.PSEUDO,"");a=l.relative[a]?a+"*":a;for(var g=0,h=f.length;g<h;g++)k(a,f[g],d);return k.filter(e,d)};f.find=k,f.expr=k.selectors,f.expr[":"]=f.expr.filters,f.unique=k.uniqueSort,f.text=k.getText,f.isXMLDoc=k.isXML,f.contains=k.contains}();var N=/Until$/,O=/^(?:parents|prevUntil|prevAll)/,P=/,/,Q=/^.[^:#\[\.,]*$/,R=Array.prototype.slice,S=f.expr.match.POS,T={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(V(this,a,!1),"not",a)},filter:function(a){return this.pushStack(V(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h,i,j={},k=1;if(g&&a.length){for(d=0,e=a.length;d<e;d++)i=a[d],j[i]||(j[i]=S.test(i)?f(i,b||this.context):i);while(g&&g.ownerDocument&&g!==b){for(i in j)h=j[i],(h.jquery?h.index(g)>-1:f(g).is(h))&&c.push({selector:i,elem:g,level:k});g=g.parentNode,k++}}return c}var l=S.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(l?l.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(U(c[0])||U(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c),g=R.call(arguments);N.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!T[a]?f.unique(e):e,(this.length>1||P.test(d))&&O.test(a)&&(e=e.reverse());return this.pushStack(e,a,g.join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|object|embed|option|style)/i,bb=/checked\s*(?:[^=]|=\s*.checked.)/i,bc=/\/(java|ecma)script/i,bd=/^\s*<!(?:\[CDATA\[|\-\-)/,be={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};be.optgroup=be.option,be.tbody=be.tfoot=be.colgroup=be.caption=be.thead,be.th=be.td,f.support.htmlSerialize||(be._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){f(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f(arguments[0]).toArray());return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!be[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bb.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bf(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bl)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i;b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof a[0]=="string"&&a[0].length<512&&i===c&&a[0].charAt(0)==="<"&&!ba.test(a[0])&&(f.support.checkClone||!bb.test(a[0]))&&(g=!0,h=f.fragments[a[0]],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean
(a,i,e,d)),g&&(f.fragments[a[0]]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d=a.cloneNode(!0),e,g,h;if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bh(a,d),e=bi(a),g=bi(d);for(h=0;e[h];++h)g[h]&&bh(e[h],g[h])}if(b){bg(a,d);if(c){e=bi(a),g=bi(d);for(h=0;e[h];++h)bg(e[h],g[h])}}e=g=null;return d},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=be[l]||be._default,n=m[0],o=b.createElement("div");o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bk(k[i]);else bk(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||bc.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.expando,g=f.event.special,h=f.support.deleteExpando;for(var i=0,j;(j=a[i])!=null;i++){if(j.nodeName&&f.noData[j.nodeName.toLowerCase()])continue;c=j[f.expando];if(c){b=d[c]&&d[c][e];if(b&&b.events){for(var k in b.events)g[k]?f.event.remove(j,k):f.removeEvent(j,k,b.handle);b.handle&&(b.handle.elem=null)}h?delete j[f.expando]:j.removeAttribute&&j.removeAttribute(f.expando),delete d[c]}}}});var bm=/alpha\([^)]*\)/i,bn=/opacity=([^)]*)/,bo=/([A-Z]|^ms)/g,bp=/^-?\d+(?:px)?$/i,bq=/^-?\d/,br=/^([\-+])=([\-+.\de]+)/,bs={position:"absolute",visibility:"hidden",display:"block"},bt=["Left","Right"],bu=["Top","Bottom"],bv,bw,bx;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bv(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=br.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bv)return bv(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return by(a,b,d);f.swap(a,bs,function(){e=by(a,b,d)});return e}},set:function(a,b){if(!bp.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bn.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNaN(b)?"":"alpha(opacity="+b*100+")",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bm,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bm.test(g)?g.replace(bm,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bv(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bw=function(a,c){var d,e,g;c=c.replace(bo,"-$1").toLowerCase();if(!(e=a.ownerDocument.defaultView))return b;if(g=e.getComputedStyle(a,null))d=g.getPropertyValue(c),d===""&&!f.contains(a.ownerDocument.documentElement,a)&&(d=f.style(a,c));return d}),c.documentElement.currentStyle&&(bx=function(a,b){var c,d=a.currentStyle&&a.currentStyle[b],e=a.runtimeStyle&&a.runtimeStyle[b],f=a.style;!bp.test(d)&&bq.test(d)&&(c=f.left,e&&(a.runtimeStyle.left=a.currentStyle.left),f.left=b==="fontSize"?"1em":d||0,d=f.pixelLeft+"px",f.left=c,e&&(a.runtimeStyle.left=e));return d===""?"auto":d}),bv=bw||bx,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bz=/%20/g,bA=/\[\]$/,bB=/\r?\n/g,bC=/#.*$/,bD=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bE=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bF=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bG=/^(?:GET|HEAD)$/,bH=/^\/\//,bI=/\?/,bJ=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bK=/^(?:select|textarea)/i,bL=/\s+/,bM=/([?&])_=[^&]*/,bN=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bO=f.fn.load,bP={},bQ={},bR,bS,bT=["*/"]+["*"];try{bR=e.href}catch(bU){bR=c.createElement("a"),bR.href="",bR=bR.href}bS=bN.exec(bR.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bO)return bO.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bJ,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bK.test(this.nodeName)||bE.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bB,"\r\n")}}):{name:b.name,value:c.replace(bB,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.bind(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?bX(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),bX(a,b);return a},ajaxSettings:{url:bR,isLocal:bF.test(bS[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bT},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bV(bP),ajaxTransport:bV(bQ),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?bZ(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=b$(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.resolveWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f._Deferred(),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bD.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.done,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bC,"").replace(bH,bS[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bL),d.crossDomain==null&&(r=bN.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bS[1]&&r[2]==bS[2]&&(r[3]||(r[1]==="http:"?80:443))==(bS[3]||(bS[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bW(bP,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bG.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bI.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bM,"$1_="+x);d.url=y+(y===d.url?(bI.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bT+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bW(bQ,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){s<2?w(-1,z):f.error(z)}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)bY(g,a[g],c,e);return d.join("&").replace(bz,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var b_=f.now(),ca=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+b_++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ca.test(b.url)||e&&ca.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ca,l),b.url===j&&(e&&(k=k.replace(ca,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cb=a.ActiveXObject?function(){for(var a in cd)cd[a](0,1)}:!1,cc=0,cd;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ce()||cf()}:ce,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cb&&delete cd[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cc,cb&&(cd||(cd={},f(a).unload(cb)),cd[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cg={},ch,ci,cj=/^(?:toggle|show|hide)$/,ck=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cl,cm=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cn;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cq("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cr(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cq("hide",3),a,b,c);for(var d=0,e=this.length;d<e;d++)if(this[d].style){var g=f.css(this[d],"display");g!=="none"&&!f._data(this[d],"olddisplay")&&f._data(this[d],"olddisplay",g)}for(d=0;d<e;d++)this[d].style&&(this[d].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cq("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return this[e.queue===!1?"each":"queue"](function(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(f.support.inlineBlockNeedsLayout?(j=cr(this.nodeName),j==="inline"?this.style.display="inline-block":(this.style.display="inline",this.style.zoom=1)):this.style.display="inline-block"))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)k=new f.fx(this,b,i),h=a[i],cj.test(h)?k[h==="toggle"?d?"show":"hide":h]():(l=ck.exec(h),m=k.cur(),l?(n=parseFloat(l[2]),o=l[3]||(f.cssNumber[i]?"":"px"),o!=="px"&&(f.style(this,i,(n||1)+o),m=(n||1)/k.cur()*m,f.style(this,i,m+o)),l[1]&&(n=(l[1]==="-="?-1:1)*n+m),k.custom(m,n,o)):k.custom(m,h,""));return!0})},stop:function(a,b){a&&this.queue([]),this.each(function(){var a=f.timers,c=a.length;b||f._unmark(!0,this);while(c--)a[c].elem===this&&(b&&a[c](!0),a.splice(c,1))}),b||this.dequeue();return this}}),f.each({slideDown:cq("show",1),slideUp:cq("hide",1),slideToggle:cq("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default,d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue!==!1?f.dequeue(this):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,b,c){function g(a){return d.step(a)}var d=this,e=f.fx;this.startTime=cn||co(),this.start=a,this.end=b,this.unit=c||this.unit||(f.cssNumber[this.prop]?"":"px"),this.now=this.start,this.pos=this.state=0,g.elem=this.elem,g()&&f.timers.push(g)&&!cl&&(cl=setInterval(e.tick,e.interval))},show:function(){this.options.orig[this.prop]=f.style(this.elem,this.prop),this.options.show=!0,this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b=cn||co(),c=!0,d=this.elem,e=this.options,g,h;if(a||b>=e.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),e.animatedProperties[this.prop]=!0;for(g in e.animatedProperties)e.animatedProperties[g]!==!0&&(c=!1);if(c){e.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){d.style["overflow"+b]=e.overflow[a]}),e.hide&&f(d).hide();if(e.hide||e.show)for(var i in e.animatedProperties)f.style(d,i,e.orig[i]);e.complete.call(d)}return!1}e.duration==Infinity?this.now=b:(h=b-this.startTime,this.state=h/e.duration,this.pos=f.easing[e.animatedProperties[this.prop]](this.state,h,0,1,e.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){for(var a=f.timers,b=0;b<a.length;++b)a[b]()||a.splice(b--,1);a.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cl),cl=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit:a.elem[a.prop]=a.now}}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cs=/^t(?:able|d|h)$/i,ct=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cu(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);f.offset.initialize();var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.offset.supportsFixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.offset.doesNotAddBorder&&(!f.offset.doesAddBorderForTableAndCells||!cs.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.offset.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.offset.supportsFixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={initialize:function(){var a=c.body,b=c.createElement("div"),d,e,g,h,i=parseFloat(f.css(a,"marginTop"))||0,j="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";f.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"}),b.innerHTML=j,a.insertBefore(b,a.firstChild),d=b.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,this.doesNotAddBorder=e.offsetTop!==5,this.doesAddBorderForTableAndCells=h.offsetTop===5,e.style.position="fixed",e.style.top="20px",this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==i,a.removeChild(b),f.offset.initialize=f.noop},bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.offset.initialize(),f.offset.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=ct.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!ct.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cu(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cu(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a&&a.style?parseFloat(f.css(a,d,"padding")):null},f.fn["outer"+c]=function(a){var b=this[0];return b&&b.style?parseFloat(f.css(b,d,a?"margin":"border")):null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNaN(j)?i:j}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f})(window);
(function($){$.toJSON=function(o)
{if(typeof(JSON)=='object'&&JSON.stringify)
return JSON.stringify(o);var type=typeof(o);if(o===null)
return"null";if(type=="undefined")
return undefined;if(type=="number"||type=="boolean")
return o+"";if(type=="string")
return $.quoteString(o);if(type=='object')
{if(typeof o.toJSON=="function")
return $.toJSON(o.toJSON());if(o.constructor===Date)
{var month=o.getUTCMonth()+1;if(month<10)month='0'+month;var day=o.getUTCDate();if(day<10)day='0'+day;var year=o.getUTCFullYear();var hours=o.getUTCHours();if(hours<10)hours='0'+hours;var minutes=o.getUTCMinutes();if(minutes<10)minutes='0'+minutes;var seconds=o.getUTCSeconds();if(seconds<10)seconds='0'+seconds;var milli=o.getUTCMilliseconds();if(milli<100)milli='0'+milli;if(milli<10)milli='0'+milli;return'"'+year+'-'+month+'-'+day+'T'+
hours+':'+minutes+':'+seconds+'.'+milli+'Z"';}
if(o.constructor===Array)
{var ret=[];for(var i=0;i<o.length;i++)
ret.push($.toJSON(o[i])||"null");return"["+ret.join(",")+"]";}
var pairs=[];for(var k in o){var name;var type=typeof k;if(type=="number")
name='"'+k+'"';else if(type=="string")
name=$.quoteString(k);else
continue;if(typeof o[k]=="function")
continue;var val=$.toJSON(o[k]);pairs.push(name+":"+val);}
return"{"+pairs.join(", ")+"}";}};$.evalJSON=function(src)
{if(typeof(JSON)=='object'&&JSON.parse)
return JSON.parse(src);return eval("("+src+")");};$.secureEvalJSON=function(src)
{if(typeof(JSON)=='object'&&JSON.parse)
return JSON.parse(src);var filtered=src;filtered=filtered.replace(/\\["\\\/bfnrtu]/g,'@');filtered=filtered.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']');filtered=filtered.replace(/(?:^|:|,)(?:\s*\[)+/g,'');if(/^[\],:{}\s]*$/.test(filtered))
return eval("("+src+")");else
throw new SyntaxError("Error parsing JSON, source is not valid.");};$.quoteString=function(string)
{if(string.match(_escapeable))
{return'"'+string.replace(_escapeable,function(a)
{var c=_meta[a];if(typeof c==='string')return c;c=a.charCodeAt();return'\\u00'+Math.floor(c/16).toString(16)+(c%16).toString(16);})+'"';}
return'"'+string+'"';};var _escapeable=/["\\\x00-\x1f\x7f-\x9f]/g;var _meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'};})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/utils/jquery.extend.js $
// Revision: 16259 $
$.extend({
  _urlVars : null,
  getUrlVars: function(){
    if ($._urlVars == null){
      var vars = [], hash;
      var str = window.location.href;
      var ipos = str.indexOf('#'); 
      if (ipos > -1)
        str = str.substring(0, ipos);
      var hashes = str.slice(str.indexOf('?') + 1).split('&');
      for(var i = 0; i < hashes.length; i++){
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
      }
      $._urlVars = vars;
    }
    return $._urlVars;
  },
  getUrlVar: function(name){
    var vars = $.getUrlVars();
    if (vars.hasOwnProperty(name))
      return vars[name];
    return null;
  },
  str2color : function(str){
    if (str && str.constructor == Array && str.length == 3) return str;
    var res;
    while (str.indexOf(' ') > -1) str = str.replace(' ', '');
    if (str.match(/rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)/)){
      str = str.replace("rgb(","");str=str.replace(")","");
      res=str.split(",");
      for(i=0;i<3;i++){if (res[i]>255) res[i]=255; else res[i]=parseInt(res[i]);}
      return res;}
    else if (str.match(/#?[0-9a-fA-F]{6}/)){
      if (str.length==7) str=str.substring(1);
      res = [parseInt(str.substring(0,2),16),
             parseInt(str.substring(2,4),16),
             parseInt(str.substring(4,6),16)];}
    else if(str.match(/#?[0-9a-fA-F]{3}/)){
      if (str.length==4) str=str.substring(1);
      res =  [parseInt(str.substring(0,1)+str.substring(0,1),16),
              parseInt(str.substring(1,2)+str.substring(1,2),16),
              parseInt(str.substring(2,3)+str.substring(2,3),16)];}
    else res = [0,0,0];
    return res;
  },
  rgbColor2Hex : function (str){
    while (str.indexOf(' ') > -1) str = str.replace(' ', '');
    if (str.match(/rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)/)){
      str = str.replace("rgb(","");str=str.replace(")","");
      res=str.split(",");
      for(i=0;i<3;i++){if (res[i]>255) res[i]=255; else res[i]=parseInt(res[i]);}
      return "#" + $.decToHex(res[0]) + $.decToHex(res[1]) + $.decToHex(res[2]);
    }
    return str;
  },
  decToHex : function (val){
    var res = val.toString(16);
    if (res.length % 2 == 1) res = '0' + res;
    return res;
  },
  idle : function(time){
    var i = $(this);
    i.queue(function(){
      setTimeout(function(){
        i.dequeue();
      }, time);
    });
  }
});
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/flex/flexInteractionCode.js $
// Revision: 14960 $

/***********************************************************\
|*                                                         *|
|*      Javascript class used to load a swf component      *|
|*                                                         *|
\***********************************************************/

// -- Detect Client Browser type
var isIEForFlashCode  = (navigator.appVersion.indexOf("MSIE") != -1) ? true : false;
var isWinForFlashCode = (navigator.appVersion.toLowerCase().indexOf("win") != -1) ? true : false;
var isOperaForFlashCode = (navigator.userAgent.indexOf("Opera") != -1) ? true : false;

// -- Flex Interface URL 
var strRootURL = get_rootUrl();
var strFlexInterfaceFileName = strRootURL + get_main_directory() + 
 'amfphp/gateway.php?session_id=' + get_session_id() + '&lng=' + get_lng();

// -- PHP Debug Mode
var bDebugMode = false;
var sDebugSyntax = 'DBGSESSID=1'; 

// -- Pictures Directory
var sPicturesDir = '';

// -- Swf Objects List
var aSwfObjects = [];

/**
 * Escape special characters in a string
 * @param sStrToEscape (string) : String to treat
 */
function swfEscapeChars(sStrToEscape)
{
  sStrToEscape = encodeURIComponent(sStrToEscape);
  
  /*while (sStrToEscape.indexOf("+") != -1)
  {
    sStrToEscape = sStrToEscape.replace("+", "%2B");
  }*/

  return (sStrToEscape);
}

/**
 * Enable or Disable PHP debug Mode
 * @param bEnabled (boolean) : Enable or Disable PHP debug Mode
 */
function setDebugMode(bEnabled)
{
  if (bEnabled == true)
    bDebugMode = true;
  else
    bDebugMode = false;
}

/**
 * Execute a javascript code
 * 
 * @param sJSCode Code to executed
 */
function evalJS(sJSCode)
{
  // Get Error Handle
  var fError = window.onerror;
  
  // Disable JS Error
  window.onerror = FlexNoJSError;
  
  // Eval JS
  eval(sJSCode);
  
  // Restore Error Handler
  window.error = fError;
} 

/**
 * Write a SWF Object in the HTML Page
 * @return Id use for SWF Object declaration. It may be different from strId Object if strId Object is already used
 * @param strSwfName Object : SWF Name
 * @param strId Object : ID use for SWF Object declaration
 * @param strWidth Object : Width used for the SWF Object
 * @param strHeight Object : Height used for the SWF Object
 * @param sDivName String : Name of the div that will contain the object. If Empty, the object will be written directly in the document
 */
function WriteSWFInADiv(strSwfName, strId, strWidth, strHeight, sDivName)
{
  return (WriteSWFAndDefineTransparentMode(strSwfName, strId, strWidth, strHeight, true, sDivName));
}

/**
 * Write a SWF Object in the HTML Page
 * @return Id use for SWF Object declaration. It may be different from strId Object if strId Object is already used
 * @param strSwfName Object : SWF Name
 * @param strId Object : ID use for SWF Object declaration
 * @param strWidth Object : Width used for the SWF Object
 * @param strHeight Object : Height used for the SWF Object
 */
function WriteSWF(strSwfName, strId, strWidth, strHeight)
{
  return (WriteSWFAndDefineTransparentMode(strSwfName, strId, strWidth, strHeight, true, ''));
}

/**
 * Write a SWF Object in the HTML Page
 * @return Id use for SWF Object declaration. It may be different from strId Object if strId Object is already used
 * @param strSwfName Object : SWF Name
 * @param strId Object : ID use for SWF Object declaration
 * @param strWidth Object : Width used for the SWF Object
 * @param strHeight Object : Height used for the SWF Object
 * @param bUseTransparentMode Boolean : If true then the attributes wmode and embed will be set to transparent else they will be not defined
 * @param sDivName String : Name of the div that will contain the object. If Empty, the object will be written directly in the document
 */
function WriteSWFAndDefineTransparentMode(strSwfName, strId, strWidth, strHeight, bUseTransparentMode, sDivName)
{
  // Major version of Flash required
  var requiredMajorVersion = 10;
  // Minor version of Flash required
  var requiredMinorVersion = 0;
  // Minor version of Flash required
  var requiredRevision = 0;
  
  // Version check for the Flash Player that has the ability to start Player Product Install
  var hasProductInstall = DetectFlashVer(10, 0, 0);

  // Version check based upon the values defined in globals
  var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);

  if ((hasProductInstall && !hasRequestedVersion) || hasRequestedVersion)
  {
    var arrParamsList = new Array();
    
    // Get Object Id
    strId = getFlashObjectId(strId);
    
    var iPos = strSwfName.indexOf('?');
    if (iPos > -1)
    {
      sFlashVars = strSwfName.substring(iPos + 1);
      strSwfName = strSwfName.substring(0, iPos)
    }
    else
      sFlashVars = '';
    
    arrParamsList.push("src");
    arrParamsList.push(strSwfName);
    arrParamsList.push("width");
    arrParamsList.push(strWidth);
    arrParamsList.push("height");
    arrParamsList.push(strHeight);
    arrParamsList.push("id");
    arrParamsList.push(strId);
    arrParamsList.push("quality");
    arrParamsList.push("high");
    arrParamsList.push("name");
    arrParamsList.push(strId);
    arrParamsList.push("allowScriptAccess");
    arrParamsList.push("sameDomain");
    arrParamsList.push("type");
    arrParamsList.push("application/x-shockwave-flash");
    arrParamsList.push("pluginspage");
    arrParamsList.push("http://www.adobe.com/go/getflashplayer");
    if (bUseTransparentMode)
    {
      arrParamsList.push("wmode");
      arrParamsList.push("transparent");
      arrParamsList.push("embed");
      arrParamsList.push("transparent");
    }
    
    if (hasProductInstall && !hasRequestedVersion)
    {
      // if we've detected an non-acceptable version
      
      // DO NOT MODIFY THE FOLLOWING FOUR LINES
      // Location visited after installation is complete if installation is required
      var MMPlayerType = (isIEForFlashCode == true) ? "ActiveX" : "PlugIn";
      var MMredirectURL = window.location;
      document.title = document.title.slice(0, 47) + " - Flash Player Installation";
      var MMdoctitle = document.title;
      
      arrParamsList.push("FlashVars");
      arrParamsList.push("MMredirectURL=" + MMredirectURL + '&MMplayerType=' + MMPlayerType + '&MMdoctitle=' + MMdoctitle);
    }
    else if (sFlashVars != '')
    {
      arrParamsList.push("FlashVars");
      arrParamsList.push(sFlashVars);
    }
  
    // if we've detected an acceptable or non-acceptable version embed the Flash Content SWF when all tests are passed
  
    // Format Arguments  
    var ret = AC_GetArgs(arrParamsList);
    // Write SWF Object call
    var str = AC_Generateobj(ret.objAttrs, ret.params, ret.embedAttrs);
    
    if (sDivName != '')
      document.getElementById(sDivName).innerHTML = str;
    else
      document.write(str);
    
    // Manage MouseWheel Event
    if (bUseTransparentMode && aSwfObjects.length == 0 && !(document.attachEvent))
    {
      window.addEventListener("DOMMouseScroll", handleWheel, true);
      window.addEventListener("mousewheel", handleWheel, true);
      
      aSwfObjects.push(strId);
    }
  }
  else 
  {
    // flash is too old or we can't detect the plug in
    var alternateContent = 'This content requires the Adobe Flash Player. ' + 
      '<a href=http://www.adobe.com/go/getflash/>Get Flash</a>';
      
    document.write(alternateContent);
    
    // Object does not exists
    strId = '';
  }
  
  return (strId);
}

/**
 * Get MouseWheel event
 * @param {Object} event MouseWheel Event
 */
function handleWheel(event)
{
  for (var iI = aSwfObjects.length - 1; iI >= 0; iI--)
  {
    var el = $("#" + aSwfObjects[iI]);
    if (el == null)
      continue;
    var offset = el.offset();
    var left = offset.left;
    var top = offset.top;
    var height = el.height();
    var width = el.width();
    
    if (event.clientX >= left && event.clientX <= left + width && event.clientY >= top && event.clientY <= top + height)
    {
      event.preventDefault();
      event.stopPropagation();
      var oEvent = {x: event.clientX, y: event.clientY,
        delta: event.detail ? event.detail : event.wheelDelta * -1  / 40,
        ctrlKey: event.ctrlKey, altKey: event.altKey,
        shiftKey: event.shiftKey}
      
      var objSWF = null;
      if (window[aSwfObjects[iI]] != null)
        objSWF = window[aSwfObjects[iI]];
      else
        objSWF = document[aSwfObjects[iI]];
      if (typeof(objSWF.handleWheel) != "undefined")
        objSWF.handleWheel(oEvent);
      return;
    }
  }
}

/**
 * Get Window Size
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function getWindowSize(strSWFId, strCallBackFunctionName)
{
  if (strCallBackFunctionName != '')
  {
	// N.M : Correction resize flex (vu par P.F sur les Gantt). A valider plus avant.
    if (navigator.appName == "Netscape" ) //&& navigator.appCodeName != 'Mozilla')
    {
      var iWidth = window.innerWidth;
      var iHeight = window.innerHeight;
    }
    else
    {
      var iWidth = document.body.parentNode.clientWidth > 0 ? document.body.parentNode.clientWidth : document.body.parentNode.offsetWidth;
      var iHeight = (document.body.parentNode.clientHeight) ? document.body.parentNode.clientHeight : document.body.parentNode.offsetHeight;
    }
    
    var oSize = '{"width" : ' + iWidth + ', "height" : ' + iHeight + '}';
    CallSWFFunction(strSWFId, strCallBackFunctionName, oSize);
  }
}

/**
 * Get Container Size
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function getContainerSize(strSWFId, strCallBackFunctionName)
{
  if (strCallBackFunctionName != '' && document.getElementById(strSWFId).parentNode != null)
  {
    var iWidth = document.getElementById(strSWFId).parentNode.offsetWidth;
    var iHeight = document.getElementById(strSWFId).parentNode.offsetHeight;
    
    var oSize = '{"width" : ' + iWidth + ', "height" : ' + iHeight + '}';
    CallSWFFunction(strSWFId, strCallBackFunctionName, oSize);
  }
}

/**
 * Set Window resize capture
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function captureWindowResize(strSWFId, strCallBackFunctionName)
{
  if (strCallBackFunctionName != '')
  {
    window.onresize = function ()
    {
      // N.M : Correction resize flex (vu par P.F sur les Gantt). A valider plus avant.
      if (navigator.appName == "Netscape" ) //&& navigator.appCodeName != 'Mozilla')
      {
        var iWidth = window.innerWidth;
        var iHeight = window.innerHeight;
      }
      else
      {
        var iWidth = document.body.parentNode.clientWidth > 0 ? document.body.parentNode.clientWidth : document.body.parentNode.offsetWidth;
        var iHeight = (document.body.parentNode.clientHeight) ? document.body.parentNode.clientHeight : document.body.parentNode.offsetHeight;
      }
            
      var oSize = '{"width" : ' + iWidth + ', "height" : ' + iHeight + '}';
      CallSWFFunction(strSWFId, strCallBackFunctionName, oSize);
    }
  }
}

/**
 * Get Screen Size
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function getScreenSize(strSWFId, strCallBackFunctionName)
{
  if (strCallBackFunctionName != '')
  {
    var oSize = '{"width" : ' + screen.availWidth + ', "height" : ' + screen.availHeight + '}';
    
    CallSWFFunction(strSWFId, strCallBackFunctionName, oSize);
  }
}

/**
 * Get Flex Interface URL
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function getFlexInterfaceUrl(strSWFId, strCallBackFunctionName)
{
  if (strCallBackFunctionName != '')
  {
    if (bDebugMode)
      CallSWFFunction(strSWFId, strCallBackFunctionName, strFlexInterfaceFileName + '&' + sDebugSyntax);
    else
      CallSWFFunction(strSWFId, strCallBackFunctionName, strFlexInterfaceFileName);
  }
}

/**
 * Call an Operation of a Web Interface
 * 
 * @param strSWFId Object : Id associates to the SWF
 * @param webinterface : Name of the Web Interface
 * @param operation : Name of the Operation
 * @param params : Params of the Operation. This is an array encoded with JSON (each line contains the parameter name as key and associated value as value)
 * @param strCallBackFunctionName Object : Name of the function which get result
 */
function callWebInterfaceFromFlex(strSWFId, webinterface, operation, params, strCallBackFunctionName)
{
  var url = strRootURL + get_main_directory() + 'webinterface/WebInterface.php';
  $.ajax({
      type: "POST",
      url: url,
      data: "webinterface=" + webinterface + "&operation=" + operation + "&params=" + params,
      dataType: "json",
      success: function(oRes) { 
        if (strCallBackFunctionName != '')
          CallSWFFunction(strSWFId, strCallBackFunctionName, $.toJSON(oRes));
      },
      error: function(jqXHR, textStatus, errorThrown) { alert("Error " + errorThrown); }
    });
}

/**
 * Get content (in JSON) stored in a JS variable
 * @param strSWFId Object : Id associates to the SWF
 * @param strVarName (String) : Name of the JS Variable
 * @param strCallBackFunctionName Object : Name of the function which get result
 * @return Object representing content stored in the JS Variable, NULL if the variable does not exist
 */
function getContentVar(strSWFId, strVarName, strCallBackFunctionName)
{
  fError = window.onerror; 
  window.onerror = FlexNoJSError;
  var objVar = eval(strVarName);
  window.onerror = fError;
  
  if (typeof(objVar) == "undefined")
    objVar = null;
    
  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, objVar);
}

/**
 * Get content (in JSON) of a variable stored in the PHP SESSION
 * @param strSWFId Object : Id associates to the SWF
 * @param strVarName (String) : Name of the Variable stored in the PHP session
 * @param strCallBackFunctionName Object : Name of the function which get result
 * @return Object representing content stored in the Variable, NULL if the variable does not exist
 */
function getSessionVar(strSWFId, strVarName, strCallBackFunctionName)
{
  var strFlexInterfaceUrl = strRootURL + get_main_directory() + 
    'include/javascript/staff/flex/flexInterface.php?session_id=' + get_session_id() + '&lng=' + get_lng() + '&uniqid=' + get_session_uniqid();
  strFlexInterfaceUrl += '&pictures=' + sPicturesDir;
  
  if (bDebugMode)
    strFlexInterfaceUrl += '&' + sDebugSyntax; 
  
  strFlexInterfaceUrl += '&action=' + swfEscapeChars('getSessionVar');
  strFlexInterfaceUrl += '&varName=' + swfEscapeChars(strVarName);
  
  var xhr_object = null;   
  
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return ("");   
  } 
  
  xhr_object.open("GET", strFlexInterfaceUrl, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    objVar = xhr_object.responseText; 
  else
    objVar = "";
    
  if (typeof(objVar) == "undefined")
    objVar = null;
    
  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, objVar);
}

/**
 * Get contents (in JSON) of frequently used variables stored in the PHP SESSION
 * @param strSWFId Object : Id associates to the SWF
 * @param strCallBackFunctionName Object : Name of the function which get result
 * @return Array containing the name of the variables as index and there content as value
 */
function getBasicSessionVars(strSWFId, strCallBackFunctionName)
{
  var sSession = 'session_id=' + get_session_id() + '&lng=' + get_lng() + '&uniqid=' + get_session_uniqid();
  
  var strFlexInterfaceUrl = strRootURL + get_main_directory() + 
    'include/javascript/staff/flex/flexInterface.php?' + sSession;
  strFlexInterfaceUrl += '&pictures=' + sPicturesDir;
  strFlexInterfaceUrl += '&session=' + swfEscapeChars(sSession);

  if (bDebugMode)
    strFlexInterfaceUrl += '&' + sDebugSyntax; 
  
  strFlexInterfaceUrl += '&action=' + swfEscapeChars('getBasicSessionVars');
  
  var xhr_object = null;   
  
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return ("");   
  } 
  
  xhr_object.open("GET", strFlexInterfaceUrl, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    objVar = xhr_object.responseText; 
  else
    objVar = "";

  if (typeof(objVar) == "undefined")
    objVar = null;
    
  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, objVar);
}

/**
 * Get translations (in JSON) stored in a PHP file
 * @param strSWFId String : Id associates to the SWF
 * @param strFileName String : Name of the file
 * @param strCallBackFunctionName String : Name of the function which get result
 * @return Array containing the name of the variables as index and there content as value
 */
function getTranslationVar(strSWFId, strFileName, strCallBackFunctionName)
{
  var strFlexInterfaceUrl = strRootURL + get_main_directory() + 
    'include/javascript/staff/flex/flexInterface.php?session_id=' + get_session_id() + '&lng=' + get_lng() + '&uniqid=' + get_session_uniqid();
  strFlexInterfaceUrl += '&pictures=' + sPicturesDir;
    
  if (bDebugMode)
    strFlexInterfaceUrl += '&' + sDebugSyntax; 
  
  strFlexInterfaceUrl += '&action=' + swfEscapeChars('getTranslationVar');
  strFlexInterfaceUrl += '&p1=' + swfEscapeChars(strFileName);
  
  var xhr_object = null;   
  
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return ("");   
  } 
  
  xhr_object.open("GET", strFlexInterfaceUrl, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    objVar = xhr_object.responseText; 
  else
    objVar = "";

  if (typeof(objVar) == "undefined")
    objVar = null;
    
  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, objVar);
}

/**
 * Get translations (in JSON) stored in a PHP file and Get contents (in JSON) of frequently used variables stored in the PHP SESSION
 * @param strSWFId String : Id associates to the SWF
 * @param strFileName String : Name of the file
 * @param strCallBackFunctionName String : Name of the function which get result
 * @return Array containing the name of the variables as index and there content as value
 */
function getTranslationVarAndBasicSessionVars(strSWFId, strFileName, strCallBackFunctionName)
{
  var strFlexInterfaceUrl = strRootURL + get_main_directory() + 
    'include/javascript/staff/flex/flexInterface.php?session_id=' + get_session_id() + '&lng=' + get_lng() + '&uniqid=' + get_session_uniqid();
  strFlexInterfaceUrl += '&pictures=' + sPicturesDir;
    
  if (bDebugMode)
    strFlexInterfaceUrl += '&' + sDebugSyntax; 
  
  strFlexInterfaceUrl += '&action=' + swfEscapeChars('getTranslationVarAndBasicSessionVars');
  strFlexInterfaceUrl += '&p1=' + swfEscapeChars(strFileName);
  
  var xhr_object = null;   
  
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return ("");   
  } 
  
  xhr_object.open("GET", strFlexInterfaceUrl, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    objVar = xhr_object.responseText; 
  else
    objVar = "";

  if (typeof(objVar) == "undefined")
    objVar = null;
    
  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, objVar);
}


/**
 * Get an Object Id not used
 * @return ID usable
 * @param strId Object : ID use for SWF Object declaration
 */
function getFlashObjectId(strId)
{
  strIdResult = strId;
  
  // An object Id is not used if it is not already used by another tag in the HTML 
  if (document.getElementById(strIdResult) != null)
  {
    for (intI = 0; ; intI++)
    {
      strIdResult = strId + intI;
      if (document.getElementById(strIdResult) == null)
      {
        break;
      }
    }
  }
  
  return (strIdResult);
}

/**
 * Resize a SWF Object
 * @return Nothing
 * @param strId Object : Id associates with the SWF Object
 * @param strWidth Object : Width used for the SWF Object
 * @param strHeight Object : Height used for the SWF Object
 */
function ResizeSwf(strId, strHeight, strWidth)
{
  //alert("Resize : " + strId);
  if (document.getElementById(strId) != null)
  {
    if (strHeight != '')
      document.getElementById(strId).height = strHeight;
    
    if (strWidth != '')
      document.getElementById(strId).width = strWidth;
  }
  
  /* Verify if a specific function called "ResizePageAfterSWFSizeChange" exists.
   * If it exists, it is called after the resizing of the SWF Object
   */
  fError = window.onerror; 
  window.onerror = FlexNoJSError;
  var func = eval("ResizePageAfterSWFSizeChange");
  window.onerror = fError;
  
  if (typeof(func) != "undefined")
    func();
}

/**
 * Désactivation temporaire des erreurs JS
 * */
function FlexNoJSError()
{
  return (true);
}

/**
 * Call an actionScript function
 * @return Nothing
 * @param strSWFId Object : Id associates to the SWF
 * @param strFunctionName Object : SWF Function Name 
 * @param arrParamsList Object : array containing params for the function
 */
function CallSWFFunction(strSWFId, strFunctionName, arrParamsList)
{
  var objSWF = null;
  if (window[strSWFId] != null)
    objSWF = window[strSWFId];
  else
    objSWF = document[strSWFId];

  if (objSWF != null)
  {
    try
    {
      var strAction = "objSWF.swfCallback('" + strFunctionName + "'";
      
      if (arrParamsList != null)
      {
        strAction += ",";
        
        if (typeof(arrParamsList) == "string")
        {
          // arrParamsList is a string
          strAction += "'" + escapeSpecialChars(arrParamsList) + "'";
        }
        else if (typeof(arrParamsList) == "boolean")
        {
          if (arrParamsList)
            strAction += 'true';
          else
            strAction += 'false';
        }
        else if (typeof(arrParamsList) == "object" && arrParamsList[0] != null)
        {
          // arrParamsList object is an array
          // Add all params
          for (intI = 0; intI < arrParamsList.length; intI++)
          {
            if (intI > 0)
              strAction += ", ";
            
            if (typeof(arrParamsList) == "boolean")
            {
              if (arrParamsList)
                strAction += 'true';
              else
                strAction += 'false';
            }
            else
              strAction += "'" + escapeSpecialChars(arrParamsList[intI]) + "'";
          }
        }
      }
      
      strAction += ")";
      eval(strAction);
    }
    
    catch (e)
    {
      // On attend une seconde puis on ré essaye car parfois il y a un laps de temps nécessaire à l'activation de la fonction JS définie par le SWF
      setTimeout('CallSWFFunction2ndChance("' + strSWFId + '", "' + strAction + '", 0)', 1000);
    }
  }
}

/**
 * Call an actionScript function for a second time
 * @return Nothing
 * @param strSWFId Object : Id associates to the SWF
 * @param strEval String : Code to eval
 */
function CallSWFFunction2ndChance(strSWFId, strEval, iNbStep)
{
  var objSWF = null;
  if (window[strSWFId] != null)
    objSWF = window[strSWFId];
  else
    objSWF = document[strSWFId];

  if (objSWF != null)
  {
    try
    {
      eval(strEval);
    }
    
    catch (e)
    {
      if (iNbStep < 10)
      {
        iNbStep++;
        // On attend une seconde puis on ré essaye car parfois il y a un laps de temps nécessaire à l'activation de la fonction JS définie par le SWF
        setTimeout('CallSWFFunction2ndChance("' + strSWFId + '", "' + strEval + '", ' + iNbStep + ')', 1000);
      }
      else
        alert(strEval + ' : ' + e.message);
    }
  }
}

/**
 * escape Special Chars (\r, \n)
 * @return String with Special Chars escaped 
 * @param str Object : String to treat
 */
function escapeSpecialChars(str)
{
  var reg = new RegExp("(\r\n)", "g");  
  str = str.replace(reg, '\\n');
  
  reg = new RegExp("(\n)", "g");  
  str = str.replace(reg, '\\n');
  
  reg = new RegExp("(\r)", "g");
  str = str.replace(reg, '\\r');
  
  reg = new RegExp("(')", "g");
  str = str.replace(reg, "&#39;");
  
  str = encodeURIComponent(str);
  
  return (str);
}

/**
 * Show a specific dialog
 * @param strSWFId String : Id associates to the SWF
 * @param strDialogGUID String : Dialog GUID to display
 * @param strId String : Id of the element to display
 * @param strCallBackFunctionName String : Name of the function which get result (true if success else false)
 */
function showDialog(strSWFId, strDialogGUID, strId, strCallBackFunctionName)
{
  var strFlexInterfaceUrl = strRootURL + get_main_directory() + 
    'include/javascript/staff/flex/flexInterface.php?session_id=' + get_session_id() + '&lng=' + get_lng() + '&uniqid=' + get_session_uniqid();
    
  if (bDebugMode)
    strFlexInterfaceUrl += '&' + sDebugSyntax; 
  
  strFlexInterfaceUrl += '&action=' + swfEscapeChars('showDialog');
  strFlexInterfaceUrl += '&p1=' + swfEscapeChars(strDialogGUID);
  strFlexInterfaceUrl += '&p2=' + swfEscapeChars(strId);
  
  var xhr_object = null;   
  
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return ("");   
  } 
  
  xhr_object.open("GET", strFlexInterfaceUrl, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    objVar = xhr_object.responseText; 
  else
    objVar = "";

  if (typeof(objVar) == "undefined")
    objVar = null;
  
  if (window.opener != null && objVar != null && objVar != '' && objVar != '""')
  {
    var iPos = window.opener.location.href.indexOf("?");
    if (iPos > 0)
      sUrl = window.opener.location.href.substr(0, iPos);
    else
      sUrl = window.opener.location.href;
    
    sUrl += '?' + get_session_name() + '=' + get_session_id();
    sUrl += objVar.replace('"', '').replace('"', '');
    
    window.opener.location.href = sUrl;
    
    bSuccess = true; 
  }
  else
    bSuccess = false;

  if (strCallBackFunctionName != '')
    CallSWFFunction(strSWFId, strCallBackFunctionName, bSuccess);
}

/**
 * Show a specific dialog in a Popup
 * @param strSWFId String : Id associates to the SWF
 * @param strDialogGUID String : Dialog (GUID) to display
 * @param strId String : Id of the element to display
 */
function showDialogPopup(strSWFId, strDialogGUID, strId)
{
  var strInterfaceUrl = strRootURL + get_main_directory() + 
    'include/fic.php?' + get_session_name() + '=' + get_session_id();
  strInterfaceUrl += '&DialogID=' + strDialogGUID + '&id=' + strId;
    
  if (bDebugMode)
    strInterfaceUrl += '&' + sDebugSyntax; 
  
  window.open(strInterfaceUrl, '', 'scrollbars=yes,status=no,width=800,height=600,top=120,left=120,resizable=yes');
}

/**
 * Show a specific wizard in a Popup
 * @param strSWFId String : Id associates to the SWF
 * @param strWizardGUID String : Wizard (GUID) to display
 * @param strParams String : Params to send to the Wizard
 */
function showWizardPopup(strSWFId, strWizardGUID, strParams)
{
  var strInterfaceUrl = strRootURL + get_main_directory() + 
    'Wizard.php?' + get_session_name() + '=' + get_session_id();
  strInterfaceUrl += '&init_wizard=true&from_type=swf&guid=' + strWizardGUID + '&' + strParams;
    
  if (bDebugMode)
    strInterfaceUrl += '&' + sDebugSyntax; 
  
  window.open(strInterfaceUrl, '', 'scrollbars=yes,status=no,width=800,height=600,top=120,left=120,resizable=yes');
}

/*************************************************************************************/
// Flash Player Version Detection - Rev 1.6
// Copyright(c) 2005-2006 Adobe Macromedia Software, LLC. All rights reserved.

function ControlVersion()
{
  var version;
  var axo;
  var e;

  // NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry
  try 
  {
    // version will be set for 7.X or greater players
    axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
    version = axo.GetVariable("$version");
  } 
  catch (e) 
  {
  }

  if (!version)
  {
    try 
    {
      // version will be set for 6.X players only
      axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
      
      // installed player is some revision of 6.0
      // GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
      // so we have to be careful. 
      
      // default to the first public version
      version = "WIN 6,0,21,0";

      // throws if AllowScripAccess does not exist (introduced in 6.0r47)   
      axo.AllowScriptAccess = "always";

      // safe to call for 6.0r47 or greater
      version = axo.GetVariable("$version");

    } 
    catch (e) 
    {
    }
  }

  if (!version)
  {
    try 
    {
      // version will be set for 4.X or 5.X player
      axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
      version = axo.GetVariable("$version");
    } 
    catch (e) 
    {
    }
  }

  if (!version)
  {
    try 
    {
      // version will be set for 3.X player
      axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
      version = "WIN 3,0,18,0";
    } 
    catch (e) 
    {
    }
  }

  if (!version)
  {
    try 
    {
      // version will be set for 2.X player
      axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
      version = "WIN 2,0,0,11";
    } 
    catch (e) 
    {
      version = -1;
    }
  }
  
  return version;
}

// JavaScript helper required to detect Flash Player PlugIn version information
function GetSwfVer()
{
  // NS/Opera version >= 3 check for Flash plugin in plugin array
  var flashVer = -1;
  
  if (navigator.plugins != null && navigator.plugins.length > 0) 
  {
    if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) 
    {
      var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
      var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
      var descArray = flashDescription.split(" ");
      var tempArrayMajor = descArray[2].split(".");     
      var versionMajor = tempArrayMajor[0];
      var versionMinor = tempArrayMajor[1];
      var versionRevision = descArray[3];
      if (versionRevision == "") 
      {
        versionRevision = descArray[4];
      }
      
      if (versionRevision[0] == "d") 
      {
        versionRevision = versionRevision.substring(1);
      }
      else if (versionRevision[0] == "r") 
      {
        versionRevision = versionRevision.substring(1);
        if (versionRevision.indexOf("d") > 0) 
        {
          versionRevision = versionRevision.substring(0, versionRevision.indexOf("d"));
        }
      }
      
      var flashVer = versionMajor + "." + versionMinor + "." + versionRevision;
    }
  }
  // MSN/WebTV 2.6 supports Flash 4
  else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.6") != -1)
    flashVer = 4;
  // WebTV 2.5 supports Flash 3
  else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.5") != -1)
    flashVer = 3;
  // older WebTV supports Flash 2
  else if (navigator.userAgent.toLowerCase().indexOf("webtv") != -1) 
    flashVer = 2;
  else if (isIEForFlashCode && isWinForFlashCode && !isOperaForFlashCode) 
  {
    flashVer = ControlVersion();
  } 
  
  return flashVer;
}

// When called with reqMajorVer, reqMinorVer, reqRevision returns true if that version or greater is available
function DetectFlashVer(reqMajorVer, reqMinorVer, reqRevision)
{
  versionStr = GetSwfVer();
  if (versionStr == -1 ) 
  {
    return false;
  }
  else if (versionStr != 0)
  {
    if (isIEForFlashCode && isWinForFlashCode && !isOperaForFlashCode)
    {
      // Given "WIN 2,0,0,11"
      tempArray         = versionStr.split(" ");  // ["WIN", "2,0,0,11"]
      tempString        = tempArray[1];     // "2,0,0,11"
      versionArray      = tempString.split(",");  // ['2', '0', '0', '11']
    }
    else
    {
      versionArray      = versionStr.split(".");
    }
    
    var versionMajor      = versionArray[0];
    var versionMinor      = versionArray[1];
    var versionRevision   = versionArray[2];

    // is the major.revision >= requested major.revision AND the minor version >= requested minor
    if (versionMajor > parseFloat(reqMajorVer))
    {
      return true;
    }
    else if (versionMajor == parseFloat(reqMajorVer)) 
    {
      if (versionMinor > parseFloat(reqMinorVer))
        return true;
      else if (versionMinor == parseFloat(reqMinorVer)) 
      {
        if (versionRevision >= parseFloat(reqRevision))
          return true;
      }
    }
    
    return false;
  }
}

function AC_Generateobj(objAttrs, params, embedAttrs) 
{ 
    var str = '';
    if (isIEForFlashCode && isWinForFlashCode && !isOperaForFlashCode)
    {
      str += '<object ';
      for (var i in objAttrs)
      {
        //alert('objAttrs : ' + i + ' = ' + objAttrs[i]);
        str += i + '="' + objAttrs[i] + '" ';
      }
      str += '>';
      for (var i in params)
      {
        //alert('params : ' + i + ' = ' + params[i]);
        str += '<param name="' + i + '" value="' + params[i] + '" /> ';
      }
      str += '</object>';
    } 
    else 
    {
      str += '<embed ';
      for (var i in embedAttrs)
      {
        //alert('embedAttrs : ' + i + ' = ' + embedAttrs[i]);
        str += i + '="' + embedAttrs[i] + '" ';
      }
      str += '> </embed>';
    }

    return (str);
}

function AC_GetArgs(args)
{
  var srcParamName = "movie";
  var classid = "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000";
  var mimeType = "application/x-shockwave-flash";
  
  var ret = new Object();
  ret.embedAttrs = new Object();
  ret.params = new Object();
  ret.objAttrs = new Object();
  for (var i=0; i < args.length; i=i+2)
  {
    var currArg = args[i].toLowerCase();    

    switch (currArg)
    { 
      case "classid":
        break;
        
      case "pluginspage":
        ret.embedAttrs[args[i]] = args[i+1];
        break;
        
      case "src":
      case "movie": 
        ret.embedAttrs["src"] = args[i+1];
        ret.params[srcParamName] = args[i+1];
        break;
        
      case "onafterupdate":
      case "onbeforeupdate":
      case "onblur":
      case "oncellchange":
      case "onclick":
      case "ondblClick":
      case "ondrag":
      case "ondragend":
      case "ondragenter":
      case "ondragleave":
      case "ondragover":
      case "ondrop":
      case "onfinish":
      case "onfocus":
      case "onhelp":
      case "onmousedown":
      case "onmouseup":
      case "onmouseover":
      case "onmousemove":
      case "onmouseout":
      case "onkeypress":
      case "onkeydown":
      case "onkeyup":
      case "onload":
      case "onlosecapture":
      case "onpropertychange":
      case "onreadystatechange":
      case "onrowsdelete":
      case "onrowenter":
      case "onrowexit":
      case "onrowsinserted":
      case "onstart":
      case "onscroll":
      case "onbeforeeditfocus":
      case "onactivate":
      case "onbeforedeactivate":
      case "ondeactivate":
      case "type":
      case "codebase":
        ret.objAttrs[args[i]] = args[i+1];
        break;
        
      case "id":
      case "width":
      case "height":
      case "align":
      case "vspace": 
      case "hspace":
      case "class":
      case "title":
      case "accesskey":
      case "name":
      case "tabindex":
        ret.embedAttrs[args[i]] = ret.objAttrs[args[i]] = args[i+1];
        break;
        
      default:
        ret.embedAttrs[args[i]] = ret.params[args[i]] = args[i+1];
    }
  }
  
  ret.objAttrs["classid"] = classid;
  if (mimeType)
    ret.embedAttrs["type"] = mimeType;
    
  return (ret);
}

/**
 * Call Clear Cache SMO and Opener URL to Refresh Interface
 * @param strSWFId String : Id associates to the SWF
 */
function callEasyvistaClearCacheAndRefreshInterface(strSWFId)
{
  if (window.opener != null)
  {
    var strInterfaceUrl = window.opener.location.href.replace("#", "");
    strInterfaceUrl = delete_param_url(strInterfaceUrl, "ClearCache");
    strInterfaceUrl += "&ClearCache=yes";
    
    if (bDebugMode)
      strInterfaceUrl += '&' + sDebugSyntax; 
      
    window.opener.location.href = strInterfaceUrl;
  }
}

/**
 * JavaScript Code to close Window
 * @param strSWFId String : Id associates to the SWF
 */
function closeWindowJS(strSWFId)
{
  window.close();
}

// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/ajax.js $
// Revision: 12264 $

// -- gestion des caractères dont le code est > à 255
function conversionUnicode(s) 
{
  if (s == null)
    return ('');
    
  retour = s.replace(/(\w|\W)/g,
      function(s, n) 
      {
        c = n.charCodeAt(0);
        if (c <= 255)
        return (n);
        
        return ('&#' + c + ';');
      }
    );
  
  return (retour);
}


// -- Fonction d'échappement des caractères en javascript
function escape_ezv(str)
{
  //str = conversionUnicode(str);
  //str = escape(str);
  str = encodeURIComponent(str);
  
  /*while (str.indexOf("+") != -1)
  {
    str = str.replace("+", "%2B");
  }*/

  return (str);
}

// -- Extraction du javascript dans une chaîne
function extract_script(txt) 
{
  // On enlève les espaces entre le < et le nom du tag Script
  var reg1 = new RegExp("(<[ \t]*s)", "g");
  var reg2 = new RegExp("(<[ \t]*S)", "g");
  var reg3 = new RegExp("(</[ \t]*s)", "g");
  var reg4 = new RegExp("(</[ \t]*S)", "g");
  txt = txt.replace(reg1, "<s");
  txt = txt.replace(reg2, "<S");
  txt = txt.replace(reg3, "</s");
  txt = txt.replace(reg4, "</S");
  
  var txt_lower = txt.toLowerCase();
  var pos1;
  var pos2;
  var pos3;
  var current_pos = 0;
  
  var result_js = "";
  var result_txt = "";
  
  // position de la balise "<script"
  pos1 = txt_lower.indexOf("<script", current_pos);
  
  // On récupère le texte valide
  if (pos1 == -1)
  result_txt += txt.substr(current_pos, txt.length - current_pos);
  else
  result_txt += txt.substr(current_pos, pos1 - current_pos);
  
  while (pos1 > -1)
  {
    // position de la balise "</script"
    pos2 = txt_lower.indexOf("</script", current_pos);
    
    // récupération du texte
    tmp = txt.substr(pos1, pos2 - pos1);
    pos3 = tmp.indexOf(">", 0);
    tmp = tmp.substr(pos3 + 1, tmp.length - pos3 - 1);
    alert(tmp);
    result_js += tmp;
    
    // position servant au début de la recherche
    current_pos = txt_lower.indexOf(">", pos2) + 1;
    
    // position de la balise "<script"
    pos1 = txt_lower.indexOf("<script", current_pos);
    
    // On récupère le texte valide
    if (pos1 == -1)
    result_txt += txt.substr(current_pos, txt.length - current_pos);
    else
    result_txt += txt.substr(current_pos, pos1 - current_pos);
  }
  
  result = new Array(result_txt, result_js);
  return (result);
}

// ------------------------------------- Déclenchement d'un évènement ---------------------------------------
function fireEvent2(eventName, target, fct) 
{
  if (document.getElementById(target).fireEvent)
  {
    // Create event
    eval("document.getElementById(\'" + target + "\').on" + eventName + " = " + fct + ";");
    // Call Event
    document.getElementById(target).fireEvent("on" + eventName);
  }
  else
  {
    // Create event
    eventName = "my" + eventName;
    eval("document.getElementById(\'" + target + "\').addEventListener(\'" + eventName + "\', " + fct + ", false);"); 
	  //document.getElementById(target).addEventListener(eventName, foobar, false);
    
    // Call Event
    // - create a generic event 
	  var evt = document.createEvent("Events")
	  // - initialize it to be the event we want
	  evt.initEvent(eventName, true, true); //true for can bubble, true for cancelable
	  // - call
	  document.getElementById(target).dispatchEvent(evt);
  }
}

// ------------------------------------- Les paramètres -------------------------------------
// file_name : nom du fichier a exécuter (URL)
// form_name : nom du formulaire à récupérer
// method : méthode pour transmettre le formulaire (GET ou POST)
// div_id : ID du div à remplacer
// not_initialize : Fonction javascript a exécuter si on n'arrive pas à initialiser le composant XMLHttpRequest
// eval_js : code javascript à exécuter une fois le traitement terminé

// ------------------------------------- Les Fonctions -------------------------------------
// ------------------ Retour ResponseText ------------------
// --- Méthode Asynchrone ---
// Récupération de formulaire : 
// - formulaire_ajax_eval : exécution d'un javascript en retour
// - formulaire_ajax_div : remplacement du contenu d'un div en retour
// - formulaire_ajax : Transfert simple d'un formulaire (on ne s'occupe pas du retour)
//
// Appel simple à un fichier : 
// - url_ajax_eval : exécution d'un javascript en retour
// - url_ajax_div : remplacement du contenu d'un div en retour
// - url_ajax_div_eval : remplacement du contenu d'un div en retour avec extraction de code JS pour évaluation
// - url_ajax : Appel simple (on ne s'occupe pas du retour)
//
// Récupération de formulaire puis exécution d'un code javascript en fin de traitement : 
// - formulaire_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - formulaire_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - formulaire_ajax_js : Transfert simple d'un formulaire (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel simple à un fichier puis exécution d'un code javascript en fin de traitement : 
// - url_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - url_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - url_ajax_js : Appel simple (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Récupération du javascript retourné
// - url_ajax_get_js : Appel d'un fichier et récupération du javascript retourné
// - formulaire_ajax_get : Appel d'un fichier en postant un formulaire (méthode POST ou GET) et récupération du javascript retourné

// --- Méthode Synchrone ---
// Récupération de formulaire : 
// - sync_formulaire_ajax_eval : exécution d'un javascript en retour
// - sync_formulaire_ajax_div : remplacement du contenu d'un div en retour
// - sync_formulaire_ajax : Transfert simple d'un formulaire (on ne s'occupe pas du retour)
//
// Appel simple à un fichier : 
// - sync_url_ajax_eval : exécution d'un javascript en retour
// - sync_url_ajax_div : remplacement du contenu d'un div en retour
// - sync_url_ajax : Appel simple (on ne s'occupe pas du retour)
//
// Récupération de formulaire puis exécution d'un code javascript en fin de traitement : 
// - sync_formulaire_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - sync_formulaire_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - sync_formulaire_ajax_js : Transfert simple d'un formulaire (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel simple à un fichier puis exécution d'un code javascript en fin de traitement : 
// - sync_url_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - sync_url_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - sync_url_ajax_js : Appel simple (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel à un fichier puis récupération du résultat
// - sync_formulaire_ajax_get : Appel avec un formulaire
// - sync_url_ajax_get : Appel simple

// ------------------ Retour responseXML ------------------
// --- Méthode Asynchrone ---
// Récupération de formulaire : 
// - xml_formulaire_ajax_eval : exécution d'un javascript en retour
// - xml_formulaire_ajax_div : remplacement du contenu d'un div en retour
// - xml_formulaire_ajax : Transfert simple d'un formulaire (on ne s'occupe pas du retour)
//
// Appel simple à un fichier : 
// - xml_url_ajax_eval : exécution d'un javascript en retour
// - xml_url_ajax_div : remplacement du contenu d'un div en retour
// - xml_url_ajax : Appel simple (on ne s'occupe pas du retour)
//
// Récupération de formulaire puis exécution d'un code javascript en fin de traitement : 
// - xml_formulaire_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - xml_formulaire_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - xml_formulaire_ajax_js : Transfert simple d'un formulaire (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel simple à un fichier puis exécution d'un code javascript en fin de traitement : 
// - xml_url_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - xml_url_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - xml_url_ajax_js : Appel simple (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement

// --- Méthode Synchrone ---
// Récupération de formulaire : 
// - xml_sync_formulaire_ajax_eval : exécution d'un javascript en retour
// - xml_sync_formulaire_ajax_div : remplacement du contenu d'un div en retour
// - xml_sync_formulaire_ajax : Transfert simple d'un formulaire (on ne s'occupe pas du retour)
//
// Appel simple à un fichier : 
// - xml_sync_url_ajax_eval : exécution d'un javascript en retour
// - xml_sync_url_ajax_div : remplacement du contenu d'un div en retour
// - xml_sync_url_ajax : Appel simple (on ne s'occupe pas du retour)
//
// Récupération de formulaire puis exécution d'un code javascript en fin de traitement : 
// - xml_sync_formulaire_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - xml_sync_formulaire_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - xml_sync_formulaire_ajax_js : Transfert simple d'un formulaire (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel simple à un fichier puis exécution d'un code javascript en fin de traitement : 
// - xml_sync_url_ajax_eval_js : exécution d'un javascript en retour + exécution d'un code javascript en fin de traitement
// - xml_sync_url_ajax_div_js : remplacement du contenu d'un div en retour + exécution d'un code javascript en fin de traitement
// - xml_sync_url_ajax_js : Appel simple (on ne s'occupe pas du retour) + exécution d'un code javascript en fin de traitement
//
// Appel à un fichier puis récupération du résultat
// - xml_sync_formulaire_ajax_get : Appel avec un formulaire
// - xml_sync_url_ajax_get : Appel simple

// ----------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------
// ---------------------------------------- Retour ResponseText ----------------------------------------
// ----------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------------
// ---------------------------------------- Méthode Asynchrone ----------------------------------------
// ----------------------------------------------------------------------------------------------------

// ---------------------------------- Récupération du javascript retourné -----------------------------

// -- Appel d'un fichier et récupération du javascript retourné
function url_ajax_get_js(file_name, gl_var_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
      {
        eval(gl_var_js + "= xhr_object.responseText"); 
      }
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et récupération du javascript retourné
function formulaire_ajax_get(file_name, gl_var_js, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
        eval(gl_var_js + "= xhr_object.responseText"); 
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ------------------------------------ Formulaire ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné
function formulaire_ajax_eval(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
        eval(xhr_object.responseText); 
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat
function formulaire_ajax_div(file_name, form_name, method, div_id, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseText; 
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET)
function formulaire_ajax(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ------------------------------------ URL ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné
function url_ajax_eval(file_name, not_initialize)
{
  if (file_name == "")
  return (false);

  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
      {
        eval(xhr_object.responseText); 
      }
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat
function url_ajax_div(file_name, div_id, not_initialize)
{
  if (file_name == "" || div_id == "" || document.getElementById(div_id) == null)
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
      document.getElementById(div_id).innerHTML = xhr_object.responseText;
  }
  xhr_object.send(null);
  
  return (true);
}

/**
 * Appel d'un fichier et remplacement du contenu d'un div par son résultat 
 * après extraction du code JS contenu dans le résultat
 */
function url_ajax_div_eval(file_name, div_id, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      var regexStart = /[<][ ]*script[ >]/mi;
      var regexEnd = /[<]\/[ ]*script[ ]*[>]/mi;
      var sHTML = xhr_object.responseText;
      var sAllJs = ''; 
        
      while ((iPosStart = sHTML.search(regexStart)) > -1)
      {
        // Extraction du début du code JS
        sEndHTML = sHTML.substr(iPosStart);
        
        // Récupération du début de la sHTML (avant le code JS)
        sHTML = sHTML.substr(0, iPosStart);
        
        // Récupération de la position de la fin du script
        iPosEnd = sEndHTML.search(regexEnd);
        
        // Extraction de la totalite du code JS
        sJS = sEndHTML.substr(0, iPosEnd);
        
        // Suppression de la balise de début script
        sJS = sJS.substr(sJS.indexOf('>') + 1);

        // Suppression du code JS de la sHTML
        sEndHTML = sEndHTML.substr(iPosEnd);
        
        // Suppression de la balise de fin script
        sHTML += sEndHTML.replace(regexEnd, '');
        
        // Stockage du JS
        sAllJs += sJS;
      }
    
      // Application du code HTML
      document.getElementById(div_id).innerHTML = sHTML;
      // Exécution du code JS
      if (sAllJs != '')
        eval(sAllJs);
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier
function url_ajax(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ URL + JS ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné puis exécute un code javascript
function url_ajax_eval_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
      {
        eval(xhr_object.responseText); 
        eval(eval_js); 
      }
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function url_ajax_div_js(file_name, div_id, eval_js, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseText;
      eval(eval_js);
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier puis exécute un code javascript
function url_ajax_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      eval(eval_js);
    }
  }
  
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ Formulaire + JS ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné puis exécute un code javascript
function formulaire_ajax_eval_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      if (xhr_object.responseText && xhr_object.responseText != "")
      {
        eval(xhr_object.responseText); 
        eval(eval_js);
      }
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function formulaire_ajax_div_js(file_name, form_name, method, div_id, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseText;
      eval(eval_js);
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) puis exécute un code javascript
function formulaire_ajax_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      eval(eval_js);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ---------------------------------------------------------------------------------------------------
// ---------------------------------------- Méthode Synchrone ---------------------------------------
// ---------------------------------------------------------------------------------------------------

// ------------------------------------ Formulaire ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné
function sync_formulaire_ajax_eval(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  // Indique la valeur retournée par la fonction 
  // => comme il s'agit d'une fonction synchrone, cette valeur peut être surchargée via le Javascript évalué en retour de l'appel
  var AjaxResult = true;
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    eval(xhr_object.responseText); 
  
  return (AjaxResult);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat
function sync_formulaire_ajax_div(file_name, form_name, method, div_id, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  document.getElementById(div_id).innerHTML = xhr_object.responseText;
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET)
function sync_formulaire_ajax(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ------------------------------------ URL ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné
function sync_url_ajax_eval(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  // Indique la valeur retournée par la fonction 
  // => comme il s'agit d'une fonction synchrone, cette valeur peut être surchargée via le Javascript évalué en retour de l'appel
  var AjaxResult = true;
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    eval(xhr_object.responseText); 

  return (AjaxResult);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat
function sync_url_ajax_div(file_name, div_id, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  document.getElementById(div_id).innerHTML = xhr_object.responseText;
  
  return (true);
}

// -- Appel d'un fichier
function sync_url_ajax(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ URL + JS ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné puis exécute un code javascript
function sync_url_ajax_eval_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);

  // Indique la valeur retournée par la fonction 
  // => comme il s'agit d'une fonction synchrone, cette valeur peut être surchargée via le Javascript évalué en retour de l'appel
  var AjaxResult = true;
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    eval(xhr_object.responseText); 

  eval(eval_js);
  
  return (AjaxResult);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function sync_url_ajax_div_js(file_name, div_id, eval_js, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  document.getElementById(div_id).innerHTML = xhr_object.responseText;
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier puis exécute un code javascript
function sync_url_ajax_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  eval(eval_js);
  
  return (true);
}

// ------------------------------------ Formulaire + JS ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné puis exécute un code javascript
function sync_formulaire_ajax_eval_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  // Indique la valeur retournée par la fonction 
  // => comme il s'agit d'une fonction synchrone, cette valeur peut être surchargée via le Javascript évalué en retour de l'appel
  var AjaxResult = true;
  
  if (xhr_object.responseText && xhr_object.responseText != "")
    eval(xhr_object.responseText); 
  
  eval(eval_js);
  
  return (AjaxResult);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function sync_formulaire_ajax_div_js(file_name, form_name, method, div_id, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  document.getElementById(div_id).innerHTML = xhr_object.responseText; 
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) puis exécute un code javascript
function sync_formulaire_ajax_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et retourne le résultat
function sync_formulaire_ajax_get(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
  return (xhr_object.responseText); 
  else
  return ("");
}

// -- Appel d'un fichier et retourne le résultat
function sync_url_ajax_get(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  if (xhr_object.responseText && xhr_object.responseText != "")
  return (xhr_object.responseText); 
  else
  return ("");
}

// ----------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------
// ---------------------------------------- Retour responseXML ----------------------------------------
// ----------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------------
// ---------------------------------------- Méthode Asynchrone ----------------------------------------
// ----------------------------------------------------------------------------------------------------

// ------------------------------------ Formulaire ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné
function xml_formulaire_ajax_eval(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      if (xhr_object.responseXML != null)
        eval(xhr_object.responseXML); 
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat
function xml_formulaire_ajax_div(file_name, form_name, method, div_id, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseXML; 
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET)
function xml_formulaire_ajax(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ------------------------------------ URL ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné
function xml_url_ajax_eval(file_name, not_initialize)
{
  if (file_name == "")
  return (false);

  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      if (xhr_object.responseXML != null)
      {
        eval(xhr_object.responseXML); 
      }
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat
function xml_url_ajax_div(file_name, div_id, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
      document.getElementById(div_id).innerHTML = xhr_object.responseXML;
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier
function xml_url_ajax(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ URL + JS ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné puis exécute un code javascript
function xml_url_ajax_eval_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      if (xhr_object.responseXML != null)
      {
        eval(xhr_object.responseXML); 
        eval(eval_js); 
      }
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function xml_url_ajax_div_js(file_name, div_id, eval_js, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseXML;
      eval(eval_js);
    }
  }
  xhr_object.send(null);
  
  return (true);
}

// -- Appel d'un fichier puis exécute un code javascript
function xml_url_ajax_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if (xhr_object.readyState == 4)
    {
      eval(eval_js);
    }
  }
  
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ Formulaire + JS ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné puis exécute un code javascript
function xml_formulaire_ajax_eval_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      if (xhr_object.responseXML != null)
      {
        eval(xhr_object.responseXML); 
        eval(eval_js);
      }
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function xml_formulaire_ajax_div_js(file_name, form_name, method, div_id, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      document.getElementById(div_id).innerHTML = xhr_object.responseXML; 
      eval(eval_js);
    }
  } 
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) puis exécute un code javascript
function xml_formulaire_ajax_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.onreadystatechange = function() 
  { 
    if (xhr_object.readyState == 4) 
    {
      eval(eval_js);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, true); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, true); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ---------------------------------------------------------------------------------------------------
// ---------------------------------------- Méthode Synchrone ---------------------------------------
// ---------------------------------------------------------------------------------------------------

// ------------------------------------ Formulaire ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné
function xml_sync_formulaire_ajax_eval(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  if (xhr_object.responseXML != null)
  eval(xhr_object.responseXML); 
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat
function xml_sync_formulaire_ajax_div(file_name, form_name, method, div_id, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  document.getElementById(div_id).innerHTML = xhr_object.responseXML;
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET)
function xml_sync_formulaire_ajax(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  return (true);
}

// ------------------------------------ URL ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné
function xml_sync_url_ajax_eval(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  if (xhr_object.responseXML != null)
  eval(xhr_object.responseXML); 

  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat
function xml_sync_url_ajax_div(file_name, div_id, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  document.getElementById(div_id).innerHTML = xhr_object.responseXML;
  
  return (true);
}

// -- Appel d'un fichier
function xml_sync_url_ajax(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  return (true);
}

// ------------------------------------ URL + JS ------------------------------------

// -- Appel d'un fichier et exécution du javascript retourné puis exécute un code javascript
function xml_sync_url_ajax_eval_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);

  if (xhr_object.responseXML != null)
  eval(xhr_object.responseXML); 

  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function xml_sync_url_ajax_div_js(file_name, div_id, eval_js, not_initialize)
{
  if (file_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  document.getElementById(div_id).innerHTML = xhr_object.responseXML;
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier puis exécute un code javascript
function xml_sync_url_ajax_js(file_name, eval_js, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  eval(eval_js);
  
  return (true);
}

// ------------------------------------ Formulaire + JS ------------------------------------

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et exécution du javascript retourné puis exécute un code javascript
function xml_sync_formulaire_ajax_eval_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  if (xhr_object.responseXML != null)
  eval(xhr_object.responseXML); 
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et remplacement du contenu d'un div par son résultat puis exécute un code javascript
function xml_sync_formulaire_ajax_div_js(file_name, form_name, method, div_id, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "" || div_id == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  document.getElementById(div_id).innerHTML = xhr_object.responseXML; 
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) puis exécute un code javascript
function xml_sync_formulaire_ajax_js(file_name, form_name, method, eval_js, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  eval(eval_js);
  
  return (true);
}

// -- Appel d'un fichier en postant un formulaire (méthode POST ou GET) et retourne le résultat
function xml_sync_formulaire_ajax_get(file_name, form_name, method, not_initialize)
{
  if (file_name == "" || form_name == "")
  return (false);
  
  // remplacement de la racine pour améliorer les performances
  file_name = translateUrl(file_name);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  var data = "";
  
  if (typeof(form_name) != "object")
  arr_data = document.forms[form_name].elements;
  else
  {
    arr_data = new Array();
    for (i = 0; i < form_name.length; i++)
    {
      arr_data.push(document.getElementById(form_name[i]));
    }
  }
  
  for (i = 0; i < arr_data.length; i++)
  {
    if (data != "")
    data += "&";
    
    if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
    editor_id = tinyMCE.get(arr_data[i].name);
    else
    editor_id = null;
    
    if (editor_id != null)
    {
      tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
      tmp_value = tinyMCE.getInstanceById(arr_data[i].name).getContent();
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(tmp_value);
    }
    else
    {
      if (arr_data[i].type == "radio" || arr_data[i].type == "checkbox")
      {
        if (arr_data[i].checked == true)
        data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
      }
      else
      data += escape_ezv(arr_data[i].name) + "=" + escape_ezv(arr_data[i].value);
    }
  }
  
  if (method.toUpperCase() != "POST")
  {
    xhr_object.open("GET", file_name + "?" + data, false); 
    data = null;
  }
  else
  {
    xhr_object.open("POST", file_name, false); 
  }
  
  xhr_object.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); 
  xhr_object.send(data);
  
  if (xhr_object.responseXML && xhr_object.responseXML != "")
  return (xhr_object.responseXML); 
  else
  return ("");
}

// -- Appel d'un fichier et retourne le résultat
function xml_sync_url_ajax_get(file_name, not_initialize)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    if (not_initialize != "")
      eval(not_initialize);
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  if (xhr_object.responseXML && xhr_object.responseXML != "")
  return (xhr_object.responseXML); 
  else
  return ("");
}


// -- Appel d'un fichier et retourne le résultat d'une seule valeur
function xml_sync_url_ajax_value_get(file_name, js)
{
  if (file_name == "")
  return (false);
  
  var xhr_object = null;   
  if (window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if (window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, false);
  xhr_object.send(null);
  
  if (js != '') {
    eval(js) ;
    return (true) ;
  } else {
    return (xhr_object.responseXML.text); 
  }
}


// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/autoresize.js $
// Revision: 12439 $

// On ferme la fenêtre
function NoErrorResize()
{
	return (true);
}

function WindowResizeTo_ResizeWindowFromTable(width_to, height_to, name, width_diff, height_diff)
{
  if (document.getElementById(name) != null)
  {
    WindowResizeTo(width_to, height_to);
    ResizeWindowFromTable(name, width_diff, height_diff);
  }
}

function ResizeWindowFromTable(name, width_diff, height_diff)
{
  ResizeWindowFromTableWithMinValues(name, width_diff, height_diff, 0, 0);
}
  
function ResizeWindowFromTableWithMinValues(name, width_diff, height_diff, minWidth, minHeight)
{
  window.oldOnError = window.onerror;
  window.onerror = NoErrorResize;
  
  if (width_diff == 0)
  width_diff = 16;
  
  if (height_diff == 0)
  height_diff = 2;
  
  if (width_diff < 0)
  width_diff = 0;
  
  if (height_diff < 0)
  height_diff = 0;
  
  
  var Table = null;
  if (document.getElementById)
  {
    if (document.getElementById(name))
    Table = document.getElementById(name);
  }
  else if (document.all)
  {
    if (document.all[name])
    Table = document.all[name];
  }
  
  if (Table)
  {
    if (isGecko)
    {
      iWidth = Table.clientWidth + width_diff + 20;
      iHeight = Table.clientHeight + height_diff + 100;

      screen_width = screen.width - 20;
      screen_height = screen.height - 100;

      if (iWidth > screen_width)
      iHeight += 50;
      
      if (iHeight > screen_height)
      iWidth += 20;
      
      if (iWidth > screen_width)
      iWidth = screen_width;
      
      if (iHeight > screen_height)
      iHeight = screen_height;
      
      if (!isNaN(minWidth) && iWidth < minWidth)
        iWidth = minWidth;
      if (!isNaN(minHeight) && iHeight < minHeight)
        iHeight = minHeight;
      window.resizeTo(iWidth, iHeight);
      
      pageX = window.screenX;
      pageY = window.screenY;
      
      if (pageX + iWidth > screen_width)
      moveX = screen_width - iWidth;
      else
      moveX = pageX;
      
      if (pageY + iHeight > screen_height)
      moveY = screen_height - iHeight;
      else
      moveY = pageY;
      
      window.moveTo(moveX, moveY);
    }
    else if (isIE)
    {
      iWidth = Table.offsetWidth + width_diff + 20;
      iHeight = Table.offsetHeight + height_diff + 100;

      screen_width = screen.width - 20;
      screen_height = screen.height - 100;

      if (iWidth > screen_width)
      iHeight += 50;
      
      if (iHeight > screen_height)
      iWidth += 20;
      
      if (iWidth > screen_width)
      iWidth = screen_width;
      
      if (iHeight > screen_height)
      iHeight = screen_height;
      
      if (!isNaN(minWidth) && iWidth < minWidth)
        iWidth = minWidth;
      if (!isNaN(minHeight) && iHeight < minHeight)
        iHeight = minHeight;
      window.resizeTo(iWidth, iHeight);
      
      pageX = window.screenLeft - 4;
      pageY = window.screenTop - 30;
      
      if (pageX < 0)
      pageX = 0;
      
      if (pageY < 0)
      pageY = 0;
      
      if (pageX + iWidth > screen_width)
      moveX = screen_width - iWidth;
      else
      moveX = pageX;
      
      if (pageY + iHeight > screen_height)
      moveY = screen_height - iHeight;
      else
      moveY = pageY;
      
      window.moveTo(moveX, moveY);
    }
    else if (isOpera || isSafari)
    {
      iWidth = Table.offsetWidth + width_diff + 20;
      iHeight = Table.offsetHeight + height_diff + 100;

      screen_width = screen.width - 20;
      screen_height = screen.height - 100;

      if (iWidth > screen_width)
      iHeight += 50;
      
      if (iHeight > screen_height)
      iWidth += 20;
      
      if (iWidth > screen_width)
      iWidth = screen_width;
      
      if (iHeight > screen_height)
      iHeight = screen_height;
      
      if (!isNaN(minWidth) && iWidth < minWidth)
        iWidth = minWidth;
      if (!isNaN(minHeight) && iHeight < minHeight)
        iHeight = minHeight;
      window.resizeTo(iWidth, iHeight);
      
      pageX = window.screenX;
      pageY = window.screenY;
      
      if (pageX + iWidth > screen_width)
      moveX = screen_width - iWidth;
      else
      moveX = pageX;
      
      if (pageY + iHeight > screen_height)
      moveY = screen_height - iHeight;
      else
      moveY = pageY;
      
      window.moveTo(moveX, moveY);
    }
    else
    {
      iWidth = Table.offsetWidth + width_diff + 20;
      iHeight = Table.offsetHeight + height_diff + 100;

      screen_width = screen.width - 20;
      screen_height = screen.height - 100;

      if (iWidth > screen_width)
      iHeight += 50;
      
      if (iHeight > screen_height)
      iWidth += 20;
      
      if (iWidth > screen_width)
      iWidth = screen_width;
      
      if (iHeight > screen_height)
      iHeight = screen_height;
      
      if (!isNaN(minWidth) && iWidth < minWidth)
        iWidth = minWidth;
      if (!isNaN(minHeight) && iHeight < minHeight)
        iHeight = minHeight;
      window.resizeTo(iWidth, iHeight);
      
      pageX = window.screenLeft - 4;
      pageY = window.screenTop - 30;
      
      if (pageX < 0)
      pageX = 0;
      
      if (pageY < 0)
      pageY = 0;
      
      if (pageX + iWidth > screen_width)
      moveX = screen_width - iWidth;
      else
      moveX = pageX;
      
      if (pageY + iHeight > screen_height)
      moveY = screen_height - iHeight;
      else
      moveY = pageY;
      
      window.moveTo(moveX, moveY);
    }
  }
  
  window.onerror = window.oldOnError;
}

function WindowMoveTo(x, y)
{
  window.oldOnError = window.onerror;
  window.onerror = NoErrorResize;
  
  var NS = (navigator.appName=="Netscape")?true:false;
  iWidth = (NS)?window.innerWidth:document.body.clientWidth;
  iHeight = (NS)?window.innerHeight:document.body.clientHeight;
  
  if (x < 0)
  x = -x;
  
  if (y < 0)
  y = -y;
  
  if (iWidth + x > screen.width - 20)
  {
    x = screen.width - 20 - iWidth;
    if (x < 0)
    x = 0;
  }
  
  if (iHeight + y > screen.height - 20)
  {
    y = screen.height - 20 - iHeight;
    if (y < 0)
    y = 0;
  }
  window.moveTo(x, y);
  
  window.onerror = window.oldOnError;
}

function WindowResizeTo(x, y)
{
  window.oldOnError = window.onerror;
  window.onerror = NoErrorResize;
  
  if (x < 0)
  x = -x;
  
  if (y < 0)
  y = -y;
  
  if (x > screen.width - 20)
  x = screen.width - 20;
  
  if (y > screen.height - 20)
  y = screen.height - 20;
  
  window.resizeTo(x, y);
  
  window.onerror = window.oldOnError;
}

function maximise_window()
{
  window.oldOnError = window.onerror;
  window.onerror = NoErrorResize;
  
  
  window.moveTo(0, 0);
  window.resizeTo(screen.availWidth, screen.availHeight);
  
  window.onerror = window.oldOnError;
}

function getCurrentWindowHeight()
{
  var NS = (navigator.appName=="Netscape")?true:false;
  if (NS && navigator.appCodeName == 'Mozilla')
  {
    NS = false;
    Mozilla = true;
  }
  else
  Mozilla = false;
  
  return ((NS)?window.innerHeight:document.body.clientHeight);
}

function getCurrentWindowWidth()
{
  var NS = (navigator.appName=="Netscape")?true:false;
  if (NS && navigator.appCodeName == 'Mozilla')
  {
    NS = false;
    Mozilla = true;
  }
  else
  Mozilla = false;
  
  return ((NS)?window.innerWidth:document.body.clientWidth);
}

// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/Studio/Studio.js $
// Revision: 14134 $

// -- récupération de libellés
function studio_get_label(str)
{
  var result = str.replace("_", " ");
  
  var xhr_object = null;   
  if(window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if(window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return (result);
  } 
  
  filename = get_main_directory();
  filename += 'Studio/Studio_js.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&str=' + str;
  
  // Mode synchrone
  xhr_object.open("GET", filename, false);
  xhr_object.send(null);
  if (xhr_object.responseText != "")
  {
    result = xhr_object.responseText;
  }
  
  return (result);
}


function confirm_delete_query( AlocationWindow )
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_QUERY'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}


function confirm_delete_theme( AlocationWindow )
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_THEME'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}

function confirm_delete_block( AlocationWindow )
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_BLOCK'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}

function delete_all_messages(AlocationWindow)
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_ALL_MESS'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}


function confirm_delete_menu( AlocationWindow )
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_MENU'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}

function confirm_delete_profil( AlocationWindow )
{
  var confirm_del = window.confirm(studio_get_label('MESS_DEL_PROFIL'));
  if (confirm_del) 
  {
     window.location = AlocationWindow ;
  }
}

function guid_click(sess, guid, name, table, field, index, filter){

  window.open("Studio/S_GUID.php?" + sess + "&guid=" + guid + "&name=" + name + "&table=" + table + "&field=" + field +
              "&index=" + index + "&filter=" + filter, "GUID", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=300,height=400,top=50,left=250") ;

}

function fieldlookup_click(sess,Astrname){

  window.open("Studio/S_Fieldlookup.php?" + sess + "&strname=" + Astrname, "Lookupfield", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=300,height=400,top=50,left=250") ;

}


function blocklookup_click(sess,Astrname){
  window.open("Studio/S_BlockLookup.php?" + sess + "&strname=" + Astrname, "Lookupfield", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=300,height=400,top=50,left=250") ;

}

function querylookup_click(sess,Astrname){
  window.open("Studio/S_QueryLookup.php?" + sess + "&strname=" + Astrname, "Lookupfield", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=300,height=400,top=50,left=250") ;

}


function imagelookup_click(sess,Astrname){
  window.open("Studio/S_ImageLookup.php?" + sess + "&strname=" + Astrname, "Lookupfield", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=300,height=400,top=50,left=250") ;

}



function wherefieldlookup_click(sess,Astrname){

  window.open("Studio/S_Where_Fieldlookup.php?" + sess + "&strname=" + Astrname, "Lookupfield", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=500,height=150,top=50,left=250") ;
}



function ok_click(Aid){
  window.opener.document.getElementById(Aid).value = document.fieldlookup.fieldlook.options[document.fieldlookup.fieldlook.selectedIndex].value ;
  window.close() ;
}

function cancel_click(){
  window.close() ;
}


function NumericControl(AID)
{
	vinputvalue = document.getElementById(AID);
	str = vinputvalue.value ;
	i   = str.length ;
	if (isNaN(str)){
		vinputvalue.value = str.substring(0, i-1);
	}
}

function SendSubmit(aaction)
{
	document.query_studio.action = document.query_studio.action + aaction ;
	document.query_studio.submit();
  return (false);
}

function listnodechange(){
  window.location = document.studio.listobject.options[document.studio.listobject.selectedIndex].value ;
}


function showhide_pagecontrol( APCShow, APCHide, AIsEvent){
	document.getElementById(APCShow).style.visibility = "visible" ;
	document.getElementById(APCHide).style.visibility = "hidden" ;
	if (AIsEvent) {
		document.getElementById(APCShow).style.height     = document.getElementById(APCHide).style.height ;
		document.getElementById(APCShow).style.width      = document.getElementById(APCHide).style.width ;
	}
}

function typejoincliclk(sess,Astrname,Astrvalue,Astrjoin){
  window.open("Studio/S_TypeJoinEditor.php?" + sess + "&strname=" + Astrname + "&strvalue=" + Astrvalue + "&strjoin=" + Astrjoin , "TypeJoin", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=no,resize=no," +
              "copyhistory=no,width=550,height=250,top=50,left=250") ;
}


function changevalue(){
  try{
     document.forms["query_studio"].submit() ;
     return (false);
  }
  catch(e){
     document.forms["sub_query_studio"].submit() ;
     return (false);
  }
}

function save_menu(AlocationWindow)
{
	document.forms["menustudio"].submit() ;
}

function number_control(Ainput) {
	str = Ainput.value ;
	i   = str.length ;
	if (isNaN(str))
		Ainput.value = str.substring(0, i-1);
	return (true);
}

function linked_profil_open(sess,str_class, str_id, displayvalue){  
  window.open("Studio/linked_profiles.php?" + sess + "&str_class="+ str_class + "&str_profilid=" + str_id + "&caption="+ displayvalue, "linkedprofiles", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=275,height=400,top=200,left=250") ;
}


function linked_languages_open(sess,str_class){
	document.editForm.language_var.value = "True" ;
	document.editForm.submit();
  window.open("Studio/linked_languages.php?" + sess + "&str_class="+ str_class , "linkedlanguages", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=no,resize=no," +
              "copyhistory=no,width=400,height=250,top=200,left=250") ;
}



function filter_report_modif(sess,str_class , str_id , filtervalue, reportvalue, helpvalue , displayvalue , quickcallvalue, dashboardvalue, affectationvalue){
  window.open("Studio/linked_report_filter.php?" + sess + "&str_class="+ str_class + "&module_id=" + str_id + "&filtervalue="+ filtervalue + "&reportvalue="+reportvalue + "&helpvalue="+helpvalue + "&displayvalue="+displayvalue+ "&quickcallvalue="+quickcallvalue+ "&dashboardvalue="+dashboardvalue+ "&affectationvalue="+affectationvalue , "linkedlanguages", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=no,resize=no," +
              "copyhistory=no,width=350,height=350,top=200,left=250") ;
}


function actions_open(sess,str_class , theme_id ){
  window.open("Studio/linked_actions.php?" + sess + "&str_class="+ str_class + "&theme_id=" + theme_id  , "linkedactions", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,width=820,height=400,top=200,left=250") ;
}

function metrics_open(sess,str_class , theme_id ){
  window.open("Studio/linked_metrics.php?" + sess + "&str_class="+ str_class + "&theme_id=" + theme_id  , "linkedactions", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=400,height=400,top=200,left=250") ;
}

function visible_blocks_open(sess,str_class , theme_id ){
  window.open("Studio/linked_blocks.php?" + sess + "&str_class="+ str_class + "&theme_id=" + theme_id  , "linkedblocks", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=400,height=400,top=200,left=250") ;
}


function linked_wizard_open(sess,str_class , query_id ,block_id ){
  window.open("linked_wizards.php?" + sess + "&str_class="+ str_class + "&query_id=" + query_id + "&block_id=" + block_id  , "linkedwizards", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=300,height=300,top=200,left=250") ;
}



function linked_filter_open(sess,str_class , query_id  ){
  window.open("linked_filters.php?" + sess + "&str_class="+ str_class + "&query_id=" + query_id  , "linkedfilters", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=300,height=300,top=200,left=250") ;
}


function linked_report_open(sess,str_class , query_id  ){
  window.open("linked_reports.php?" + sess + "&str_class="+ str_class + "&query_id=" + query_id  , "linkedreports", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=300,height=300,top=200,left=250") ;
}



function linked_dialogs_open(sess,str_class , dialog_id , query_id, int_firsttime, str_window_name, int_left, dialog_name){ ;
  window.open("linked_dialogs.php?" + sess + "&str_class="+ str_class + "&dialog_id=" + dialog_id  + "&queryid=" + query_id + "&firsttime=" + int_firsttime + "&dialog_name=" + dialog_name, str_window_name, "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=600,height=300,top=200,left="+ int_left) ;
}

function linked_representations_open(sess,str_class , dialog_id , query_id ){ 
  window.open("linked_representations.php?" + sess + "&str_class="+ str_class + "&dialog_id=" + dialog_id  + "&query_id=" + query_id  , "linkedrepresentation", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=350,height=300,top=200,left=300") ;
}

function linked_dialog_conditions_open(sess,str_class , dialog_id , query_id){ 
  window.open("linked_dialog_conditions.php?" + sess + "&str_class="+ str_class + "&dialog_id=" + dialog_id  + "&queryid=" + query_id , "linkeddialog", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=300,height=300,top=200,left=250") ;
}


function Preview_Overlaoded_Block(sess, q2_dialogId, preview_block_overload_guid){
  window.open("linked_BlockOverloadedPreview.php?" + sess + "&q2_dialogId="+ q2_dialogId + "&preview_block_overload_guid=" + preview_block_overload_guid  + "&q2_id=0"  , "PreviewOverloadedBlock", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=yes," +
              "copyhistory=no,top=100,left=100") ;
}


//=*****************

function hideHintStudio(AcompName){
	window.document.getElementById(AcompName).innerHTML = "" ;
 	window.document.getElementById(AcompName).style.visibility = "hidden";
}

function showhintStudio(AcompName , Avalue){
 	window.document.getElementById(AcompName).innerHTML = "<B>"+Avalue+"</B>" ;
 	window.document.getElementById(AcompName).style.visibility = "visible";
}



function checkbox_click(comp, i_checkboxname , u_checkboxname, wizard_btn, filter_btn, report_btn, section_btn, represent_btn){
	wizard_btn = window.document.getElementById(wizard_btn);
	filter_btn = window.document.getElementById(filter_btn);
	report_btn = window.document.getElementById(report_btn);
	section_btn = window.document.getElementById(section_btn);
	represent_btn = window.document.getElementById(represent_btn);
	if ( comp.checked == true ) {
		if (wizard_btn == "[object]")
	  	wizard_btn.disabled = false ;
		if (filter_btn == "[object]")
	  	filter_btn.disabled = false ;
		if (report_btn == "[object]")
	  	report_btn.disabled = false ;
		if (section_btn == "[object]")
	  	section_btn.disabled = false ;
	  if (represent_btn == "[object]")
	  	represent_btn.disabled = false ;

		window.document.getElementById(i_checkboxname).disabled = false ;
		window.document.getElementById(u_checkboxname).disabled = false ;
	  //window.document.getElementById(i_checkboxname).checked = true ;
	  //window.document.getElementById(u_checkboxname).checked = true ;
	}else{
		if (wizard_btn == "[object]")
			wizard_btn.disabled = true ;
		if (filter_btn == "[object]")
	  	filter_btn.disabled = true ;
		if (report_btn == "[object]")
	  	report_btn.disabled = true ;
		if (section_btn == "[object]")
			section_btn.disabled = true ;
		if (represent_btn == "[object]")
			represent_btn.disabled = true ;

		//window.document.getElementById(i_checkboxname).disabled = true ;
		//window.document.getElementById(u_checkboxname).disabled = true ;
	  //window.document.getElementById(i_checkboxname).checked = false ;
	  //window.document.getElementById(u_checkboxname).checked = false ;
  }
}


function Insert_click(Acomp, Aname, ObjWindow){
	if ( Acomp.checked == true ) {

    ObjUpdateCheckbox = window.document.getElementById(Aname); 
	  ObjUpdateCheckbox.checked = true ;
    if (ObjWindow != null){
      for (i = 0; i < ObjWindow.document.formactionqueries.length; i++) { 
        if( (ObjUpdateCheckbox.src != "") && (ObjWindow.document.formactionqueries[i].src == ObjUpdateCheckbox.src) ){
          ObjWindow.document.formactionqueries[i].checked = ObjUpdateCheckbox.checked;
        }
      }
    }
	}
}

function Update_click(Acomp, Aname){
	if ( window.document.getElementById(Aname).checked == true ) {
	  if ( Acomp.checked == false )
	    Acomp.checked = true ;
	}
}


//=*****************

// -- pour ouvrir la fenetre du studio du planning des Cis
function ci_planning_hint_studio_open(sess, query_guid, element_name){
  window.open("Studio/ci_planning_hint_studio.php?" + sess + "&query_guid="+ query_guid + "&element_name="+ element_name , "ciplanninghints", "toolbar=no,menubar=no," +
              "location=no,directories=no,status=no,scrollbars=yes,resize=no," +
              "copyhistory=no,width=400,height=400,top=200,left=250") ;
}

// -- pour reafficher l'ordre des champs du hint du planning des cis qd coche/décoche un champ
function CiPlanningFieldCheck(field_alias, query_guid) 
{
  if (window.document.getElementById(field_alias).checked)
    action_value = 'checked' ;
  else
    action_value = 'unchecked' ;

  window.document.CiPlanningHintFieldsform.action = window.document.CiPlanningHintFieldsform.action + '&action='+action_value+'&field_alias='+field_alias+'&query_guid='+query_guid ;
  window.document.CiPlanningHintFieldsform.submit();
}

// -- pour reafficher l'ordre des champs du hint du planning des cis qd coche/décoche un champ
function CiPlanningFieldUpDown(field_alias, action_value, query_guid) 
{
  window.document.CiPlanningHintFieldsform.action = window.document.CiPlanningHintFieldsform.action + '&action='+action_value+'&field_alias='+field_alias+'&query_guid='+query_guid ;
  window.document.CiPlanningHintFieldsform.submit();
}


// -- pour sauvegarder les modif sur les champs du hint du planning des cis et leur ordre
function SaveCiPlanningField(query_guid) 
{
  window.document.CiPlanningHintFieldsform.action = window.document.CiPlanningHintFieldsform.action + '&action=save&query_guid='+query_guid ;
  window.document.CiPlanningHintFieldsform.submit();
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/edit_function.js $
// Revision: 18676 $

var listOfChanges = [] ;
var isChanged = 0;
var current_location ;
var can_save = 1;
var dialog_allow_save = 1;
var listOfDateField =[];
var listTimer = [];
var listOfPopups = [] ;
// R110110_00004 : Nombre de caractères minimum du commentaire de résolution sur les incidents, hors espace
var minLengthFields = 0;
var listOfRequiredMinLengthFields = [];

// -- encodage de l'url
function urlencode(str)
{
  str = encodeURIComponent(str);
  
  return (str);
}

// -- gestion des batch_id
function treatment_batch(guid, action, id)
{
  if (!verify_timeout(false))
    return ('');
    
  if (action == 'del_all')
  {
    txt = edit_function_get_label('clear_list_of_selected_items');  
    
    if (txt == '')
      return; 
    else if (!confirm(txt))
      return;
  }
  
  filename = get_main_directory();
  filename += 'include/javascript/staff/batch_id.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&guid=' + urlencode(guid);
  filename += '&action=' + urlencode(action);
  filename += '&id=' + urlencode(id);
  
  result = sync_url_ajax_get(filename, "");
    
  if (action == 'total_nb')
  {
    if (document.getElementById('__DIV_VIEW_CADDY_NB__') != null)
    document.getElementById("__DIV_VIEW_CADDY_NB__").innerHTML = result + "&nbsp;";
    
    if (document.getElementById('__DIV_VIEW_CADDY__') != null && result != 0)
      document.getElementById('__DIV_VIEW_CADDY__').style.display = 'block';
    else if (document.getElementById('batch_checkbox_all') != null && document.getElementById("batch_checkbox_all").checked)
      document.getElementById('__DIV_VIEW_CADDY__').style.display = 'none';
  }
  else if (action == 'del_all')
  {
    if (document.getElementById('batch_checkbox_all') != null)
    document.getElementById("batch_checkbox_all").checked = false;
    
    for (i = 0; document.getElementById("batch_checkbox_" + i) != null; i++)
    {
      document.getElementById("batch_checkbox_" + i).checked = false;
    }
    
    if (document.getElementById('__DIV_VIEW_CADDY_NB__') != null)
    document.getElementById("__DIV_VIEW_CADDY_NB__").innerHTML = "0&nbsp;";
    
    if (result != '')
    eval(result);
  }
  else if (action == 'unselect_all')
  {
    filename = get_main_directory();
    filename += 'include/javascript/staff/batch_id.php?';
    filename += get_session_name();
    filename += '=';
    filename += get_session_id();
    filename += '&guid=' + urlencode(guid);
    filename += '&action=' + urlencode("in_array");
    filename += '&id=';
    
    for (i = 0; document.getElementById("batch_checkbox_" + i) != null; i++)
    {
      if (i > 0)
      filename += ",";
      filename += document.getElementById("batch_checkbox_" + i).value;
    }
    
    tmp_result = sync_url_ajax_get(filename, "");
    
    if (tmp_result != '')
    {
      eval("tmp_result = " + tmp_result);
      for (i = 0; i < tmp_result.length; i++)
      {
        if (tmp_result[i] == true)
        document.getElementById("batch_checkbox_" + i).checked = true;
        else
        document.getElementById("batch_checkbox_" + i).checked = false;
      }
    }
  }
  else if (action == 'select_all')
  {
    for (i = 0; document.getElementById("batch_checkbox_" + i) != null; i++)
    {
      document.getElementById("batch_checkbox_" + i).checked = true;
    }
  }
  
  return (result);
}

// -- Fonctions de traitement pour les champs d'une fiche --
function dlg_change_date(field)
{
  OnChangeEdit(field);
  var res = checkDate(field, true);
  if (res == false)
  window.parent.document.getElementById(field).style.backgroundColor = 'yellow';
  else
  window.parent.document.getElementById(field).style.backgroundColor = '';
  
  return (res);
}


function dlg_checkdate(field)
{
  var res = checkDate(field, true);
  if (res == false)
  window.parent.document.getElementById(field).style.backgroundColor = 'yellow';
  else
  window.parent.document.getElementById(field).style.backgroundColor = '';
  
  return (res);
}

function dlg_checktime(field)
{
  var res = checkTime(field, true);
  if (res == false)
  window.parent.document.getElementById(field).style.backgroundColor = 'yellow';
  else
  window.parent.document.getElementById(field).style.backgroundColor = '';
  
  return (res);
}


function ed_popup_dlg(field, dlg, sess, maintable)
{
  if (document.getElementById(field))
  {
    str = urlencode(document.getElementById(field).value);
    dlg = urlencode(dlg);
  
    if (str != "")
      listOfPopups[listOfPopups.length] = window.open("include/fic.php?table=" + maintable + "&q2_id=" + str + "&" + sess + "&DialogID=" + dlg + "&visu=1", "", "scrollbars=yes,status=no,width=800,height=600,top=120,left=120,resizable=yes");
  }
}

function ed_goto_block(tmp_fieldname, tmp_name, href, lng)
{
  var field = "";
  
  if (window.parent.document.getElementById(tmp_fieldname + "_hide") != null && 
  window.parent.document.getElementById(tmp_fieldname + "_hide").value != "" && 
  window.parent.document.getElementById(tmp_fieldname + "_hide").value.toUpperCase() != "NULL")
  {
    field = tmp_fieldname + "_hide";
  }
  else if (window.parent.document.getElementById(tmp_name) != null && 
  (window.parent.document.getElementById(tmp_fieldname) == null || 
  (window.parent.document.getElementById(tmp_fieldname).value != "" &&
  window.parent.document.getElementById(tmp_fieldname).value.toUpperCase() != "NULL")))
  {
    field = tmp_name;
  }
  
  if (document.getElementById(field))
  {
    str = urlencode(document.getElementById(field).value);
  
    if (str != "")
      checkChanges(href + '&q2_id=' + str, lng);
  }
}

function ed_mail_dlg (field)
{
  if (document.getElementById(field))
  {
    str = document.getElementById(field).value;
  
    window.location.href="mailto:" + str;
  }
}


function ed_world_link_map (field)
{
  str = "http://maps.google.com/?q=";
  
  var tmp = "";
  
  // ADDR 1 
  if (document.getElementById(field + "_ADDR1") && document.getElementById(field + "_ADDR1").value != "")
  tmp = urlencode(document.getElementById(field + "_ADDR1").value);
  
  // ADDR 2 
  if (document.getElementById(field + "_ADDR2") && document.getElementById(field + "_ADDR2").value != "")
  {
    if (tmp != "")
    tmp += "+";
    
    tmp += urlencode(document.getElementById(field + "_ADDR2").value);
  }
  
  str += tmp;
  
  // CP 
  str += ",";
  if (document.getElementById(field + "_CP"))
  str += urlencode(document.getElementById(field + "_CP").value);

  // Location
  str += ",";
  if (document.getElementById(field + "_CITY"))
  str += urlencode(" " + document.getElementById(field + "_CITY").value);

  // Country
  str += ",";
  if (document.getElementById(field + "_COUNTRY"))
  str += urlencode(document.getElementById(field + "_COUNTRY").value);

  listOfPopups[listOfPopups.length] = window.open(str, "", "");
}


function ed_world_link_dlg1 (field, url, type)
{
  if (document.getElementById(field))
  {
    str = url;
    str = str.replace("@@URLFIELD@@", document.getElementById(field).value);

    if (type == "link_popup")
    listOfPopups[listOfPopups.length] = window.open(str, "link_popup", "status=no,scrollbars=yes,width=800,height=600,top=120,left=120,resizable=yes");
    else
    listOfPopups[listOfPopups.length] = window.open(str, "", "");
  }
}


function ed_world_link_dlg2 (field)
{
  if (document.getElementById(field))
  {
    str = "http://";
    str = str + document.getElementById(field).value;

    listOfPopups[listOfPopups.length] = window.open(str, "", "");
  }
}


function ed_world_link_dlg3 (field)
{
  if (document.getElementById(field))
  {
    str = "http://www.unspsc.org/Search.asp?css=";
    str = str + urlencode(document.getElementById(field).value);

    listOfPopups[listOfPopups.length] = window.open(str, "", "");
  }
}


// -- récupération de libellés
function edit_function_get_label(str)
{
  if (!verify_timeout(false))
    return (str);
    
  var result = str.replace("_", " ");
  
  filename = get_main_directory();
  filename += 'include/javascript/staff/edit_function.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&str=' + urlencode(str);
  
  result = sync_url_ajax_get(filename, "");
  
  return (result);
}

// -- récupération de libellés
function edit_function_get_regexp(regexp)
{
  if (!verify_timeout(false))
    return (regexp);
    
  filename = get_main_directory();
  filename += 'include/javascript/staff/edit_function.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&regexp=' + urlencode(regexp);
  
  result = sync_url_ajax_get(filename, "");
  
  if (result == "")
    result = regexp;
  
  return (result);
}

// Fonction vérifiant que les heures sont correctement saisies dans le calendrier SLA
function checkTimeSLA (lng, regexp)
{
  var re_time;
  var flag = 0;
  //re_time = new  RegExp(regexp);
  eval('re_time = ' + regexp);
  for (day=1; day < 8; day++)
  {
    for (plage=1; plage < 4; plage++)
    {
      for (j=1; j < 3; j++)
      {
        name= day + '_plage_' + plage + j;
        //value = window.parent.document.getElementById(name).value ;
        if (window.parent.document.getElementById(name).value != '' && re_time.test(window.parent.document.getElementById(name).value) == false)
        {  
          window.parent.document.getElementById(name).style.backgroundColor = 'yellow';
          can_save = 0;
          flag = 1;
        }
      else
        window.parent.document.getElementById(name).style.backgroundColor = '';
      } 
    }
  }
  if (flag == 0)
    window.parent.document.form_calendar.submit();
}


function doOnloadPopup ()
{
  //var false_popup = window.parent.document.getElementsByName('false_popup_span'));
}


function doUpload (sess, input_name, form_name)
{
  listOfPopups[listOfPopups.length] = window.open ('include/upload_file.php?' + sess, '', 'scrollbars=yes,status=no,width=650,height=50,top=120,left=120,resizable=yes');
}


/**
* Fonction permettant de télécharger des documents "uploadés" sur le serveur
* 
* @param sess : ID de la session
* @param ref_document : Nom Physique du fichier (urlencode requis)
* @param log_document : Nom Logique du fichier (urlencode requis)
*/
function doDownload (sess, ref_document, log_document)
{
  window.location.href = 'include/download_file.php?' + sess + '&p='+ ref_document +'&l='+ log_document;
  
  //listOfPopups[listOfPopups.length] = window.open ('include/download_file.php?' + sess + '&p='+ urlencode(ref_document) +'&l='+ urlencode(log_document) ,'download_popup', 'scrollbars=yes, status=no, width=20, height=20, top=120, left=120, resizable=yes');
  //if (window.download_popup != null )
    //window.download_popup.close();
}
      

function getCurrentDateTime () 
{
  var csChaine;
  var nJour, nMois, nAnnee, nHeures , nMinutes, nSecondes;
  var dtJour;
  csChaine = " ";
  dtJour = new Date();
  nJour = dtJour.getDate();
  if ( nJour < 10 ) csChaine += "0";
  
  csChaine += nJour;
  
  nMois = dtJour.getMonth() + 1;
  
  if (nMois == 1) csChaine += " Janvier";
  else if (nMois == 2) csChaine += " Février";
  else if (nMois == 3) csChaine += " Mars";
  else if (nMois == 4) csChaine += " Avril";
  else if (nMois == 5) csChaine += " Mai";
  else if (nMois == 6) csChaine += " Juin";
  else if (nMois == 7) csChaine += " Juillet";
  else if (nMois == 8) csChaine += " Août";
  else if (nMois == 9) csChaine += " Septembre";
  else if (nMois == 10) csChaine += " Octobre";
  else if (nMois == 11) csChaine += " Novembre";
  else if (nMois == 12) csChaine += " Décembre";
  
  csChaine += " ";
  
  nAnnee = dtJour.getYear();
  
  if (nAnnee <= 99) nAnnee += 1900;
  
  csChaine += nAnnee + " ";
  
  nHeures = dtJour.getHours();
  
  if (nHeures < 10) csChaine += "0";
  
  csChaine += nHeures + ":";
  
  nMinutes = dtJour.getMinutes();
  
  if (nMinutes < 10) csChaine += "0";
  
  csChaine += nMinutes + ":";
  
  nSecondes = dtJour.getSeconds();
  
  if (nSecondes < 10) csChaine += "0";
  
  csChaine += nSecondes;
  
  return csChaine

}


function startClock(block_id)
{
  counter = 'x' + block_id;
  clock ='clock' + block_id;
  
  window.parent.document.getElementById(counter).value  = window.parent.document.getElementById(counter).value - 1;
  
  if(window.parent.document.getElementById(counter).value < 0)
  {
    //window.parent.document.getElementById(clock).innerHTML = "&nbsp;";
    window.parent.document.getElementById(counter).value = 10;
    eval ('window.parent.document.form_'+block_id+'.submit();');
  }
  else
  {
    setTimeout('startClock("'+block_id+'")', 1000);
  }
  
}


// Fonction vérifiant si un chaîne est numérique.
function checkNumeric (Num, type, lng, regexp_int, regexp_curr)
{
  var msg = get_checkNumeric (Num, type, lng, regexp_int, regexp_curr);
   
  if (msg != '')
  {
    can_save = 0;
    alert(msg);
  }
  else
  can_save = 1;
  
  return (can_save);
}

function get_checkNumeric (Num, type, lng, regexp_int, regexp_curr)
{
  var re_int;
  var re_curr;
  
  if (regexp_int == '')
  regexp_int = edit_function_get_regexp("int");
  
  if (regexp_curr == '')
  regexp_curr = edit_function_get_regexp("float");
  
  eval('re_int = ' + regexp_int);
  eval('re_curr = ' + regexp_curr);

  msg = "";
  
  if (window.parent.document.getElementById(Num) != null)
  {
    if (window.parent.document.getElementById(Num).value.replace(" ", "") != "" &&
      (((type == 'integer' || type == 'int') && re_int.test(window.parent.document.getElementById(Num).value) == false) ||
      (type == 'currency' && re_curr.test(window.parent.document.getElementById(Num).value) == false)))
    {
      msg = edit_function_get_label('checknumeric');
      window.parent.document.getElementById(Num).style.backgroundColor = 'yellow';
    }
    else if (window.parent.document.getElementById(Num).name == 'q2_searchfield')
    {
      window.parent.document.getElementById(Num).style.backgroundColor = '';
      return (msg);
    }
    else
    {
      window.parent.document.getElementById(Num).style.backgroundColor = '';
    }

    window.parent.document.getElementById(Num).select();
  }
  
  return (msg);
}

function frmSearchDataToJSON()
{
  var frmSearch = document.getElementById('frmSearch');
  var frmSearchLength = frmSearch.length;
  var result = {};
  var sEval = '';
  for(var i=0; i<frmSearchLength; i++)
  {
    if (frmSearch[i].id == 'q2_searchfield')
    sEval += 'result.' + frmSearch[i].id + '= "' + frmSearch[i].value + '";';
  }
  eval(sEval);
  return (result);
}


function OnChangeEdit (name)
{
  isChanged=1;
  listOfChanges[listOfChanges.length] = name ;
}


// Demande de sauvegarde des changements effectués sur une fiche
function checkChangesWithoutRedirect (lng)
{
  if (!verify_timeout(false))
    return (0);
    
  var res = 0;

  if (dialog_allow_save == 1 && isChanged == 1)
  {
    txt = edit_function_get_label('datachanged');
    
    if (txt == '')
      return (0); 
    
    msg = checkerror(lng);
    if (msg == '')
    aValid = 1;
    else
    aValid = 0;
    
    if (aValid == 1 && confirm (txt))
    {
      saveForm ('editForm', lng, 0);
      isChanged = 0;   // rajouté par NM le 25/08/2005 => Sans cela, on boucle indéfiniment, le JS demandant toujours si on souhaite sauvegarder.

      for (i = 0; i < listOfChanges.length; i++)
      {
        window.parent.document.getElementById(listOfChanges[i]).style.backgroundColor = '';
      }
    }
    
    res = 1;
  }
  
  return (res);
}

function checkChangesWithoutRedirectQc(lng)
{
  if (!verify_timeout(false))
    return (0);
    
  var res = 0;

  if (dialog_allow_save == 1 && isChanged == 1)
  {
    txt = edit_function_get_label('datachanged');
    
    if (txt == '')
      return (0); 
    
    msg = checkerror(lng);
    if (msg == '')
    aValid = 1;
    else
    aValid = 0;
    
    if (aValid == 1 && confirm (txt))
    {
      if (saveFormIFrame("editForm2", lng, false, "", true) == 0)
        return 0;
      if (saveFormIFrame("editForm", lng, false, "", true) == 0)
        return 0;
        
      isChanged = 0;   // rajouté par NM le 25/08/2005 => Sans cela, on boucle indéfiniment, le JS demandant toujours si on souhaite sauvegarder.

      for (i = 0; i < listOfChanges.length; i++)
      {
        window.parent.document.getElementById(listOfChanges[i]).style.backgroundColor = '';
      }
    }
    
    res = 1;
  }
  
  return (res);
}

function checkerror_form_name(form_name, lng, listchangesinyellow)
{
  msg = ''; 
  aValid = 1;
  
  form = window.parent.document.forms[form_name];
    
  // Champs requis
  if (form.elements[form_name + 'required_fields'] != null)
  {
    var required_fields = form.elements[form_name + 'required_fields'].value;
    var aList = new Array ();

    while (required_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = required_fields.substring(0, required_fields.indexOf(',', 0));
      required_fields = required_fields.substring(required_fields.indexOf(',', 0) + 1, required_fields.length);
    }

    if (required_fields.substring(0, required_fields.length) != '')
    {
      aList[aList.length] = required_fields.substring(0, required_fields.length) ;
    }

    for (i = 0; i < aList.length; i++)
    {
      if (form.elements[aList[i]] != null)
      { 
        if (form.elements[aList[i] + '_hide'] == null && form.elements[aList[i]].value.replace(' ', '') == '')
        {
          if (typeof(tinyMCE) != "undefined" && tinyMCE != null)
          editor_id = tinyMCE.get(form.elements[aList[i]].name);
          else
          editor_id = null;
      
          if (editor_id != null)
          {
            // Champ Wysiwyg
            tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
            tmp_value = tinyMCE.getInstanceById(form.elements[aList[i]].name).getContent();
            
            if (tmp_value.replace(' ', '') == '')
            {
              document.getElementById(aList[i] + '_tbl').style.backgroundColor = 'yellow';
              form.elements[aList[i]].style.backgroundColor = 'yellow';
              tinyMCE.getInstanceById(form.elements[aList[i]].name).getBody().style.backgroundColor = "yellow";

              aValid = 0;
            }
            else
            {
              document.getElementById(aList[i] + '_tbl').style.backgroundColor = '';
              form.elements[aList[i]].style.backgroundColor = '';
              tinyMCE.getInstanceById(form.elements[aList[i]].name).getBody().style.backgroundColor = "";
            }
          }
          else
          {
            form.elements[aList[i]].style.backgroundColor = 'yellow';
            jQuery_id = aList[i].replace(".", "\\.");
            $("#"+jQuery_id).setCSSComboboxUI("backgroundColor", "yellow");
            aValid = 0;
          }
        }
        else if (form.elements['type_' + aList[i]] != null && 
        form.elements['type_' + aList[i]].value.replace(' ', '').toUpperCase() == 'DATETIME' && 
        form.elements[aList[i]].value.replace(' ', '') == '')
        {
          form.elements[aList[i]].style.backgroundColor = 'yellow';
          aValid = 0;
        }
        else if (form.elements[aList[i] + '_hide'] != null && 
        form.elements[aList[i]].value.replace(' ', '').toUpperCase() == 'N/A')
        {
          form.elements[aList[i]].style.backgroundColor = 'yellow';
          aValid = 0;
        }
        else
        {
          form.elements[aList[i]].style.backgroundColor = '';
          jQuery_id = aList[i].replace(".", "\\.");
          $("#"+jQuery_id).setCSSComboboxUI("backgroundColor", "");
        }
      }
    } 
    
    if (aValid == 0) 
    {
      msg = edit_function_get_label('fieldrequired');
    }
  }

  // Vérification des dates 
  if (form.elements[form_name + 'date_fields'] != null && aValid == 1)
  {
    var date_fields = form.elements[form_name + 'date_fields'].value;
    var aList = new Array ();
  
    while ( date_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = date_fields.substring(0, date_fields.indexOf(',', 0));
      date_fields = date_fields.substring(date_fields.indexOf(',', 0) + 1, date_fields.length);
    }

    if (date_fields.substring(0, date_fields.length) != '')
    {
      aList[aList.length] = date_fields.substring(0, date_fields.length) ;
    }
    
    for (i = 0; i < aList.length; i++)
    {
      if (!checkDate(aList[i], false))
      {
        window.parent.document.getElementById (aList[i]).style.backgroundColor = 'yellow';
        aValid = 0;
      }
      else if (form.elements[aList[i]] != null)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = '';
      }
    }

    if (aValid == 0) 
    {
      msg = edit_function_get_label('bad_date_format');
    }
  }
  
  // Vérification des dates/heures 
  if (form.elements[form_name + 'datetime_fields'] != null && aValid == 1)
  {
    var datetime_fields = form.elements[form_name + 'datetime_fields'].value;
    var aList = new Array ();
  
    while ( datetime_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = datetime_fields.substring(0, datetime_fields.indexOf(',', 0));
      datetime_fields = datetime_fields.substring(datetime_fields.indexOf(',', 0) + 1, datetime_fields.length);
    }

    if (datetime_fields.substring(0, datetime_fields.length) != '')
    {
      aList[aList.length] = datetime_fields.substring(0, datetime_fields.length) ;
    }
    
    for (i = 0; i < aList.length; i++)
    {
      if (!checkDate(aList[i], false))
      {
        window.parent.document.getElementById (aList[i]).style.backgroundColor = 'yellow';
        aValid = 0;
      }
      else if (form.elements[aList[i]] != null)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = '';
      }
    }
    
    if (aValid == 0) 
    {
      msg = edit_function_get_label('bad_date_format');
    }
  }
  
  // Vérification des nombres entiers
  if (form.elements[form_name + 'numeric_fields'] != null && aValid == 1)
  {
    var numeric_fields = form.elements[form_name + 'numeric_fields'].value;
    var aList = new Array ();
  
    while ( numeric_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = numeric_fields.substring(0, numeric_fields.indexOf(',', 0));
      numeric_fields = numeric_fields.substring(numeric_fields.indexOf(',', 0) + 1, numeric_fields.length);
    }

    if (numeric_fields.substring(0, numeric_fields.length) != '')
    {
      aList[aList.length] = numeric_fields.substring(0, numeric_fields.length) ;
    }
    
    for (i = 0; i < aList.length; i++)
    {
      msg = get_checkNumeric(aList[i], "integer", lng, "", "");
      if (msg != "")
      {
        window.parent.document.getElementById (aList[i]).style.backgroundColor = 'yellow';
        aValid = 0;
      }
      else if (form.elements[aList[i]] != null)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = '';
      }
    }
  }

  // Vérification des nombres flottants
  if (form.elements[form_name + 'currency_fields'] != null && aValid == 1)
  {
    var currency_fields = form.elements[form_name + 'currency_fields'].value;
    var aList = new Array ();
  
    while ( currency_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = currency_fields.substring(0, currency_fields.indexOf(',', 0));
      currency_fields = currency_fields.substring(currency_fields.indexOf(',', 0) + 1, currency_fields.length);
    }

    if (currency_fields.substring(0, currency_fields.length) != '')
    {
      aList[aList.length] = currency_fields.substring(0, currency_fields.length) ;
    }
    
    for (i = 0; i < aList.length; i++)
    {
      msg = get_checkNumeric(aList[i], "currency", lng, "", "");
      if (msg != "")
      {
        window.parent.document.getElementById (aList[i]).style.backgroundColor = 'yellow';
        aValid = 0;
        break;
      }
      else if (form.elements[aList[i]] != null)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = '';
      }
    }
  }
  
  // Vérification des durées
  if (form.elements[form_name + 'duration_fields'] != null && aValid == 1)
  {
    var duration_fields = form.elements[form_name + 'duration_fields'].value;
    var aList = new Array ();
  
    while (duration_fields.indexOf(',', 0) != -1)
    {
      aList[aList.length] = duration_fields.substring(0, duration_fields.indexOf(',', 0));
      duration_fields = duration_fields.substring(duration_fields.indexOf(',', 0) + 1, duration_fields.length);
    }

    if (duration_fields.substring(0, duration_fields.length) != '')
    {
      aList[aList.length] = duration_fields.substring(0, duration_fields.length) ;
    }
    
    for (i = 0; i < aList.length; i++)
    {
      if (validDuration($("#" + aList[i].replace('.', '\\.')).val()) === false)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = 'yellow';
        aValid = 0;
      }
      else if (form.elements[aList[i]] != null)
      {
        window.parent.document.getElementById(aList[i]).style.backgroundColor = '';
      }
    }
    
    if (aValid == 0) 
      msg = edit_function_get_label('checkduration');
  }
  
  if (listchangesinyellow == true && aValid == 1)
  {
    for (i = 0; listOfChanges != null && i < listOfChanges.length; i++)
    {
      window.parent.document.getElementById(listOfChanges[i]).style.backgroundColor = 'yellow';
      jQuery_id = listOfChanges[i].replace(".", "\\.");
      $("#"+jQuery_id, "window.parent").setCSSComboboxUI("backgroundColor", "yellow");
    }
  }
  
  return (msg);
}

function checkerror(lng)
{
  msg = ''; 
  
  for (i = 0; msg == "" && i < 2; i++)
  {
    if (i == 0)
    form_name = "editForm";
    else
    form_name = "editForm2";
    
    if (document.getElementById(form_name) != null)
    msg = checkerror_form_name(form_name, lng, true);
  }

  return (msg);
}

/**
 * Indique si on sauvegarde la fiche
 * @return int : 0 = Pas de sauvegarde, 1 = Sauvegarde, 2 = Erreur 
 */
function checkChangesAction(lng) 
{
  if (!verify_timeout(false))
    return (2);
    
  if (dialog_allow_save == 1 && isChanged == 1)
  {
    txt = edit_function_get_label('datachanged');

    if (txt == '')
      return (0); 
    
    msg = checkerror(lng);
    if (msg == '')
      aValid = 1;
    else
      aValid = 0;
    
    if (confirm (txt))
    {
      if (aValid == 1)
      {
        isChanged = 0; // Sans cela, on boucle indéfiniment, le JS demandant toujours si on souhaite sauvegarder.
        iRes = 1;
      }
      else
      {
        alert(msg);
        iRes = 2;
      }
    }
    else
    {
      isChanged = 0; // Sans cela, on boucle indéfiniment, le JS demandant toujours si on souhaite sauvegarder.
      iRes = 0;
    }
  }
  else
    iRes = 0;
  
  return (iRes);
}

function checkChanges(newlocation, lng)
{
  if (newlocation.indexOf('&logout=1', 0) > -1)
    var bIsLogout = true;
  else
    var bIsLogout = false;
  
  if (!verify_timeout(bIsLogout))
    return;
    
  if (dialog_allow_save == 1 && isChanged == 1)
  {
    txt = edit_function_get_label('datachanged');

    if (txt == '')
    {
      window.location.href = window.location.href.replace("#", "");
      return;
    }

    msg = checkerror(lng);
    if (msg == '')
    aValid = 1;
    else
    aValid = 0;
    
    if (confirm (txt))
    {
      if (aValid == 1)
      {
        if (!saveajaxform('editForm'))
          return;
        if (!saveajaxform('editForm2'))
          return;
        isChanged = 0;   // rajouté par NM le 25/08/2005 => Sans cela, on boucle indéfiniment, le JS demandant toujours si on souhaite sauvegarder.
      }
      else
      alert(msg);
    }
    else
    aValid = 1;
    
    if (aValid == 1)
    {
      if (newlocation == '')
        window.history.back();
      else
        window.location.href = newlocation;
    }
  }
  else
  {
    if (newlocation == '')
      window.history.back();
    else
      window.location.href = newlocation;
  }
}

// -- Sauvegarde via ajax
function saveajaxform(form_name)
{
  if (!verify_timeout(false))
    return;
  
  form = window.parent.document.forms[form_name];
  
  if (form != null)
  {
    form.action = form.action.replace("index.php", "ajaxfiche.php");
    return sync_formulaire_ajax_eval(form.action, form_name, "POST", "");
  }
  
  return true;
}

//------------
function fireAction (n, sess, id, q2treeid, isGrid, themeGUID, FromGUID, FromType, main_tablename, current_page_for_grid)
{
  ids = '';
  separator = ',';
  
  if (n == 1 || id == 0)
  ids = treatment_batch(FromGUID, "get", "");
  else
  ids = id;
  
  if (ids != '')
    ids = '&batch_id=' + urlencode(ids);
  if (q2treeid != '' && q2treeid != 0)
    q2treeid = '&id=' + urlencode(q2treeid);
  else
    q2treeid = '';
    
  wizard_name = get_wizard_name(window.parent.document.getElementById('action_select').value, FromGUID);
  
  // selection multi-pages
  select_all = treatment_batch(FromGUID, "is_select_all", "");
  
  if (FromGUID != '')
    FromGUID = FromType + '=' + urlencode(FromGUID);
  
  current_page_for_grid = urlencode(current_page_for_grid);
  select_all = urlencode(select_all);
  main_tablename = urlencode(main_tablename);
  themeGUID = urlencode(themeGUID);
   
  if (isGrid == '1')
  {
    listOfPopups[listOfPopups.length] = window.open ('Wizard.php?current_page='+current_page_for_grid+'&selectall='+select_all+'&pk_tablename='+ main_tablename + '&theme='+themeGUID+'&'+FromGUID+'&'+sess+'&init_wizard=true&q2_is_grid=1' + q2treeid + ids + '&guid='+ urlencode(window.parent.document.getElementById('action_select').value),wizard_name, 'scrollbars=yes,status=yes,width=100,height=100,top=120,left=120,resizable=yes');  
  }
  else
  {
    listOfPopups[listOfPopups.length] = window.open ('Wizard.php?pk_tablename='+ main_tablename + '&theme='+themeGUID+'&'+FromGUID+'&'+sess+'&init_wizard=true' + q2treeid + ids + '&guid='+ urlencode(window.parent.document.getElementById('action_select').value), wizard_name, 'scrollbars=yes,status=yes,width=100,height=100,top=120,left=120,resizable=yes');  
  }
}


function fireActionByAssistGUID (n, sess, id, q2treeid, GUID, from, tablename, FromGUID, theme, ParamsListBase64) 
{
  ids = '';
  separator = ',';
  if (id == 0)
  {
    ids = treatment_batch(GUID, "get", "");
  }
  else
  {
    ids = id;
  }
  
  if (ids != '')
  ids = '&batch_id=' + urlencode(ids);
  
  if (q2treeid != '' && q2treeid != 0)
    q2treeid = '&id=' + urlencode(q2treeid);
  else
    q2treeid = '';

  wizard_name = get_wizard_name(GUID, FromGUID);

  if (from != '')
    wizard_from = '&wizard_from=' + urlencode(from);
  else
    wizard_from = '';
  
  if (FromGUID != '')
    dialog_guid = '&dialog_guid=' + urlencode(FromGUID);
  else
    dialog_guid = '';
  
  if (theme != '')
    theme = '&theme=' + urlencode(theme);
  else
    theme = '';
  
  if (ParamsListBase64 != '')
    wizardParams = '&wizardParams=' + urlencode(ParamsListBase64);
  else
    wizardParams = '';
  
  listOfPopups[listOfPopups.length] = window.open ('Wizard.php?'+sess+'&init_wizard=true' + dialog_guid + q2treeid + ids + wizard_from + '&guid='+ urlencode(GUID) +'&pk_tablename=' +urlencode(tablename) + theme + wizardParams ,
    wizard_name, 'scrollbars=yes,status=yes,width=100,height=100,top=120,left=120,resizable=yes');
}

/**
 * Nom de la popup associée à un assistant
 * 
 * @param guid GUID de l'assistant
 * @param sFromGuid GUID de l'interface à partir de laquelle on lance l'assistant
 * @return Le nom de la popup
 */
function get_wizard_name(guid, sFromGuid)
{
  // Sur la prise d'appel, on ne peut lancer qu'un assistant à la fois
  if (sFromGuid.toUpperCase() == '{90D54E77-40A5-4F0F-8029-5A7A05F5814D}')
    guid = sFromGuid;
    
  reg = new RegExp("({)", "g");
  guid = guid.replace(reg, "");
  
  reg = new RegExp("(})", "g");
  guid = guid.replace(reg, "");
  
  reg = new RegExp("(-)", "g");
  
  while (guid.match(reg)) 
  {
    guid = guid.replace(reg, "");
  }
  
  return (guid);
}

function gestBoolean (name) 
{
  if (window.parent.document.getElementById (name+'0').checked  ) 
  {
    window.parent.document.getElementById (name).value = 1 ;
  }
  else
  {
    window.parent.document.getElementById (name).value = 0;
  }
}


function gestBooleanGrid (name) 
{
  if (window.parent.document.getElementById (name+'_0').checked  ) 
  {
    window.parent.document.getElementById (name).value = 1 ;
  }
  else
  {
    window.parent.document.getElementById (name).value = 0 ;
  }
}

function onChangeFilter (formName, iFrame)
{  
  str = delete_param_url (window.location.href,'q2_f');
  str = delete_param_url (str,'back');
  // ROXANA TEAM For Translator
  str = delete_param_url (str,'replace_messages');
  str = delete_param_url (str,'forcerefresh');
  str = delete_param_url (str,'dontaskdynamicfilter');
  str = str.replace("#", "");

  if (iFrame == '')
  window.location.href = str + '&q2_f=' + urlencode(window.parent.document.getElementById("comboFilter").value) +'&OnChangeFilter=true';
  else
  {
    var obj = eval("window." + iFrame);
    obj.location.href = str + '&q2_f=' + urlencode(window.parent.document.getElementById("comboFilter").value) +'&OnChangeFilter=true&iframe=GRID';
  }
}


function onChangeTypeRequest (href)
{  
  window.location.href = href + '&q2_section=' +window.parent.document.getElementById('selectPA').value;
}


function onChangeLayout(formName, iFrame)
{  
  str = delete_param_url (window.location.href,'q2_r');
  str = delete_param_url (str,'q2_filter');
  str = delete_param_url (str,'q2_filters');
  str = delete_param_url (str,'q2_tree_id');
  str = delete_param_url (str,'q2_treetable');
  str = delete_param_url (str,'back');
  str = delete_param_url (str,'forcerefresh');
  str = delete_param_url (str,'dontaskdynamicfilter');
  str = delete_param_url (str,'q2_clickfield');
  str = delete_param_url (str,'q2_value_selected');
  str = delete_param_url (str,'clickpage');
  str = delete_param_url (str,'q2_level');
  str = delete_param_url (str,'q2_cnt');
  str = delete_param_url (str,'clickHisto');
  str = delete_param_url (str,'histo_pos');
  str = delete_param_url (str,'ShowGraph');
  str = delete_param_url (str,'ShowMap');
  str = delete_param_url (str,'ShowGoogleMaps');
  str = delete_param_url (str,'GraphChart');
  
  str = str.replace("#", "");

  if (iFrame == '')
  window.location.href =  str + '&q2_r='+ urlencode(window.parent.document.getElementById("comboLayout").value);
  else
  {
    var obj = eval("window." + iFrame);
    obj.location.href =  str + '&q2_r='+ urlencode(window.parent.document.getElementById("comboLayout").value) + '&iframe=GRID';
  }
}

function changeDomainFrmAction()
{
  var str = window.location.href;
  str = str.replace("#", "");
  str = delete_params_url(str, new Array("q2_filter", "q2_filters", "q2_tree_id", "q2_treetable", "back", "q2_clickfield", "q2_value_selected", "clickpage", "q2_level", "q2_cnt", "q3_page", "clickHisto", "histo_pos"));
  document.domainFormToolbar.action = str;
}


function processIFrame (id_name, html_value)
{
  window.parent.document.getElementById(id_name).innerText = html_value;
}


function processIFrame2(id_name,html_value, block_id)
{
  window.parent.document.getElementById(id_name).innerHTML = html_value;
 // startClock (block_id);
}

// Timer empêchant qu'il y ait trop d'appels au fichier timeout_ajax.php
var _timeout_ajax_timer = 0;

// -- Vérification de l'expiration de la session
// -- @return booléen indiquant si on peut continuer l'exécution du code javascript 
function verify_timeout(bIsLogout)
{
  var currentDate = new Date();
  var iTime = currentDate.getTime();
  
  // Timer empêchant qu'il y ait trop d'appels au fichier timeout_ajax.php
  if (iTime < _timeout_ajax_timer + 120000)
    return (true);
  else
    _timeout_ajax_timer = iTime;

  // On vérifie si on traite le timeout
  if (!bCanTreatTimeout)
    return (true);
  
  var filename = window.parent.location.href.replace("#", "");
  if (filename.indexOf("index.php") == -1)
    filename += "timeout_ajax.php";
  else
    filename = filename.replace("index.php", "timeout_ajax.php");  
  
  if (filename.indexOf('?') == -1)
    filename += '?' + get_session_id();
  
  if (bIsLogout)
    filename += '&logout=1';
  
  // On vérifie que la session est toujours active
  bResult = sync_url_ajax_eval(filename + "&__AJAX_TIMEOUT_FCT__=session_active", "");
  if (!bResult)
  {
    // La session n'étant plus active, on demande à l'utilisateur de se reconnecter
    sync_url_ajax_eval(filename + "&__AJAX_TIMEOUT_FCT__=interface_relogin", "");
    
    // On vérifie si la session est active
    bResult = sync_url_ajax_eval(filename + "&__AJAX_TIMEOUT_FCT__=session_active", "");    
    if (!bResult)
    {
      // la session n'étant pas active, on se déconnecte
      var str = window.parent.location.href.replace("#", "");
      if (str.indexOf('?') == -1)
        window.parent.location.href = str + "?logout=1";
      else
        window.parent.location.href = str + "&logout=1";
      
      return (false);      
    }
  }
  
  return (true);
}

function saveForm (form_name, lng, is_double_save)
{
  if (!verify_timeout(false))
    return (0);
  
  // -- On vérifie si on a le droit de sauvegarder la fiche
  if (dialog_allow_save == 0)
    return (1);
    
  var res = 1;
  
  form = window.parent.document.forms[form_name];
  res = checkRequiredFieldsInForm (form_name, form, lng, is_double_save, '', '', false);
  
  return (res);
}


function saveFormIFrame(form_name, lng, check, iframe, is_request)
{  
  if (!verify_timeout(false))
    return (0);
  
  // -- On vérifie si on a le droit de sauvegarder la fiche
  if (dialog_allow_save == 0)
    return (1);
    
  var res = 1;
  
  if (window.parent.document.getElementById("next_call") != null)
    window.parent.document.getElementById("next_call").value = "";

  if (window.parent.document.getElementById("next_call2") != null)
    window.parent.document.getElementById("next_call2").value = "";
  
  if (iframe == '')
  iframe = 'IFrame' + form_name;
  form = window.parent.document.forms[form_name];
  
  res = 1;
  if (form != null)
  {
    if (check == true)
    {
      res = checkRequiredFieldsInForm (form_name, form, lng, 0, '', iframe, is_request);
    }
    else
    {
      // On indique que l'on a sauvegardé la fiche
      isChanged = 0;
      
      window.parent.document.forms[form_name].target = iframe;
      if (is_request == true)
      {
        window.parent.document.forms[form_name].action = window.parent.document.forms[form_name].action.replace("index.php", "iframefiche.php");
        
        AjaxResult = sync_formulaire_ajax_get(window.parent.document.forms[form_name].action, form_name, "POST", "");
        eval(AjaxResult);
        
        if (typeof(errorFound) != "undefined" && errorFound != null && errorFound == true)
          res = 0;
      }
      else
      {
        window.parent.document.forms[form_name].target = '';
        window.parent.document.forms[form_name].submit();
      }
    }
    // R110110_00004 : Nombre de caractères minimum du commentaire de résolution sur les incidents, hors espace
    if (res == 1 && minLengthFields != null && minLengthFields > 0)
    {
      res = checkRequiredMinLengthFields(form_name, form, lng, 0, '', iframe, is_request);
      if (res == 0)
      return (0);
    }
  }
  
  return (res);
}


function saveFormIFrameNextCall (form_name, lng, check, iframe, is_request, next_call)
{
  if (!verify_timeout(false))
    return (0);
  
  var res = 1; 
  
  if (window.parent.document.forms[form_name].action.indexOf("index_popup.php") > -1)
  {
    // R080228_00006 : Le Bouton d'appel des Documents ne fonctionne pas sur les Fiches Popup de la recherche Full-Text
    eval(next_call);
  }
  else
  {
    if (window.parent.document.forms[form_name].elements["next_call"] != null)
    window.parent.document.forms[form_name].elements["next_call"].value = Base64.encode(next_call);
    else if (window.parent.document.forms[form_name].elements["next_call2"] != null)
    window.parent.document.forms[form_name].elements["next_call2"].value = Base64.encode(next_call);
    
    if (iframe == '')
    iframe = 'IFrame' + form_name;
    form = window.parent.document.forms[form_name];
    
    if (form != null)
    {
      // -- On vérifie si on a le droit de sauvegarder la fiche
      if (dialog_allow_save == 1 && check == true)
      {
        res = checkRequiredFieldsInForm (form_name, form, lng, 0, next_call, iframe, is_request);
      }
      else
      {
        // On indique que l'on a sauvegardé la fiche
        isChanged = 0;
        
        window.parent.document.forms[form_name].target = iframe;
        if (is_request == true)
        {
          window.parent.document.forms[form_name].action = window.parent.document.forms[form_name].action.replace("index.php", "iframefiche.php");
          
          AjaxResult = sync_formulaire_ajax_get(window.parent.document.forms[form_name].action, form_name, "POST", "");
          eval(AjaxResult);

          if (typeof(errorFound) != "undefined" && errorFound != null && errorFound == true)
            res = 0;
        }
        else
        {
          window.parent.document.forms[form_name].target = '';
          window.parent.document.forms[form_name].submit();
        }
      }
    }
  }
  
  return (res);
}


function saveFormAndFireWizard (form_name, lng, is_double_save, next_call)
{
  if (!verify_timeout(false))
    return (0);
  
  // -- On vérifie si on a le droit de sauvegarder la fiche
  if (dialog_allow_save == 0)
  {
    eval(next_call);
    return (1);
  }
  
  var res = 1;
  
  form = window.parent.document.forms[form_name];
  res = checkRequiredFieldsInForm (form_name, form, lng, is_double_save, next_call, 'RemoteScriptingFiche', true);
  
  return (res);
}
 
function printForm ()
{
  alert(edit_function_get_label('notyetavailable'));
}


function emailForm ()
{
  alert(edit_function_get_label('notyetavailable'));
}


function helpForm ()
{
  alert(edit_function_get_label('notyetavailable'));
}


function checkRequiredFieldsInForm(form_name, form, lng, is_double_save, next_call, target, is_request)
{ 
  var i;
  var aValid = 1;

  if (form == null)
  return (aValid);
  
  msg = checkerror_form_name(form_name, lng, false);
  if (msg == '')
  aValid = 1;
  else
  {
    alert(msg);
    aValid = 0;
  }
  
  // Ajout de tests supplémentaire pour la fiche de prise d'appel
  if (aValid == 1 && is_request == true)
  {
    var dlgId = $("#__Q2DIALOGID__");
    if ((dlgId.length == 0 || dlgId.html().toUpperCase() == '{90D54E77-40A5-4F0F-8029-5A7A05F5814D}') && 
    document.getElementById("AM_ASSET_CI.NETWORK_IDENTIFIER_hide") != null && 
    (document.getElementById("AM_ASSET_CI.NETWORK_IDENTIFIER_hide").value == "" || 
    document.getElementById("AM_ASSET_CI.NETWORK_IDENTIFIER_hide").value == "NULL") && 
    document.getElementById("SD_CATALOG.TITLE_" + lng + "_hide") != null && 
    document.getElementById("SD_CATALOG.TITLE_" + lng + "_hide").value != "" && 
    document.getElementById("SD_CATALOG.TITLE_" + lng + "_hide").value != "NULL")
    {
      // On vérifie si le CI est requis
      var str = window.parent.location.href.replace("#", "");
      str = str.replace("index.php", "reload_qc.php");
		  str += "&field_to_reload=TEST_CI_MANDATORY&sd_cat=" + document.getElementById("SD_CATALOG.TITLE_" + lng + "_hide").value;
      tmp_res = sync_url_ajax_get(str, "");
      
      eval(tmp_res);
      
      if (can_continue == false)
      aValid = 0;
    }
  }
  
  if (aValid == 1)
  {
    // On indique que l'on a sauvegardé la fiche
    isChanged = 0;
    
     if (typeof(window.parent.document.getElementById ('next_call')) != "undefined" && window.parent.document.getElementById ('next_call') != null)
    {
      if (next_call != '')
        window.parent.document.getElementById ('next_call').value = Base64.encode(next_call);
      else 
        window.parent.document.getElementById ('next_call').value = '';
    }
      
    if (typeof(window.parent.document.getElementById ('next_call2')) != "undefined" && window.parent.document.getElementById ('next_call2') != null)
    {
      if (next_call != '')
        window.parent.document.getElementById ('next_call2').value = Base64.encode(next_call);
      else 
        window.parent.document.getElementById ('next_call2').value = '';
    }
  
    var sAction = window.parent.document.forms[form_name].action;
    var sTarget = window.parent.document.forms[form_name].target;
    
    if (window.parent.document.getElementById('action_select') != null)
    window.parent.document.forms[form_name].action += "&action_select=" + urlencode(window.parent.document.getElementById('action_select').value);
    
    if (target != '')
    {
      window.parent.document.forms[form_name].target = target;
      if (is_request == true)
      {
        window.parent.document.forms[form_name].action = window.parent.document.forms[form_name].action.replace("index.php", "iframefiche.php");
        
        AjaxResult = sync_formulaire_ajax_get(window.parent.document.forms[form_name].action, form_name, "POST", "");
        eval(AjaxResult);
        
        if (typeof(errorFound) != "undefined" && errorFound != null && errorFound == true)
          aValid = 0;
        
        window.parent.document.forms[form_name].action = sAction;
        window.parent.document.forms[form_name].target = sTarget;
      }
      else
      {
        window.parent.document.forms[form_name].target = '';
        window.parent.document.forms[form_name].submit();
      }
    }
    else
    //sync_formulaire_ajax_get(window.parent.document.forms[form_name].action, form_name, "POST", "");
    window.parent.document.forms[form_name].submit();

    if (is_double_save == '1')
    {
       var str = window.location.href.replace("#", "");
      window.location.href=str;
    }
  }
  
  return (aValid);
}
 
 
function doDeleteReport (lng, param) 
{
  txt = edit_function_get_label('deletereport');
  txt2 = edit_function_get_label('reportnotsaved');

  if (txt == '')
    return;

  if (param != 1)
  {
    alert (txt2);
  }
  else
  {  
    if (confirm (txt))
    {
      window.parent.document.forms['presentation_file'].submit ();
    }
  }
}


function doDelete (num_row, lng, type_delete, field_unaffect)
{
  txt = edit_function_get_label('detachdocument');
  
  if (txt == '')
    return;
  else if (confirm (txt))
  {
    window.parent.document.forms['editForm2'].elements['delete_row'].value = num_row ; 
    window.parent.document.forms['editForm2'].elements['updatedata'].value = type_delete ; 
    window.parent.document.forms['editForm2'].elements['desaffect_field'].value = field_unaffect ; 
    window.parent.document.forms['editForm2'].submit ();
  }
}


function doSearchList () 
{
  listOfPopups[listOfPopups.length] = window.open ('./include/edit/ed_list.php?@@PARAM@@&@@SESSION@@&DialogID=' + urlencode('{C3071BC4-2C1F-4F15-B018-5449B6D30C83}'), '','scrollbars=yes,status=no,width=800,height=500,top=120,left=120,resizable=yes') ;
}


function popupMemo (sess, id_memo, id_memo_hidden, wordwrap)
{
  PositionX = 200;
  PositionY = 200;

  defaultWidth  = 800;
  defaultHeight = 200;

  if (parseInt(navigator.appVersion.charAt(0)) >= 4)
  {
    var isNN  = (navigator.appName == "Netscape")?1:0;
    var isIE  = (navigator.appName.indexOf("Microsoft") != -1)?1:0;
  }
  var optNN = 'resizable=yes,scrollbars=yes,width=' + defaultWidth + ',height=' + (defaultHeight + 10) + ',left=' + PositionX + ',top=' + PositionY;
  var optIE = 'resizable=yes,scrollbars=yes,width=' + defaultWidth + ',height=' + defaultHeight + ',left=' + PositionX + ',top=' + PositionY;
  var url = 'include/javascript/staff/memo.php?' + sess + '&id_memo=' + urlencode(id_memo) + '&id_memo_hidden=' + urlencode(id_memo_hidden);
  url += '&wordwrap=' + wordwrap;
  
  if (isNN)
  {
    imgWin = window.open(url, 'dlg_memo', optNN);
  }
  else
  {
    imgWin = window.open(url, 'dlg_memo', optIE);
  }
  
  listOfPopups[listOfPopups.length] = imgWin;
}

function setLogoEzv()
{
  document.body.style.marginWidth = 0;
  document.body.style.marginHeight = 0;
  document.body.style.marginTop = 0;
  document.body.style.marginLeft = 0;
  
  document.body.style.backgroundImage = 'url("./Styles/Easyvista/Images/logo-ezv.png")';
  document.body.style.backgroundRepeat = 'no-repeat';
  //document.body.style.backgroundPosition = 'left bottom';
  document.body.style.backgroundPosition = '45px 99%';
  document.body.style.backgroundAttachment = 'fixed';
}

// -- Show/Hide div popup
function divDown_onclick(form_name, tmp_fieldname_js)
{
  hideAlldivDownWithout(form_name, 'divDown_' + tmp_fieldname_js);
  var div = document.getElementById('divDown_' + tmp_fieldname_js);
  if (div != null)
  {
    var divDisplay = div.style.display;
    
    if (divDisplay == 'none')
    var newDisplay = 'block';
    else
    var newDisplay = 'none';
    
    var imgDown = document.getElementById('imgDown_' + tmp_fieldname_js);
    
    if (imgDown.style.Top == null || imgDown.style.Top == "" || imgDown.style.Left == null || imgDown.style.Left == "")
    {
       var _Height = imgDown.style.Height;
       var _Width = imgDown.style.Width;
       if (_Height == "" || _Height == undefined) _Height = 0;
       if (_Width == "" || _Width == undefined) _Width = 0;
       
       div.style.Top = parseInt(glMousePosY) + parseInt(_Height) + 10 + "px";
       div.style.Left = parseInt(glMousePosX) + parseInt(_Width) + 10 + "px";
    }
    else
    {
       div.style.Top = imgDown.style.Top + imgDown.style.Height + 10 + "px";
       div.style.Left = imgDown.style.Left + imgDown.style.Width + 10 + "px";
    }
    
    div.style.display = newDisplay;
  }
}

// -- Hide all div with id = divDown_* without the div with id = avoidDiv
function hideAlldivDownWithout(form_name, avoidDiv)
{
  if (form_name != 'undefined' && form_name != null)
  {
    var form1 = document.getElementById(form_name);
    var aElements = form1.getElementsByTagName('div');
  }
  else
  var aElements = document.getElementsByTagName('div');
  
  if(aElements!=null)
  {
    for(var i=0;i<aElements.length;i++)
    {
      var div_id = aElements[i].id;
      if (div_id.substring(0,8) == 'divDown_' && div_id != avoidDiv)
      {
        aElements[i].style.display = 'none';
      }
    }
  }
  
}

// -- Hide all div with id = divDown_*
function hideAlldivDown(form_name)
{
  if (form_name != 'undefined' && form_name != null)
  {
    var form1 = document.getElementById(form_name);
    var aElements = form1.getElementsByTagName('div');
  }
  else
  var aElements = document.getElementsByTagName('div');
  
  if(aElements!=null)
  {
    for(var i=0;i<aElements.length;i++)
    {
      var div_id = aElements[i].id;
      if (div_id.substring(0,8) == 'divDown_')
      {
        aElements[i].style.display = 'none';
      }
    }
  }
  
}

// -- onMouseOver div popup
function leaveDivDownBlock(event, obj, form_name, tmp_fieldname_js)
{
  var out = false;
  if (isIE)
  {
    if (!obj.contains(event.toElement))
    out = true;
  }
  else
  {
    if (!obj.contains(event.relatedTarget))
    out = true;
  }
  
  if (out)
  {
    if (tmp_fieldname_js != 'undefined' && tmp_fieldname_js != null)
    eval('divDown_onclick("' + form_name + '", "' + tmp_fieldname_js + '")');
    else
    eval(obj.id + '_onclick_block()');
  }
}

// -- onMouseOver div popup
function leaveDivDownGrid(event, obj)
{
  var out = false;
  if (isIE)
  {
    if (!obj.contains(event.toElement))
    out = true;
  }
  else
  {
    if (!obj.contains(event.relatedTarget))
    out = true;
  }
  
  if (out)
  {
    eval(obj.id + '_onclick_grid()');
  }
}

// -- leaveDivDownSearchBox generic
function leaveDivDownSearchBox(event, obj)
{
  var out = false;
  if (isIE)
  {
    if (!obj.contains(event.toElement))
    out = true;
  }
  else
  {
    if (!obj.contains(event.relatedTarget))
    out = true;
  }
  
  if (out)
  {
    obj.style.display = 'none';
  }
}

/**
 * Limitation de la hauteur des memos
 * 
 * @param id_name_span Id du memo
 * @param iHeight Hauteur max
 */
function _detect_overflow(id_name_span, iHeight)
{
  // On empêche la DIV de dépasser une taille définie par l_utilisateur
  var d = document.getElementById(id_name_span);
  var divMaxH = iHeight;
  if (d != null && divMaxH != "" && divMaxH > 0)
  {
    if (d.offsetHeight == 0)
    {
      // Sous IE, la div est créé mais pas remplie la première fois, on laisse un lap de temps s_écouler
      setTimeout("_detect_overflow('" + id_name_span + "', " + iHeight + ")", 500);
    }
    else
    {
      if (d.offsetHeight > divMaxH)
      {
        // On a dépassé la taille limite définie dans la config
        $("#" + id_name_span).height(divMaxH);
        d.style.overflow = "scroll";
      }
    }
  }
}

// -- divDown_searchBox_onclick generic
function divDown_searchBox_onclick(div)
{
  if (div != null && typeof(div) != 'undefined')
  {
    var jDiv = $(div);
    var divDisplay = div.style.display;
    
    if (divDisplay == 'none')
    $('.divDown_searchBox').hide();
    
    if (divDisplay == 'none')
    var newDisplay = 'block';
    else
    var newDisplay = 'none';
    
    var jImgDown = jDiv.siblings('.imgDown_searchBox').first();
    var imgDown = jImgDown[0];
    
    if (imgDown.style.Top == null || imgDown.style.Top == "" || imgDown.style.Left == null || imgDown.style.Left == "")
    {
       var _Height = imgDown.style.Height;
       var _Width = imgDown.style.Width;
       if (_Height == "" || _Height == undefined) _Height = 0;
       if (_Width == "" || _Width == undefined) _Width = 0;
       
       div.style.Top = parseInt(glMousePosY) + parseInt(_Height) + 10 + "px";
       div.style.Left = parseInt(glMousePosX) + parseInt(_Width) + 10 + "px";
    }
    else
    {
       div.style.Top = imgDown.style.Top + imgDown.style.Height + 10 + "px";
       div.style.Left = imgDown.style.Left + imgDown.style.Width + 10 + "px";
    }
    
    div.style.display = newDisplay;
  }
}

function divDown_actions_onclick_block()
{
  var div = document.getElementById('divDown_actions');
  if (div != null)
  {
    var divDisplay = div.style.display;
    
    if (divDisplay == 'none')
    var newDisplay = 'block';
    else
    var newDisplay = 'none';
    
    var imgDown = document.getElementById('imgDown_actions');
    
    if (imgDown.style.Top == null || imgDown.style.Top == "" || imgDown.style.Left == null || imgDown.style.Left == "")
    {
       var _Height = imgDown.style.Height;
       var _Width = imgDown.style.Width;
       if (_Height == "" || _Height == undefined) _Height = 0;
       if (_Width == "" || _Width == undefined) _Width = 0;
       
       div.style.Top = parseInt(glMousePosY) + parseInt(_Height) + 10 + "px";
       div.style.Left = parseInt(glMousePosX) + parseInt(_Width) + 10 + "px";
    }
    else
    {
       div.style.Top = imgDown.style.Top + imgDown.style.Height + 10 + "px";
       div.style.Left = imgDown.style.Left + imgDown.style.Width + 10 + "px";
    }
    
    div.style.display = newDisplay;
  }
}

function divDown_actions_onclick_grid()
{
  var div = document.getElementById('divDown_actions');
  if (div != null)
  {
    var divDisplay = div.style.display;
    // -- Sous IE6 on cache la combo des vues temporairement car les combos sous IE6 passent en premier plan
    if (isIE6)
    { 
      var comboLayout = document.getElementById('comboLayout');
    }
    
    if (divDisplay == 'none')
    {
      var newDisplay = 'block';
      if (isIE6) { comboLayout.style.display = 'none'; }
    }
    else
    {
      var newDisplay = 'none';
      if (isIE6) { comboLayout.style.display = 'block'; }
    }
    
    var imgDown = document.getElementById('imgDown_actions');
    
    if (imgDown.style.Top == null || imgDown.style.Top == "" || imgDown.style.Left == null || imgDown.style.Left == "")
    {
       var _Height = imgDown.style.Height;
       var _Width = imgDown.style.Width;
       if (_Height == "" || _Height == undefined) _Height = 0;
       if (_Width == "" || _Width == undefined) _Width = 0;
       
       div.style.Top = parseInt(glMousePosY) + parseInt(_Height) + 10 + "px";
       div.style.Left = parseInt(glMousePosX) + parseInt(_Width) + 10 + "px";
    }
    else
    {
       div.style.Top = imgDown.style.Top + imgDown.style.Height + 10 + "px";
       div.style.Left = imgDown.style.Left + imgDown.style.Width + 10 + "px";
    }

    div.style.display = newDisplay;
  }
}

function dlg_checkNumeric(field, type, lng, regexp_int, regexp_float)
{
  var res = checkNumeric (field, type, lng, regexp_int, regexp_float);
  if (res == 0)
  window.parent.document.getElementById(field).style.backgroundColor = "yellow";
  else
  window.parent.document.getElementById(field).style.backgroundColor = "";
}

function ed_popup(tmp_fieldname, tmp_name, dialog_guid_href, popup_table)
{
  var field = "";
  
  if (window.parent.document.getElementById(tmp_fieldname + "_hide") != null && 
  window.parent.document.getElementById(tmp_fieldname + "_hide").value != "" && 
  window.parent.document.getElementById(tmp_fieldname + "_hide").value.toUpperCase() != "NULL")
  {
    field = tmp_fieldname + "_hide";
  }
  else if (window.parent.document.getElementById(tmp_name) != null && 
  (window.parent.document.getElementById(tmp_fieldname) == null || 
  (window.parent.document.getElementById(tmp_fieldname).value != "" &&
  window.parent.document.getElementById(tmp_fieldname).value.toUpperCase() != "NULL")))
  {
    field = tmp_name;
  }
  
  ed_popup_dlg(field, dialog_guid_href , session_name + "=" + session_id, popup_table);
}

/**
 * La request en cours d'édition n'existe plus
 */
function qcRequestNotFound(sTheme)
{
  if (!verify_timeout(false))
    return (0);

  alert(edit_function_get_label('qcRequestNotFound'));
  
  window.location.href = main_directory + "index.php?" + session_name + "=" + session_id + "&theme" + sTheme;
}

/**
 * Fermeture des popups ouvertes sur une fiche
 */
function closeDlgPopup()
{
  for (iLenI = listOfPopups.length; iLenI > 0; iLenI--)
  {
    if (listOfPopups[iLenI - 1] != null)
      listOfPopups[iLenI - 1].close();
    
    listOfPopups.pop();
  }
}

/**
 * Fonction de suppression des espaces en début et fin de chaine
 */
function trim(inputString)
{
  // Est-ce une chaine ?
  if (typeof inputString != "string")
  return (inputString);
  
  var retValue = inputString;
  var ch = retValue.substring(0, 1);
  while (ch == " " || ch == "\t")
  {
    // Ltrim
    retValue = retValue.substring(1, retValue.length);
    ch = retValue.substring(0, 1);
  }
  
  ch = retValue.substring(retValue.length-1, retValue.length);
  while (ch == " " || ch == "\t")
  {
    // RTrim
    retValue = retValue.substring(0, retValue.length-1);
    ch = retValue.substring(retValue.length-1, retValue.length);
  }
  
  return (retValue);
}

/**
 * R110110_00004 : Nombre de caractères minimum du commentaire de résolution sur les incidents, hors espace
 */
function checkRequiredMinLengthFields (form_name, form, lng, is_double_save, next_call, target, is_request)
{
  var res = 1;
  
  if (minLengthFields > 0)
  {
    var item = '';
    var editor_id = null;
    var tmp_value = '';
    
    for (var i = 0; i < listOfRequiredMinLengthFields.length; i++)
    {
      item = listOfRequiredMinLengthFields[i];
      
      if (tinyMCE != null)
      editor_id = tinyMCE.get(item);
      else
      editor_id = null;
      
      if (editor_id != null)
      {
        tinyMCE.execInstanceCommand(editor_id, "mceSelectNode");
        tmp_value = trim(tinyMCE.getInstanceById(item).getContent());
      }
      else
      {
        var objTarget = document.getElementById(item);
        if (objTarget != null)
        {
          tmp_value = trim(objTarget.value);
        }
      }
      
      if (tmp_value.length < minLengthFields)
      {
        // Debug
        //alert('minLengthFields : ' + minLengthFields + '\r\nContenu : ' + tmp_value + '\r\nTaille : ' + tmp_value.length);
        alert(edit_function_get_label('qcDescriptionTooShort'));
        return (0);
      }
      
      tmp_value = '';
    }
  }
  
  return res;
}

function dlg_checkDuration(field){
  var val = validDuration($("#" + field.replace('.', '\\.')).val());
  if (val === false)
  {
    window.parent.document.getElementById(field).style.backgroundColor = "yellow";
    alert(edit_function_get_label('checkduration'));
  }else{
    window.parent.document.getElementById(field).style.backgroundColor = "";
    $("#" + field.replace('.', '\\.')).val(val);
  }
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/location/location.js $
// Revision: 12122 $

var locations = [];
var location_max_filter_len = 1000;

function location1(obj_target, obj_target2, session, fullpath, fullpath_separator, root) 
{
	// assing methods
	this.popup                                           = loc_popup1;
  this.popup_request                                   = loc_popup1_request;
	this.popup_filter                                    = loc_popup1_filter;
	this.popup_filter_without_domain                     = loc_popup1_filter_without_domain;
	this.popup_filter_without_domain_with_rootid         = loc_popup1_filter_without_domain_with_rootid;
  this.popup_filter_without_domain_with_rootid_request = loc_popup1_filter_without_domain_with_rootid_request;
	this.popup_with_rootid                               = loc_popup1_with_rootid;
	this.popup_filter_with_rootid                        = loc_popup1_filter_with_rootid;
  this.set_none_empty                                  = loc_none_empty;
  this.set_empty_equal_null                            = loc_empty_equal_null;
  this.select_all_link                                 = loc_select_all_link;
  this.get_guid                                        = loc_get_guid;
  this.change_popup_name                               = loc_popup_name1;
  this.set_perimeter                                   = loc_set_perimeter1;
  this.ajax                                            = loc_ajax;

	// validate input parameters
	if (!obj_target)
		return loc_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return loc_error("Unable to load component : Parameter specified is not a valid target control");

	// text
	this.target = obj_target;
	// Hidden
	this.target2 = obj_target2;
	
	// Main directory
	this.root = root;
	
	// return fullpath ?
	this.fullpath = fullpath;
	this.fullpath_separator = fullpath_separator;
	
	this.session = session;
	
  this.none_empty = 0;
	this.empty_equal_null = 0;
	
	// Nom de la popup
	this.popup_name = 'Popup_js_loc';
	
	// register in global collections
	this.id = locations.length;
	locations[this.id] = this;
	
	this.all_link = 0;
	
	this.getguid = 0;
	
	// Périmètre d'application
	this.perimeter = '';
}

// -- Changement du périmètre d'application
function loc_set_perimeter1(perimeter)
{
  this.perimeter = perimeter;
}

// -- Changement du nom de la popup
function loc_popup_name1(name)
{
  this.popup_name = name;
}

function loc_none_empty(b_val)
{
  // Si none_empty = 1 alors le bouton None retourne Vide sinon il retourne le root
  if (b_val == true)
  this.none_empty = 1;
  else
  this.none_empty = 0;
}

function loc_empty_equal_null(b_val)
{
  // Si empty_equal_null = 1 alors le bouton None retourne NULL comme valuer. Ne fonctionne que si none_empty = 1
  if (b_val == true)
  this.empty_equal_null = 1;
  else
  this.empty_equal_null = 0;
}

function loc_select_all_link(b_val)
{
  // Si none_empty = 1 alors le bouton None retourne Vide sinon il retourne le root
  if (b_val == true)
  this.all_link = 1;
  else
  this.all_link = 0;
}

function loc_get_guid(b_val)
{
  // Si none_empty = 1 alors le bouton None retourne Vide sinon il retourne le root
  if (b_val == true)
  this.getguid = 1;
  else
  this.getguid = 0;
}

function loc_popup1 (str_table,guid,rootid) 
{
	if (rootid != ''){
		var obj_locwindow = window.open(
			this.root + 'include/javascript/staff/location/location.php?guid='+ guid +'&src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
			'&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
			'&fullpath_separator=' + this.fullpath_separator + '&rootId=' + rootid + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null, 
      this.popup_name, 
			'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
		);
	} else {
		var obj_locwindow = window.open(
			this.root + 'include/javascript/staff/location/location.php?guid='+ guid +'&src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
			'&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
			'&fullpath_separator=' + this.fullpath_separator + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null, this.popup_name, 
			'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
		);
	}
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}

function loc_popup1_request(str_table, guid, rootid, request) 
{
	if (rootid != '')
  {
		var obj_locwindow = window.open(
			this.root + 'include/javascript/staff/location/location.php?guid='+ guid +'&src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
			'&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
			'&fullpath_separator=' + this.fullpath_separator + '&rootId=' + rootid + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + 
      '&request=' + request, this.popup_name, 
			'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
		);
	}
  else 
  {
		var obj_locwindow = window.open(
			this.root + 'include/javascript/staff/location/location.php?guid='+ guid +'&src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
			'&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
			'&fullpath_separator=' + this.fullpath_separator + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + 
      '&request=' + request, this.popup_name, 
			'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
		);
	}
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}

function loc_popup1_filter (str_table, str_filter) 
{
	if (str_filter.length <= location_max_filter_len)
  {
    var obj_locwindow = window.open(
		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null, 
		  this.popup_name, 
		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	  );
	  obj_locwindow.opener = window;
	  obj_locwindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', str_filter);
    
    var obj_locwindow = window.open(
      this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
      '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&all_link=' + this.all_link + '&getguid=' + this.getguid +
      '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null, 
      this.popup_name, 
      'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    obj_locwindow.opener = window;
    obj_locwindow.focus();
  }
}

function loc_popup1_filter_without_domain (str_table, str_filter, without_domain, database) 
{
	if (str_filter.length <= location_max_filter_len)
  {
    var obj_locwindow = window.open(
		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + 
      '&getguid=' + this.getguid + '&all_link=' + this.all_link,
		  this.popup_name, 
		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	  );
	  obj_locwindow.opener = window;
	  obj_locwindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', str_filter);
    
    var obj_locwindow = window.open(
      this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
      '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
      '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + 
      '&getguid=' + this.getguid + '&all_link=' + this.all_link,
      this.popup_name, 
      'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    obj_locwindow.opener = window;
    obj_locwindow.focus();
  }  
}

function loc_popup1_filter_without_domain_with_rootid (str_table, str_filter, without_domain, rootid, database) 
{
  var obj_locwindow;
  if (str_filter.length <= location_max_filter_len)
  {
    if (rootid != '')
    {
	    obj_locwindow = window.open(
  		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
  		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
  		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + '&rootId=' + rootid + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
  		  this.popup_name, 
  		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	    );
	  }
    else
    {
      obj_locwindow = window.open(
  		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
  		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
  		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
  		  this.popup_name, 
  		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	    );
    }
	  obj_locwindow.opener = window;
	  obj_locwindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', str_filter);
    
    if (rootid != '')
    {
      obj_locwindow = window.open(
        this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
        '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
        '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + '&rootId=' + rootid + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
        this.popup_name, 
        'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
      );
    }
    else
    {
      obj_locwindow = window.open(
        this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
        '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + 
        '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
        this.popup_name, 
        'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
      );
    }
    obj_locwindow.opener = window;
    obj_locwindow.focus();
  }
}

function loc_popup1_filter_without_domain_with_rootid_request (str_table, str_filter, without_domain, rootid, database, request) 
{
  var obj_locwindow;
  
  if (str_filter.length <= location_max_filter_len)
  {
    if (rootid != '')
    {
	    obj_locwindow = window.open(
  		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
  		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + '&request=' + request +
  		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + '&rootId=' + rootid + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
  		  this.popup_name, 
  		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	    );
	  }
    else
    {
      obj_locwindow = window.open(
  		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
  		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + '&request=' + request + 
  		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
  		  this.popup_name, 
  		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	    );
    }
	  obj_locwindow.opener = window;
	  obj_locwindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', str_filter);
    
    if (rootid != '')
    {
      obj_locwindow = window.open(
        this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
        '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + '&request=' + request +
        '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + '&rootId=' + rootid + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
        this.popup_name, 
        'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
      );
    }
    else
    {
      obj_locwindow = window.open(
        this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&database=' + database + '&perimeter=' + this.perimeter +
        '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + '&without_domain=' + without_domain + '&request=' + request + 
        '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + 
        '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
        this.popup_name, 
        'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
      );
    }
    obj_locwindow.opener = window;
    obj_locwindow.focus();
  }
}

function loc_popup1_with_rootid (str_table,guid, rootId) 
{
	var obj_locwindow = window.open(
		this.root + 'include/javascript/staff/location/location.php?guid='+ guid +'&src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
		'&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + 
    '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null +
		'&fullpath_separator=' + this.fullpath_separator + '&rootId=' + rootId + '&getguid=' + this.getguid + '&all_link=' + this.all_link, this.popup_name,
		'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}

function loc_popup1_filter_with_rootid (str_table, str_filter, rootId) 
{
	if (str_filter.length <= location_max_filter_len)
  {
    var obj_locwindow = window.open(
		  this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
		  '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + 
      '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null +
		  '&fullpath_separator=' + this.fullpath_separator + '&filter=' + str_filter + '&rootId=' + rootId + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
		  this.popup_name, 
		  'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	  );
	  obj_locwindow.opener = window;
	  obj_locwindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', str_filter);
    
    var obj_locwindow = window.open(
      this.root + 'include/javascript/staff/location/location.php?src=' + str_table + '&id=' + this.id + '&perimeter=' + this.perimeter +
      '&node=' + this.target2.value + '&' + this.session + '&fullpath=' + this.fullpath + 
      '&none_empty=' + this.none_empty + '&empty_equal_null=' + this.empty_equal_null +
      '&fullpath_separator=' + this.fullpath_separator + '&session_filter_id=' + this.id + '&rootId=' + rootId + '&getguid=' + this.getguid + '&all_link=' + this.all_link,
      this.popup_name, 
      'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    obj_locwindow.opener = window;
    obj_locwindow.focus();
  }
}

function loc_error (str_message) 
{
	alert ("Location : " + str_message);
	return null;
}

function loc_ajax(param_name, param_value)
{
  filename = get_main_directory();
  filename += 'include/javascript/staff/location/location_ajax.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&id=' + this.id;
  
  if (document.forms["frm_loc_" + this.id] == null)
  {
    var frm_loc = document.createElement("FORM");
    frm_loc.setAttribute("name", "frm_loc_" + this.id);
    frm_loc.setAttribute("action",filename);
    frm_loc.setAttribute("method", "post");
    frm_loc.setAttribute("target", "_blank");

    document.body.appendChild(frm_loc);
    document.forms["frm_loc_" + this.id] = frm_loc;
  }  
  
  if (document.getElementById(param_name) == null)
  {
    var inputFrm = document.createElement("INPUT");
      inputFrm.name = param_name;
      inputFrm.id = param_name;
      inputFrm.type = "hidden";
      inputFrm.value = param_value;
      document.forms["frm_loc_" + this.id].appendChild(inputFrm);
  }
  else
  document.getElementById(param_name).value = param_value;

  sync_formulaire_ajax(filename, "frm_loc_" + this.id, "POST", "");
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/hint.js $
// Revision: 16275 $

var IB = new Object;
var xOffset = 0;
var yOffset = -3;
var xOffsetShort = 5;
var yOffsetShort = 5;

// Initialisation de la zone de hint
// Couleur verte
IB.ColTexte = "1D293D";
IB.ColFond = "#B3FFB3";
IB.ColContour = "#C2EAF0";
IB.NbPixel = 1;

// Couleur jaune pastel comme hint windows
IB.ColTexte = "#3A3A3A";
IB.ColFond = "#FFFFE1";
IB.ColContour = "#000000";
IB.NbPixel = 1;

IB.MaxHeightPct = '60%';
IB.MaxHeight = 0.6;
IB.MaxWidthPct = '40%';
IB.MaxWidth = 0.4;

// -- Equivalent PHP : Convertit tous les caractères éligibles en entités HTML 
function htmlentities(str) 
{
   var ta=document.createElement("textarea");
   ta.innerHTML = str;
   return ta.innerHTML;
}

// -- Eqivalent PHP : Supprime les balises HTML et PHP d'une chaîne
function strip_tags($text)
{
  return $text.replace(/<\/?[^>]+>/gi, '');
}

        
function AffBulle(texte)
{
  AffBulleWithColor(texte, IB.ColTexte, IB.ColFond, IB.ColContour, IB.NbPixel);
}

function AffBulleWithColor(texte, ColTexte, ColFond, ColContour, NbPixel)
{
	var reg = new RegExp("'", "g");
	texte.replace(reg, "\'");

  var texte_length = texte.length;
  if (strip_tags(texte).length == 0)
  {
    texte = htmlentities(texte);
  }
  
  contenu = '';
  if (texte.length > 0)
  contenu="<TABLE width_='100%' border=0 cellspacing=1 cellpadding="+NbPixel+" style='border: 1px solid "+ColContour+";'><TR><TD><TABLE border=0 cellpadding=2 cellspacing=0 bgcolor='"+ColFond+"'><TR><TD class='hint_text' style='color: "+ColTexte+";'>"+texte+"</TD></TR></TABLE></TD></TR></TABLE>";
  
  contenu = contenu.replace(/<br><tbody/gi, "<tbody");
  contenu = contenu.replace(/<\/tbody><br>/gi, "</tbody>");
  contenu = contenu.replace(/<br><tr>/gi, "<tr>");
  contenu = contenu.replace(/<\/tr><br>/gi, "</tr>");
  contenu = contenu.replace(/<br><td/gi, "<td");
  contenu = contenu.replace(/<\/td><br>/gi, "</td>");
  
  if (texte.length < 100)
  {
    xOffset = xOffsetShort;
    yOffset = yOffsetShort;
  }
  
  var zIndexHint = 20000000;
  
  if (document.getElementById && document.getElementById("bulle") != null) 
  {
    document.getElementById("bulle").innerHTML = contenu;
    
    var aLinks = $("#bulle").find("a[href]");
    for (i = aLinks.length - 1; i >= 0; i--)
    {
      var aLink = $(aLinks[i]);
      if (aLink.attr("href").indexOf("autoconnect_mail.php") != -1)
        aLink.attr("href", "#");
    }
    
    document.getElementById("bulle").style.visibility = "visible";
    document.getElementById("bulle").style.zIndex = zIndexHint;
    document.getElementById("bulle").style.backgroundColor = ColFond ;
  }
  
  //if (!isIE || isIE6) _setHeightWidth();
  
  _setPosition();
  
}

function _getScroll() 
{
    var dd = document.documentElement, db = document.body;
    if (dd && (dd.scrollTop || dd.scrollLeft)) {
        return [dd.scrollTop, dd.scrollLeft];
    } else if (db) {
        return [db.scrollTop, db.scrollLeft];
    } else {
        return [0, 0];
    }
}

function _getScrollLeft() 
{
    return _getScroll()[1];
}

function _getScrollTop() 
{
    return _getScroll()[0];
}

function _setPosition()
{
  // Sous IE on force le recalcul de la position de la souris
  if (isIE || isIE7)
  {
    var x = event.clientX + _getScrollLeft();
    var y = event.clientY + _getScrollTop();
    
    glMousePosX = parseInt(x);
    glMousePosY = parseInt(y);
  }
  
  var finalPosX = glMousePosX;      
  
  if (finalPosX < 0) finalPosX = 0;
  
  var bulle_left = finalPosX + xOffset;
  var bulle_top = glMousePosY + yOffset;
  
  if (document.getElementById && document.getElementById("bulle") != null) 
  {
    if ((window.innerHeight + window.pageYOffset - glMousePosY) < document.getElementById("bulle").offsetHeight) bulle_top = bulle_top - yOffset - document.getElementById("bulle").offsetHeight;
    if (bulle_top < 0) bulle_top = yOffset;
    document.getElementById("bulle").style.top = bulle_top + "px";
    
    if ((window.innerWidth + window.pageXOffset - finalPosX) < document.getElementById("bulle").offsetWidth) bulle_left = bulle_left - document.getElementById("bulle").offsetWidth;
    if (bulle_left < 0) bulle_left = xOffset;
    document.getElementById("bulle").style.left = bulle_left + "px";
  }
}

function _setHeightWidth()
{
  document.getElementById("bulle").style.height = '';
  document.getElementById("bulle").style.width = IB.MaxWidthPct;
  
  if (document.getElementById("bulle").clientHeight > (IB.MaxHeight*screen.availHeight))
  document.getElementById("bulle").style.height = IB.MaxHeightPct;
}

function HideBulle(e)
{
  var bulle = document.getElementById("bulle");

  if (bulle == null)
    return;
    
  if (e != undefined)
  {
    if (isIE)
    {
      var isContains = bulle.contains(e.toElement);
    }
    else
    {
      var isContains = bulle.contains(e.relatedTarget);
    }
    
    if (isContains) return;
    
    //alert(e.target.id + ' > ' + e.relatedTarget.id + ' > ' + cont);
  }
  
  if (document.getElementById && document.getElementById("bulle") != null)
  {
    document.getElementById("bulle").style.visibility = "hidden";
    $("#bulle").trigger('isHidden');
  }
}

function MoveBulle()
{
  _setPosition();

}

function InitBulle(ColTexte, ColFond, ColContour, NbPixel)
{
	/*
	IB.ColTexte = ColTexte;
	IB.ColFond = ColFond;
	IB.ColContour = ColContour;
	IB.NbPixel = NbPixel;
	*/
		
	if (document.getElementById)
	{
		// div for bulle (hint)
    if (document.getElementById("bulle") == null)
    document.write("<DIV id='bulle' style='position:absolute; top:0; left:0; visibility:hidden; overflow_:auto; max-height:"+IB.MaxHeightPct+"; max-width:"+IB.MaxWidthPct+";' onMouseOut='HideBulle(event)'></DIV>");
    
    // div for full (hint) in popup
    if (document.getElementById("hints") == null)
    document.write("<DIV id='hints' style='position:absolute; display:none; top:0; left:0; visibility:hidden; overflow:hidden;'></DIV>");
	}
}

// on cache un élément
function HideElt(name)
{
  if (document.getElementById && document.getElementById(name) != null)
	  document.getElementById(name).style.visibility = "hidden";
  else if (document.layers && document.layers[name] != null)
    document.layers[name].visibility="hide";
  else if (document.all && document.all[name] != null)
	  document.all[name].style.visibility="hidden";
}

// on affiche un élément
function ShowElt(name)
{
  if (document.getElementById && document.getElementById(name) != null) 
    document.getElementById(name).style.visibility = "visible";
  else if (document.layers && document.layers[name] != null) 
    document.layers[name].visibility = "show";
  else if (document.all && document.all[name] != null)
    document.all[name].style.visibility = "visible";
}

// ----------------------------- Autre méthode --------------------------

var horizontal_offset = "9px"; //horizontal offset of hint box from anchor link
var vertical_offset = "0"; //vertical offset of hint box from anchor link.
var ie=(document.all)?true:false;
var ns6 = document.getElementById&&!document.all;
var hint_created = false;

function getposOffset(what, offsettype)
{
  var totaloffset = (offsettype=="left")? what.offsetLeft : what.offsetTop;
  var parentEl = what.offsetParent;
  while (parentEl != null)
  {
    totaloffset = (offsettype=="left") ? totaloffset + parentEl.offsetLeft : totaloffset + parentEl.offsetTop;
    parentEl = parentEl.offsetParent;
  }
  return (totaloffset);
}

function showhint(menucontents, obj, e, tipwidth)
{
  if (hint_created == false)
  {
    if (document.body == null)
    return;
    
    createhintbox();
    hint_created = true;
  }
  
  if ((ie || ns6) && document.getElementById("hintbox"))
  {
    dropmenuobj = document.getElementById("hintbox");
    dropmenuobj.innerHTML = menucontents;
    dropmenuobj.style.left = dropmenuobj.style.top=-500;
    if (tipwidth != "")
    {
      dropmenuobj.widthobj = dropmenuobj.style;
      dropmenuobj.widthobj.width = tipwidth;
    }
    dropmenuobj.x = getposOffset(obj, "left");
    dropmenuobj.y = getposOffset(obj, "top");
    dropmenuobj.style.left = dropmenuobj.x + "px";
    dropmenuobj.style.top = dropmenuobj.y + obj.offsetHeight + "px";
    dropmenuobj.style.visibility = "visible";

    obj.onmouseout = hidetip;
  }
}

function hidetip(e)
{
  dropmenuobj.style.visibility = "hidden";
  dropmenuobj.style.left = "-500px";
}

function createhintbox()
{
  var divblock = document.createElement("div");
  divblock.setAttribute("id", "hintbox");
  document.body.appendChild(divblock);
  
  // Style
  dropmenuobj = document.getElementById("hintbox");
  dropmenuobj.style.position = "absolute";
  dropmenuobj.style.top = "0px";
  dropmenuobj.style.backgroundColor = "lightyellow";
  dropmenuobj.style.width = "150px";
  dropmenuobj.style.padding = "3px";
  dropmenuobj.style.border = "1px solid black";
  dropmenuobj.style.font = "normal 11px Verdana";
  dropmenuobj.style.lineHeight = "18px";
  dropmenuobj.style.zindex = "100";
  dropmenuobj.style.borderRight = "2px solid black";
  dropmenuobj.style.borderBottom = "2px solid black";
  dropmenuobj.style.visibility = "hidden";
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/upload/upload.js $
// Revision: 14131 $

var uploads = [];

// -------------------------- Upload initial ------------------------

function upload1(obj_target, obj_target2, obj_target3, session, obj_autosav) 
{
	// assing methods
	this.popup        = upload_popup1;
	// validate input parameters
	if (!obj_target)
		return upload_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return upload_error("Unable to load component : Parameter specified is not a valid target control");

	// text
	this.target = obj_target;
	// Hidden
	this.target2 = obj_target2;
	
	this.target3 = obj_target3;
	this.session = session;
	this.autosave = obj_autosav;
	
	// register in global collections
	this.id = uploads.length;
	uploads[this.id] = this;
}

function upload_popup1 () 
{
	var obj_locwindow = window.open(
		'include/javascript/staff/upload/upload_file.php?id=' + this.id + 
		 '&' + this.session , 'Popup_js_upload', 'width=700,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}


function upload_error (str_message) 
{
	alert ('Upload : ' + str_message);
	return null;
}


// -------------------------- Upload de pictures ------------------------

function upload3(obj_target, session, path, path_url) 
{
	// assing methods
	this.popup        = upload_popup3;
	// validate input parameters
	if (!obj_target)
		return upload_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return upload_error("Unable to load component : Parameter specified is not a valid target control");

	this.target = obj_target;
	this.session = session;
  this.path = path;
  this.path_url = path_url;
	
	// register in global collections
	this.id = uploads.length;
	uploads[this.id] = this;
}

function upload_popup3 () 
{
	// --Obsolete
    var obj_locwindow_old = window.open(
		'include/javascript/staff/upload/upload_file.php?id=' + this.id + 
		 '&' + this.session + '&path_upload=pictures' , 'Popup_js_upload', 'width=700,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
  
  var obj_locwindow = window.open(
		'include/components/staff/maps_choose_library.php?id=' + this.id + 
		 '&' + this.session + '&path_upload=pictures&path=' + this.path + '&path_url=' + this.path_url , 'Popup_js_upload', 'width=700,height=300'+
		',scrollbars=no,status=no,resizable=no,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}

// -------------------- Upload utilisé par les assistants ----------------------

function upload2(obj_target, obj_target2, session) 
{
	// assing methods
	this.popup              = upload_popup2;
  this.popup_with_delete  = upload_popup_with_delete2;
  
	// validate input parameters
	if (!obj_target)
		return upload_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return upload_error("Unable to load component : Parameter specified is not a valid target control");

	// text
	this.target = obj_target;
	// Hidden
	this.target2 = obj_target2;
	
	this.session = session;
	
	// register in global collections
	this.id = uploads.length;
	uploads[this.id] = this;
}

function upload_popup2() 
{
	var obj_locwindow = window.open('include/javascript/staff/upload/upload_file2.php?id=' + this.id + 
		 '&' + this.session , 'Popup_js_upload', 'width=700,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}

function upload_popup_with_delete2(del_id) 
{
	var obj_locwindow = window.open('include/javascript/staff/upload/upload_file2.php?id=' + this.id + 
		 '&' + this.session + '&action=del_doc&doc_id=' + del_id, 'Popup_js_upload', 'width=700,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_locwindow.opener = window;
	obj_locwindow.focus();
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/list_query/list_query.js $
// Revision: 12764 $

var list_queries = [];
var list_max_filter_len = 1000;

function list_query (query_guid, obj_target, obj_target2, session, fullpath, fullpath_separator, root) 
{
	// assing methods
	this.popup                  = lis_popup1;
	this.filter                 = lis_filter1;
	this.popup_filter           = lis_popup_filter1;
	this.popup_filter_name      = lis_popup_filter_name1;
	this.popup_add_filter_name  = lis_popup_add_filter_name1;
	this.popup_filter_column    = lis_popup_filter_column1;
	this.set_params             = lis_set_params1;
  this.set_url_params         = lis_set_url_params1;
	this.change_popup_name      = lis_popup_name1;
	this.dynamic                = lis_dynamic;
  this.ajax                   = lis_ajax;
  this.set_avoid_duplication  = lis_avoid_duplication;
  
	// validate input parameters
	if (!obj_target)
		return lis_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return lis_error("Unable to load component : Parameter specified is not a valid target control");
	
	// guid
	this.queryGUID = query_guid ;
	
	// text
	this.target = obj_target;
	// Hidden
	this.target2 = obj_target2;
	
	// Main directory
	this.root = root;
	
	// return fullpath ?
	this.fullpath = fullpath;
	this.fullpath_separator = fullpath_separator;
	
	this.session = session;
	
	this.params = '';
	
	this.p_filter = '';
  
  // Enlève les enregistrements déjà présent de la requête SQL pour les tables de liaison
  this.avoid_duplication = '';
	
	// Nom de la popup
	this.popup_name = 'Popup_js_list_query';
	
	// register in global collections
	this.id = list_queries.length;
	list_queries[this.id] = this;	
}

// -- Changement du nom de la popup
function lis_popup_name1 (name)
{
  this.popup_name = name;
}


// -- Filtre
function lis_filter1 (filter)
{
  this.p_filter = filter;
}

// -- Paramètres complémentaires
function lis_set_params1 (array_params)
{
  for (i = 0, this.params = ''; i < array_params.length; i++)
	{
    this.params += '&param_' + i + '=' + array_params[i][0] + '/' + array_params[i][1];
  }
}

// -- Paramètres complémentaires URL
function lis_set_url_params1 (array_params)
{
  for (i = 0, this.params = ''; i < array_params.length; i++)
  {
    this.params += '&' + array_params[i][0] + '=' + array_params[i][1];
  }
}


function list_query_add (query_guid, session, id_main) 
{
	this.popup = popup_add;
	this.set_params = lis_set_params1;
	
	this.queryGUID = query_guid;
	this.main_id = id_main;
	this.session = session;
	
	this.params = '';
  
  // Enlève les enregistrements déjà présent de la requête SQL pour les tables de liaison
  this.avoid_duplication = '';
  
	// register in global collections
	this.id = list_queries.length;
	list_queries[this.id] = this;
}

// [VG] cette fonction ouvre la popup et envoie les variables dans l'URL
// Param1: Nom de la table si elle est différente du vrai nom de table (alias)
// Param2: ID correspondant au champ <input type="hidden" ... > du bénéficiaire pour en récupérer sa value (RECIPIENT_ID) (QuickCall)
// Param3: ID correspondant au champ <input type="hidden" ... > du demandeur pour en récupérer sa value (REQUESTOR_ID) (QuickCall)
function lis_popup1 (str_table, recipient_filter, requestor_filter) 
{
  var recipient_id = null;
  if (recipient_filter != undefined && window.document.getElementById(recipient_filter) != null)
  recipient_id = window.document.getElementById(recipient_filter).value;
  
  var requestor_id = null;
  if (requestor_filter != undefined && window.document.getElementById(requestor_filter) != null)
  requestor_id = window.document.getElementById(requestor_filter).value;
  
	var obj_liswindow = window.open(
		this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
		'&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params +
		'&tablename=' + str_table + '&recipient_id=' + recipient_id + '&requestor_id=' + requestor_id, this.popup_name, 'width=600, height=600' +
		', scrollbars=yes, status=no, resizable=yes, top=25, left=200, dependent=yes, alwaysRaised=yes'
	);
	obj_liswindow.opener = window;
	obj_liswindow.focus();
}


function popup_add (str_table, pk_table) 
{
	var obj_liswindow = window.open(
		'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&sortField=0' + '&pk_table=' + pk_table + 
		'&postz=1' + '&' + this.session +'&insert=1&id='+ this.id + this.avoid_duplication + this.params +'&tablename=' + str_table + '&q2_id='+this.main_id, this.popup_name, 'width=600,height=600'+
		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_liswindow.opener = window;
	obj_liswindow.focus();
}


function lis_popup_filter1 (filter, location_table) 
{
  if (filter == '')
  filter = this.p_filter;
  
  if (filter.length <= list_max_filter_len)
  {
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&filter=' + filter + '&location_table=' + location_table, 
      this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', filter);
    
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&session_filter_id=' + this.id + '&location_table=' + location_table, 
      this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}

function lis_popup_filter_column1 (filter, location_table, popup_name, without_domain, column) 
{
  if (filter == '')
  filter = this.p_filter;
  
  if (filter.length <= list_max_filter_len)
  {
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&filter=' + filter + '&location_table=' + location_table + 
      '&popup_name=' + popup_name + '&without_domain=' + without_domain + '&column=' + column , this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', filter);
    
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&session_filter_id=' + this.id + '&location_table=' + location_table + 
      '&popup_name=' + popup_name + '&without_domain=' + without_domain + '&column=' + column , this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}

function lis_popup_filter_name1 (filter, location_table, popup_name, without_domain)
{
  if (filter == '')
  filter = this.p_filter;
  
  if (filter.length <= list_max_filter_len)
  {
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&filter=' + filter + '&location_table=' + location_table + 
      '&popup_name=' + popup_name + '&without_domain=' + without_domain , this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', filter);
    
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID +'&search=' + encodeURIComponent(this.target.value) + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&session_filter_id=' + this.id + '&location_table=' + location_table + 
      '&popup_name=' + popup_name + '&without_domain=' + without_domain , this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}


function lis_popup_add_filter_name1 (filter, location_table, popup_name, without_domain, column)
{
	if (filter.length <= list_max_filter_len)
  {
    var obj_liswindow = window.open(
		  this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID + '&sortField=0' + 
		  '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&filter=' + filter + '&location_table=' + location_table + 
		  '&popup_name=' + popup_name + '&without_domain=' + without_domain + '&column=' + column + '&is_add=true', this.popup_name, 'width=600,height=600'+
		  ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	  );
	  obj_liswindow.opener = window;
	  obj_liswindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('filter', filter);
    
    var obj_liswindow = window.open(
      this.root + 'include/javascript/staff/list_query/list_query.php?guid='+ this.queryGUID + '&sortField=0' + 
      '&postz=1' + '&' + this.session +'&id=' + this.id + this.avoid_duplication + this.params + '&session_filter_id=' + this.id + '&location_table=' + location_table + 
      '&popup_name=' + popup_name + '&without_domain=' + without_domain + '&column=' + column + '&is_add=true', this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}


function lis_dynamic (q, search, column_title)
{
  // column_title : nom des colonnes séparé par des ;
  
  if (q.length <= list_max_filter_len)
  {
    var obj_liswindow = window.open(
  		'include/javascript/staff/list_query/list_query.php?list_query=' + q + '&search=' + encodeURIComponent(search) + '&column_title=' + column_title +
  		'&postz=1' + '&' + this.session +'&id='+ this.id + this.avoid_duplication + this.params, this.popup_name, 'width=600,height=600'+
  		',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
  	);
  	obj_liswindow.opener = window;
  	obj_liswindow.focus();
  }
  else
  {
    // stockage du filtre dans la session PHP
    this.ajax('q', q);
    
    var obj_liswindow = window.open(
      'include/javascript/staff/list_query/list_query.php?list_query=q&search=' + encodeURIComponent(search) + '&column_title=' + column_title +
      '&postz=1' + '&' + this.session +'&id='+ this.id + this.avoid_duplication + this.params, this.popup_name, 'width=600,height=600'+
      ',scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
    );
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}

function lis_error (str_message) 
{
	alert ("List_query : " + str_message);
	return null;
}

// -- stockage du filtre
function lis_ajax(param_name, param_value)
{
  filename = get_main_directory();
  filename += 'include/javascript/staff/list_query/list_query_ajax.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&id=' + this.id;
  
  if (document.forms["frm_list_" + this.id] == null)
  {
    var frm_list = document.createElement("FORM");
    frm_list.setAttribute("name", "frm_list_" + this.id);
    frm_list.setAttribute("id", "frm_list_" + this.id);
    frm_list.setAttribute("action",filename);
    frm_list.setAttribute("method", "post");
    frm_list.setAttribute("target", "_blank");

    document.body.appendChild(frm_list);
    //document.forms["frm_list_" + this.id] = frm_list;
  }  
  
  if (document.getElementById(param_name + this.id) == null)
  {
    var inputFrm = document.createElement("INPUT");
      inputFrm.name = param_name + this.id;
      inputFrm.id = param_name + this.id;
      inputFrm.type = "hidden";
      inputFrm.value = param_value;
      document.forms["frm_list_" + this.id].appendChild(inputFrm);
  }
  else
    document.getElementById(param_name + this.id).value = param_value;

  sync_formulaire_ajax(filename, "frm_list_" + this.id, "POST", "");
}

/**
 * @desc set_avoid_duplication : Méthode permettant d'enlever les enregistrements déjà présents dans la table de liaison
 * @param bool (boolean) : permet d'ajouter un flag dans l'URL pour activer la fonctionnalité
 * @author VG
 */
function lis_avoid_duplication(bool)
{
  if (bool == true)
  {
    this.avoid_duplication = "&avoid_duplication=true";
  }
  else if (bool == false)
  {
    this.avoid_duplication = "&avoid_duplication=false";
  }
}// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/cmdb_view.js $
// Revision: 12122 $

var cmdb_views = [];

function cmdb_view (obj_target, obj_target2, session, root) 
{
	// assing methods
	this.cmdb_view  = cmdb_draw;
	this.set_ci     = cmdb_view_set_ci;
	this.set_parent = cmdb_view_set_parent;
	
	// validate input parameters
	if (!obj_target)
		return cmdb_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return cmdb_error("Unable to load component : Parameter specified is not a valid target control");
	
	// text
	this.target = obj_target;
	// Hidden
	this.target2 = obj_target2;
	
	// Main directory
	this.root = root;
	
	this.session = session;
	
	this.params = '';
	
	// Nom de la popup
	this.popup_name = 'Popup_js_cmdb';
	
	// register in global collections
	this.id = cmdb_views.length;
	cmdb_views[this.id] = this;	
}

// Affichage graphique
function cmdb_draw(select, value1, value2, tablename, requestid)
{
  if (document.getElementById(value1) && document.getElementById(value1).value != '')
  value = document.getElementById(value1).value;
  else if (document.getElementById(value2) && document.getElementById(value2).value != '')
  value = document.getElementById(value2).value;
  else if (this.target2 != null && this.target2.value != null)
  value = this.target2.value;
  else
  value = "";
  
  if (tablename.replace(' ', '').toUpperCase() == 'SD_REQUEST' && select == "1")
  {
    var obj_liswindow = window.open(
	    this.root + 'view_ci_graph.php?' + this.session + '&ciViewId=' + this.id + '&requestid=' + requestid + '&id=' + value, 
      'view_ci', 'width=600, height=600, scrollbars=yes, status=no, resizable=yes, top=25, left=200, dependent=yes, alwaysRaised=yes'
    );
    obj_liswindow.opener = window;
	  obj_liswindow.focus();
  }
  else if (value != "")
  {
    var obj_liswindow = window.open(
      this.root + 'view_ci_graph.php?' + this.session + '&ciViewId=' + this.id + '&id=' + value, 
      'view_ci', 'width=600, height=600, scrollbars=yes, status=no, resizable=yes, top=25, left=200, dependent=yes, alwaysRaised=yes'
    );
    obj_liswindow.opener = window;
    obj_liswindow.focus();
  }
}

// -- fonction modifiant la valeur de la fenêtre parent
function cmdb_view_set_ci(CiId)
{
  this.target2.value = CiId;

  window.onerror = cmdb_ViewNoError;

  var name = this.target.name.replace(".", "_");
  var func = eval("change_" + name);
  if (typeof(func) != "undefined")
    func();
}

// -- fonction modifiant la valeur de la fenêtre parent
function cmdb_view_set_parent(CiId)
{
  this.target2.value = CiId;

  window.onerror = cmdb_ViewNoError;

  var name = this.target.name.replace(".", "_");
  var func = eval("change_" + name);
  if (typeof(func) != "undefined")
    func();

  // Sauvegarde de la fiche
  saveFormIFrame("editForm", "FR", false, "", true);
  saveFormIFrame("editForm2", "FR", false, "", true);
  
  // Rechargement de la page
  window.location.href = window.location.href.replace("#", "");
}

function cmdb_error(str_message) 
{
	alert ("CMDB View : " + str_message);
	return null;
}

function cmdb_ViewNoError()
{
  window.close();
  return (true);
}

// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/lang/lang.js $
// Revision: 12264 $

var arr_lang = [];

function lang1(session, root, main_target, array_lang)
{
	// assing methods
	this.popup              = lang_popup1;
	this.popup_maxlength    = lang_popup_maxlength1;
	this.change_popup_name  = lang_popup_name1;
	this.add_tag            = lang_add_tag1;
  this.Set_WYSIWYG        = lang_Set_WYSIWYG;
  this.ajax               = lang_ajax;

	// validate input parameters
	if (!main_target)
		return lang_error("Unable to load component : No target control specified");
	if (main_target.value == null)
		return lang_error("Unable to load component : Parameter specified is not a valid target control");

	// text
	this.main_target = main_target;
	this.array_lang = array_lang;
	this.array_length = array_lang.length;

	// liste des langue
	for (i = 0, this.list_lang = ''; i < this.array_length; i++)
	{
	  if (i > 0)
	  this.list_lang += ',';
	  
	  this.list_lang += lang_escape_ezv(array_lang[i][0]);
	}
	
	// Main directory
	this.root = root;
	
	this.session = session;
	
	// Nom de la popup
	this.popup_name = 'Popup_js_lang';
	
	// on n'ajoute pas de tag
	this.tag = 0;
  
  // mode WYSIWYG inactif par défaut
  this.wysiwyg = 'false';
	
	// register in global collections
	this.id = arr_lang.length;
	arr_lang[this.id] = this;
}

// -- Fonction d'échappement des caractères en javascript
function lang_escape_ezv(str)
{
  str = encodeURIComponent(str);
  
  /*while (str.indexOf("+") != -1)
  {
    str = str.replace("+", "%2B");
  }*/

  return (str);
}

// -- Mode WYSIWYG actif / inactif
function lang_Set_WYSIWYG(val)
{
  if (val == true)
  this.wysiwyg = 'true';
  else
  this.wysiwyg = 'false';
}

// -- Ajout ou non de tag
function lang_add_tag1(val)
{
  this.tag = 1;
  this.ajax('tag', val);
}

// -- Changement du nom de la popup
function lang_popup_name1(name)
{
  this.popup_name = name;
}

function lang_popup1 (readonly, type_field) 
{
	var obj_langwindow = window.open(
		this.root + 'include/javascript/staff/lang/lang.php?id=' + this.id + '&' + this.session+ '&readonly=' + readonly 
		+ '&type_field=' + type_field + '&list_lang=' + this.list_lang + '&tag=' + this.tag + '&wysiwyg=' + this.wysiwyg, 
    this.popup_name, 'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_langwindow.opener = window;
	obj_langwindow.focus();
}

function lang_popup_maxlength1 (readonly, type_field, maxlength) 
{
	var obj_langwindow = window.open(
		this.root + 'include/javascript/staff/lang/lang.php?id=' + this.id + '&' + this.session+ '&readonly=' + readonly 
		+ '&type_field=' + type_field + '&list_lang=' + this.list_lang + '&maxlength=' + maxlength + '&tag=' + this.tag + '&wysiwyg=' + this.wysiwyg, 
    this.popup_name, 'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_langwindow.opener = window;
	obj_langwindow.focus();
}

function lang_error (str_message) {
	alert ("Lang : "+ str_message);
	return null;
}

// -- stockage du filtre
function lang_ajax(param_name, param_value)
{
  filename = get_main_directory();
  filename += 'include/javascript/staff/lang/lang_ajax.php?';
  filename += get_session_name();
  filename += '=';
  filename += get_session_id();
  filename += '&id=' + this.id;
  
  if (document.forms["frm_lang_" + this.id] == null)
  {
    var frm_lang = document.createElement("FORM");
    frm_lang.setAttribute("name", "frm_lang_" + this.id);
    frm_lang.setAttribute("action",filename);
    frm_lang.setAttribute("method", "post");
    frm_lang.setAttribute("target", "_blank");

    this.main_target.parentNode.appendChild(frm_lang);
  }  
  
  if (document.getElementById(param_name + this.id) == null)
  {
    var inputFrm = document.createElement("INPUT");
      inputFrm.name = param_name + this.id;
      inputFrm.id = param_name + this.id;
      inputFrm.type = "hidden";
      inputFrm.value = param_value;
      document.forms["frm_lang_" + this.id].appendChild(inputFrm);
  }
  else
    document.getElementById(param_name + this.id).value = param_value;

  sync_formulaire_ajax(filename, "frm_lang_" + this.id, "POST", "");
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/progress_bar/progress_bar.js $
// Revision: 12122 $

// Définition des variables pour les fonctions d'affichage du temps écoulé
var maintenant = new Date();
var Start = maintenant.getTime();

// Définition des variables pour les fonctions de la barre de progression
var ima1 = "include/javascript/staff/progress_bar/barre_verte.png";// Indiquez ici l'adresse de l'image de la barre
var ima3 = "include/javascript/staff/progress_bar/barre_orange.png";
var ima4 = "include/javascript/staff/progress_bar/barre_rouge.png";

var fond = "#EFF7FF";// Couleur de fond de la barre
var couleur = "#FFFFFF";//Couleur de fond de la page de chargement

var scale = 2;  // La taille de la barre est proportionelle a ce nombre

var tps = 60; // Temps de chargement en seconde, attention elle sera redéfinit lors de l'appel de la fonction build_progress_bar()
                        
var tps_inter = tps * 10; // conversion du temps au format javascript (ms), attention elle sera recalculée lors de l'appel de la fonction build_progress_bar()
var stat_bar = 0; // cette variable contient l'état de la barre lors d'un refresh sur la page
var inter1 = 50; // intervalle 1 = 50% de la barre, attention elle sera redéfinit lors de l'appel de la fonction build_progress_bar()
var inter2 = 75; // intervalle 2 = 75% de la barre, attention elle sera redéfinit lors de l'appel de la fonction build_progress_bar()
/*
**********************************************************************************************************************************************************
*                Fonctions d'affichage du temps qui s'écoule
**********************************************************************************************************************************************************
*/
                        
function affiche_heure() 
{
  var secondes_abs = Math.round(calcul_temps());
  var secondes_rel = secondes_abs % 60;
  //var minutes_abs = Math.abs(Math.round(secondes_abs-30)/60));
  var minutes_abs = Math.round((secondes_abs-30)/60);
  minutes_abs = Math.abs(minutes_abs);

  var nombre_secondes ="" + ((secondes_rel > 9) ? secondes_rel : "0" + secondes_rel);
  var nombre_minutes ="" + ((minutes_abs > 9) ? minutes_abs : "0" + minutes_abs);
  if (window.document.affiche_timer != null)
  window.document.affiche_timer.temps.value = nombre_minutes + ":" + nombre_secondes;
  window.setTimeout('affiche_heure()',1000);
}

function calcul_temps()
{
  var encore_toujours = new Date();
  return((encore_toujours.getTime() - Start)/1000);
}
                        
/*
**********************************************************************************************************************************************************
*                Fonctions de la barre de prgression
**********************************************************************************************************************************************************
*/
// fonction d'affichage de la barre
function pcgbar(pcg, status)
{                      
	// Taille totale de la barre 100%
	var totalbe = 100;
	if (status == null && stat_bar != 0)
	{
		status = "off";
		pcg += stat_bar;
		//alert("avancement de la barre : "+ pcg);
	}
  
	// Ici l'on va afficher la barre progressivement tant que l'on n'a pas atteint sa taille totale
	if (pcg < totalbe)
	{
		if (pcg <= inter1)
		{ 
      // intervalle 1 => barre verte
      // on change toutes les barres pour être sûr qu'il n'y a pas de pb du à la lenteur de rafraîchissement
      for (var i = 0; i <= pcg; i++)
			{
				document.getElementById("progress_bar_img_" + i).src = ima1;
			}
			
      newpcg = pcg + 1;
			timerID = setTimeout('pcgbar(newpcg, "on");', tps_inter);
		}
		else if ((pcg > inter1) && (pcg <= inter2))
		{
      // intervalle 2 => barre orange
			for (var i = 0; i <= pcg; i++)
			{
				document.getElementById("progress_bar_img_" + i).src = ima3;
			}
      
			newpcg = pcg + 1;
			timerID = setTimeout('pcgbar(newpcg, "on");', tps_inter);
		}
		else if ((pcg > inter2) && (pcg < totalbe))
		{
			// intervalle 3 => barre rouge
      for (var i = 0; i <= pcg; i++)
			{
				document.getElementById("progress_bar_img_" + i).src = ima4;
			}
			
			newpcg = pcg + 1;
			timerID = setTimeout('pcgbar(newpcg, "on");', tps_inter);
		}
	}
	// ici l'on a atteint la taille totale de la barre
	// par défaut : on fait clignoter le composant
	else if (pcg == totalbe)
	{
		//clearTimeout(timerID);
		tps_inter = 1000;
		// Code pour IE5, NS6
		if (document.getElementById)
		{
			// IE5, NS6
			if (status == 'on')
			{
				document.getElementById('hidepage').style.visibility = 'hidden';
				newpcg = pcg;
				//test = alert('barre = off');
				timerID = setTimeout('pcgbar(newpcg, "off");',tps_inter);
			}
			else
			{
				document.getElementById('hidepage').style.visibility = 'visible';
				newpcg = pcg;
				//test = alert('barre = on');
				timerID = setTimeout('pcgbar(newpcg, "on");',tps_inter);
			}
		}
		// Code pour Netscape 4, IE 4
		else
		{
			if (document.layers)
			{
				// Netscape 4
				if (status == 'on')
				{
					document.hidepage.visibility = 'hidden';
					newpcg = pcg;
					//test = alert('barre = off');
					timerID = setTimeout('pcgbar(newpcg, "off");',tps_inter);
				}
				else
				{
					document.hidepage.visibility = 'show';
					newpcg = pcg;
					//test = alert('barre = on');
					timerID = setTimeout('pcgbar(newpcg, "on");',tps_inter);
				}
			}
			else
			{
			  // IE 4
				if (status == 'on')
				{
					document.all.hidepage.style.visibility = 'hidden';
					newpcg = pcg;
					//test = alert('barre = off');
					timerID = setTimeout('pcgbar(newpcg, "off");',tps_inter);
				}
				else
				{
					document.all.hidepage.style.visibility = 'visible';
					newpcg = pcg;
					//test = alert('barre = on');
					timerID = setTimeout('pcgbar(newpcg, "on");',tps_inter);
				}
			}
		} 
	}
}

// Cette fonction construit la barre de progression vide avec l'afficheur de temps écoulé
function build_progress_bar(old_start, duree, i1, i2)
{
  if (old_start != 0)
  Start = old_start;
  else
  {
    window.document.affiche_timer.progress_bar_pos.value = Start;
    window.document.affiche_timer.submit();
  }
  // On va calculer dans cette variable l'état d'avancement de la barre par rapport au temps récupéré
  t = Math.round(calcul_temps());
  //alert("temps récupéré : "+ t);
  stat_bar = Math.round(100 * t / duree);
  //alert("taille barre 1 : "+ stat_bar);
  if (stat_bar > 100) stat_bar = 100;
  //alert("taille barre 2 : "+ stat_bar);
  
  // On redéfinit le temps de la barre de progression
  if (duree != null){
          tps = duree;
          tps_inter = tps * 10
  }
  // On redéfinit l'intervalle 1
  if (i1 != null && (i1 <= 100 && i1 < i2)) inter1 = Math.abs(i1);
  // On redéfinit l'intervalle 2
  if (i2 != null && (i2 <= 100 && i2 > i1)) inter2 = Math.abs(i2);
  var d = document;
  if (d.images) 
  {
    // Construction de la barre via 100 petites cellules vides dans lesquelles on va insérer les images de couleur.
    // Dans le cas d'un refresh on va restaurer la barre dans son état.
    for (var i = 0; i < 100; i++) 
    {
      if (i < stat_bar && stat_bar < inter1)
      {
        document.getElementById("progress_bar_img_" + i).src = ima1;
      }
      else if (i < stat_bar && (stat_bar >= inter1 && stat_bar < inter2))
      {
        document.getElementById("progress_bar_img_" + i).src = ima3;
      }
      else if (i < stat_bar && stat_bar >= inter2)
      {
        document.getElementById("progress_bar_img_" + i).src = ima4;
      }
    }
    
    // On fait appel à la fonction de remplissage de la barre grâce à un timer javascript
    pcgbar(stat_bar, null);
  }
}// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/bookmark.js $
// Revision: 8224 $


var editingBookmark = false;        
var oldcontentBookmarkBookmark = "";
var contentBookmark = "";
    
function refreshBookmarks()
{
  url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&ajax_action=refresh', 'InfoPaneFavoris');
}

function renameBookmark(id)
{
  if (!editingBookmark)
  { 
    document.getElementById("RenamedBookmark").value = id;
    editingBookmark = true ;
    oldcontentBookmarkBookmark = document.getElementById("bookmark_" + id).innerHTML ;
    contentBookmark = document.getElementById("link_bookmark_" + id).innerHTML ;
    document.getElementById("bookmark_" + id).innerHTML = '<input type="text" id="BookmarkRename" name="BookmarkRename" size="25" value="" onKeyPress="if (event.keyCode==13) renameBookmarkInDB('+id+'); if (event.keyCode==27) undoRenameBookmark('+id+');"  onBlur="renameBookmarkInDB('+id+')">' ;
    document.getElementById("BookmarkRename").value = contentBookmark;
    document.getElementById("BookmarkRename").select();
  }
  else
  {
    undoRenameBookmark(id) ;
  }
}

function undoRenameBookmark(id)
{
  if (editingBookmark)
  {
    document.getElementById("RenamedBookmark").value = 0;
    document.getElementById("bookmark_" + id).innerHTML = oldcontentBookmarkBookmark ;
    editingBookmark = false ;
  }
}

function renameBookmarkInDB(id)
{
	
	if (editingBookmark)
	{
		if (contentBookmark != document.getElementById("BookmarkRename").value)
		{
			url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&ajax_action=rename&id=' + id + '&newName=' + escape_ezv(document.getElementById("BookmarkRename").value), 'InfoPaneFavoris');
			editingBookmark = false ;
		}
		else undoRenameBookmark(id) ;
	}
}

function deleteBookmarkInDB(id)
{
	url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&ajax_action=delete&id=' + id, 'InfoPaneFavoris');
}

function addBookmark(url, nameLabel, defaultName)
{
	var bookmarkName = prompt(nameLabel, defaultName);
	
	if (bookmarkName != null)
	url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&ajax_action=add&name=' + escape_ezv(bookmarkName) + '&url=' + url, 'InfoPaneFavoris');
}




// -- Studio Bookmark Functions

function studioDeleteBookmarkInDB(id)
{
	url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&studio=1&ajax_action=delete&id=' + id, 'InfoPaneStudioFavoris');
	window.opener.refreshBookmarks();
}

function studioRenameBookmarkInDB(id, oldName)
{
  var newName = document.getElementById("BookmarkRename_"+id).value;
  if (oldName != newName)
  {
    url_ajax_div_eval(main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&studio=1&ajax_action=rename&id=' + id + '&newName=' + escape_ezv(newName), 'InfoPaneStudioFavoris');
    window.opener.refreshBookmarks();
  }
}

function studioSelectFieldToBeSwapped(line)
{
  var Items;
  var Links;

  if (document.BookmarkStudioForm["insert_field_" + line].checked == true)
  {
    for (i = 0; document.BookmarkStudioForm["insert_field_" + i] != null; i++)
    {
      Items = document.getElementById("insert_field_check_" + i);
      Links = document.getElementById("insert_field_link_" + i);
          
      if (i != line)
      {
        Items.style.display = "none";
        Links.style.display = "block";
      }
      else
      {
        Items.style.display = "block";
        Links.style.display = "none";
      }
    }
  }
  else
  {
    for (i = 0; document.BookmarkStudioForm["insert_field_" + i] != null; i++)
    {
      Items = document.getElementById("insert_field_check_" + i);
      Links = document.getElementById("insert_field_link_" + i);

      Items.style.display = "block";
      Links.style.display = "none";
    }
  }
}

function studioSwapField(line)
{
  for (i = 0; document.BookmarkStudioForm["insert_field_" + i] != null; i++)
  {
    if (i != line && document.BookmarkStudioForm["insert_field_" + i].checked == true)
    {
      var BookmarkStudioForm_action = main_directory + 'ajax_bookmark.php?session_id=' + session_id + '&lng=' + session_lng + '&studio=1&ajax_action=swap&from=' + i + '&to=' + line;
      sync_formulaire_ajax_div(BookmarkStudioForm_action, 'BookmarkStudioForm', 'post', 'InfoPaneStudioFavoris');
      window.opener.refreshBookmarks();
      break;
    }
  }
}


// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/search_filter.js $
// Revision: 12642 $

/* JS Functions to show Search Filter Popup */


// -- Show Popup Search Filter
function divPopup_searchFilter_onclick()
{
  createDivsElements();
  
  var div = document.getElementById('divPopup_searchFilter');
  if (div != null)
  {
    // -- onkeydown
    div.onkeydown = function (ev) 
    {
      var TAB = 9;
      var ESC = 27;
      var KEYUP = 38;
      var KEYDN = 40;
      var ENTER = 13;

      var key = -1;
      if (ev)
      {
        // Mozilla
        key = ev.keyCode;
      }
      else if (window.event)
      {
        //IE
        key = window.event.keyCode;
      }
      
      switch(key)
      {
        case ENTER:
        break;

        case ESC:
          var noneDisplay = 'none';
          
          var divTransparent = document.getElementById('transparentDiv'); 
          divTransparent.style.display=noneDisplay;
          
          var div = document.getElementById('divPopup_searchFilter');
          div.style.display = noneDisplay;
          
          var divShadow = document.getElementById('shadowDiv');
          divShadow.style.display=noneDisplay;
        break;
      }
    };
    
    if (isIE && !isIE8)
    {
      div.style.width = '200px';
      div.style.height = '150px';
    }
        
    var divDisplay = div.style.display;
    var newDisplay;
    
    if (divDisplay == 'none')
    newDisplay = 'block';
    else
    newDisplay = 'none';
    
    
    resizeAndPositionDivSearchFilter();
    
    var divTransparent = document.getElementById('transparentDiv'); 
    divTransparent.style.display=newDisplay;
    
    div.style.display = newDisplay;
    
    var divShadow = document.getElementById('shadowDiv');
    divShadow.style.display=newDisplay;
    
    resizeAndPositionDivSearchFilter();
    
    // -- set focus to the first combo
    var firstCombo = document.getElementById('__FILTER_GRID__CurrentField_0');
    if (firstCombo != null) firstCombo.focus();
  }
}

// -- Create transparent, content and shadow
function createDivsElements()
{
  if (document.getElementById('transparentDiv') == null)
  {
    // Creating transparent div
    var transparentDiv=document.createElement('DIV');
    transparentDiv.className='transparency';
    transparentDiv.style.left='0px';
    transparentDiv.style.top='0px';
    transparentDiv.id='transparentDiv';
    document.body.appendChild(transparentDiv);
    
    // Creating shadow div
    var div_shadow=document.createElement('DIV');
    div_shadow.className='shadow';
    div_shadow.id='shadowDiv';
    document.body.appendChild(div_shadow);
	}
}

// -- Resize and Position all divs
function resizeAndPositionDivSearchFilter()
{
	var shadowOffset = 5;
	var topOffset=Math.max(document.body.scrollTop,document.documentElement.scrollTop);
  var leftOffset=Math.max(document.body.scrollLeft,document.documentElement.scrollLeft);
	var bodyWidth=getBrowserWidth();
	var bodyHeight=getBrowserHeight();
	
  var divPopup_searchFilter = document.getElementById('divPopup_searchFilter');
  var divTransparent = document.getElementById('transparentDiv');    
	var divShadow = document.getElementById('shadowDiv');  
	
	var tmpWidth=divPopup_searchFilter.offsetWidth;
	var tmpHeight=divPopup_searchFilter.offsetHeight;

	divPopup_searchFilter.style.left=Math.ceil((bodyWidth-tmpWidth)/ 2)+'px';
	divPopup_searchFilter.style.top=(Math.ceil((bodyHeight-tmpHeight)/ 2)+ topOffset)+'px';
	
	divShadow.style.left=(divPopup_searchFilter.style.left.replace('px','')/1+shadowOffset)+'px';
	divShadow.style.top=(divPopup_searchFilter.style.top.replace('px','')/1+shadowOffset)+'px';
	divShadow.style.height=tmpHeight+'px';
	divShadow.style.width=tmpWidth+'px';
 
	// Resize transparent div
	divTransparent.style.height=(screen.height+topOffset) +'px';
	divTransparent.style.width=(screen.width+leftOffset)+'px';

}

// -- Get Browser Width
function getBrowserWidth()
{
	if(self.innerWidth) return (self.innerWidth);
	return (document.documentElement.offsetWidth);
}

// -- Get Browser Height	
function getBrowserHeight()
{
	if(self.innerHeight) return self.innerHeight;
	return document.documentElement.offsetHeight;
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/tag/tag.js $
// Revision: 12122 $

var tags = [];

function tag1(session, root, arr_params, parent_input_name, lang)
{
	// assign methods
	this.popup               = tag_popup;
	this.popup_overwrite     = tag_popup_overwrite;
	this.change_popup_name   = tag_popup_name;
	this.set_parent_div_name = tag_set_parent_div_name;
	this.closePopup          = tag_close;

	// Main directory
	this.root = root;
  
  // Params
  this.arr_params = arr_params;
  
  // Parent Input Name
  this.parent_input_name = parent_input_name;
  this.parent_div_name = '';
	
	// Language used to write tags
	this.lang = lang;
	
	this.session = session;

	// Nom de la popup
	this.popup_name = 'Popup_js_tag';
	
	// Lien vers la popup
	this.obj_tagwindow = null;
	
	// register in global collections
	this.id = tags.length;
	tags[this.id] = this;
}

// -- Changement du nom du DIV associé au champ
function tag_set_parent_div_name(name)
{ 
  this.parent_div_name = name;
}

// -- Changement du nom de la popup
function tag_popup_name(name)
{
  this.popup_name = name;
}

function tag_popup() 
{
	this.obj_tagwindow = window.open(
		this.root + 'include/javascript/staff/tag/smo_tags_popup.php?' + this.session + '&id=' + this.id + 
		'&parent_input_name=' + this.parent_input_name + '&parent_div_name=' + this.parent_div_name +
		'&' + this.arr_params.join('&') + '&lang=' + this.lang,
		this.popup_name, 'width=600,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=200,left=200,dependent=yes,alwaysRaised=yes'
	);
	this.obj_tagwindow.opener = window;
	this.obj_tagwindow.focus();
}

function tag_popup_overwrite() 
{
  this.obj_tagwindow = window.open(
    this.root + 'include/javascript/staff/tag/smo_tags_popup.php?' + this.session + '&id=' + this.id + 
    '&single=1&parent_input_name=' + this.parent_input_name + '&parent_div_name=' + this.parent_div_name + 
    '&' + this.arr_params.join('&') + '&lang=' + this.lang,
    this.popup_name, 'width=600,height=300'+
    ',scrollbars=yes,status=no,resizable=yes,top=200,left=200,dependent=yes,alwaysRaised=yes'
  );
  this.obj_tagwindow.opener = window;
  this.obj_tagwindow.focus();
}

function tag_error(str_message) 
{
	alert ("Tag : " + str_message);
	return null;
}

function tag_close() 
{
  if (this.obj_tagwindow != null && !this.obj_tagwindow.closed)
    this.obj_tagwindow.close();
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/dialog/jquery.dialog.js $
// Revision: 14637 $
(function ($){

  /**
   * Manage EZV Dialog
   */
  $.dialog = {
    
    /**
     * @private Time Before Close Dialog
     */
    _iWaitingTime : 1000,
    
    /**
     * @private q2_id
     */
    _q2_id : null,
    
    /**
     * @private q2_id2
     */
    _q2_id2 : null,
    
    /**
     * @private q2_dialogId
     */
    _q2_dialogId : null,
    
    /**
     * @private Nb of waiting Tabs Count
     */
    _nbWaitingTabs : 0,
    
    /**
     * @private Must Launch count for hidden tabs
     */
    _bMustCountHiddenTabs : true,
    
    /**
     * @private Tab Preview
     */
    _aPreview : {},
    
    /**
     * Single public method of this class
     */
    init : function() {
      $(document).ready(function(){ $.dialog._init(); });
    },
    
    /**
     * @private init Dialog
     */
    _init : function (){
      this._q2_id = $.getUrlVar('q2_id');
      this._q2_id2 = $.getUrlVar('q2_id2');
      this._q2_dialogId = $.getUrlVar('q2_dialogId');
      var oDiv = $('#divDown_tabsheets');
      var oOthers = $("#otherTabSheets");
      if (oDiv == null || oOthers == null || !oOthers.is(':visible')) {applyEffectWidthForDialog(); return;}
      applyEffectDefaultWidthForDialog();
      var iWidth = oOthers.width();
      var iMaxLeft = $(window).width() - _getBodyGeneralMarge();
      while (parseInt(oOthers.offset().left) + iWidth > iMaxLeft){
        var oTab = oOthers.prev();
        if (oTab.length == 0 || oTab.attr('id') == 'tabSheet_1') break;
        if (oTab.hasClass('dialog_sections_header_selected')){
          oTab.prev().removeClass('dialog_sections_header_end');
          oTab = oTab.prev().prev();
          if (oTab.length == 0 || oTab.attr('id') == 'tabSheet_1') break;
          oSeparator = oTab.prev();
        }else{
          oSeparator = oTab.prev();
          oSeparator.prev().prev().addClass('dialog_sections_header_end').removeClass('dialog_sections_header_between');
        }
        oSeparator.remove();
        oTab.remove();
      }
      oSeparator = $('.dialog_sections_header_end');
      if (oSeparator != null && oSeparator.prev().hasClass('dialog_sections_header_selected') || oSeparator.next().hasClass('dialog_sections_header_selected'))
        oSeparator.removeClass('dialog_sections_header_end');
      oOthers.width(_getBodyGeneralWidth());
      var currentTab = $(".dialog_sections_header_selected.currentVisibleSection").get(0);
      $("#tabSheetEnd").width(1);
      var sMethodName = '';
      for (oTd = oOthers.prev(); oTd != null; oTd = oTd.prev()){
        if (oTd.attr('id') != null){
          if (oTd.attr('id').substr(0, 9) == 'tabSheet_'){
            oDiv.find('tr[id=' + oTd.attr('id') + ']').hide().addClass('hiddenOther');
            var oCount = oTd.find('span[class=dialogPreviewGridTab]');
            if (oCount.length > 0)
              sMethodName += this._initDialogPreviewGrid(oCount, true, oTd.attr('id')) + ",";
            else
              var oCount = oTd.find('span[class=dialogPreviewTab]');
            if (oCount.length > 0 && oTd.get(0) != currentTab)
              this._initMouseEvents(oCount);
          }
          if (oTd.attr('id') == 'tabSheet_0')
            break;
        }
      }
      this._nbWaitingTabs++;
      this._manageTabs(); 
      /* Hint Bulle Closed */
      $("#bulle").bind('isHidden', function (){$.notificationDialog.externalComponentUsage('previewDlg_hint', false);});
      /* Calculate values */
      $.longPolling.callMethod("DlgCount|" + sMethodName, function (response){
        $.each(response, function(id, val) { 
          oId = $("#" + id);
          sTabSheet = oId.parent('td').attr('id');
          oId.find(".TabCount").html("(" + val + ")");
          if (sTabSheet != '') $('#divDown_tabsheets #' + sTabSheet + ' span.TabCount:not(.hidden)').html("(" + val + ")");
          $.dialog._manageTabs();
        });
      });
    },
    
    /**
     * @private Init Mouse Events
     * 
     */
    _initMouseEvents : function (oCount){
      $.notificationDialog.create();
      $.notificationDialog.bind($.notificationDialog.closeEvent, $.dialog._previewDialogChange);
      $.notificationDialog.bind($.notificationDialog.contentIdChangeEvent, $.dialog._previewDialogChange);
      oCount.mouseenter(function () { $.dialog._mouseEnter(oCount); })
      oCount.mouseleave(function () { $.dialog._mouseLeave(oCount); })
    },
    
    /**
     * @private Init a Grid Tab (Count and preview)
     */
    _initDialogPreviewGrid : function(oCount, bManageTab, sTabSheet){
      if (bManageTab) this._nbWaitingTabs++;
      var id = oCount.attr('id');
      var sMethodName = id + '_' + this._q2_dialogId + '_' + this._q2_id;
      if (this._q2_id2 != null) sMethodName += '_' + this._q2_id2;
      return sMethodName;
    },
    
    /**
     * Manage Tabs after Preview Count
     */
    _manageTabs : function () {
      var oOthers = $("#otherTabSheets");
      if (oOthers.find('table tr:not(.hiddenOther)').length == 0)
        oOthers.find('#imgDown_tabsheets').hide();
      else 
        oOthers.find('#imgDown_tabsheets').click($.dialog._othersClick);
    },
    
    _othersClick : function(){
      if ($.dialog._bMustCountHiddenTabs){ 
        $.dialog._bMustCountHiddenTabs = false;
        var oTabCount = $('#divDown_tabsheets tr:not(.hiddenOther) span.TabCount:not(.hidden)');
        var sMethodName = ''; 
        for (i = oTabCount.length - 1; i >= 0; i--)
          sMethodName += $.dialog._initDialogPreviewGrid($(oTabCount[i]).parent(), false, '') + ",";
        /* Calculate values */
        $.longPolling.callMethod("DlgCount|" + sMethodName, function (response){
          $.each(response, function(id, val) { 
            oId = $("#" + id);
            oId.find(".TabCount").html("(" + val + ")");
          });
          $('#divDown_tabsheets').width($('#divDown_tabsheets').width() + 20);
          $.dialog.divDown_tabsheets_onclick(true);
        });
      }
    },    
    
    /**
     * @private Tab Object containing the mouse
     */
    _oCurrentTab : null,
    
    /**
     * @private Uniq Id generated when the mouse is over a Tab
     */
    _currentId : -1,
    
    /**
     * @private Elapsed time before opening preview dialog
     */
    _iWaitingTimeBeforeOpeningPreview : 500,

    /**
     * @private Mouse Enter Event on a Tab
     */
    _mouseEnter : function(oCount){
      $.dialog._oCurrentTab = oCount;
      $.dialog._currentId = new Date().getTime();
      // Wait before opening preview dialog
      setTimeout('$.dialog._tryToOpenPreview("' + $.dialog._currentId + '");', $.dialog._iWaitingTimeBeforeOpeningPreview);
    },
    
    /**
     * @private Mouse over a statistic
     */
    _tryToOpenPreview : function(id){
      if ($.dialog._currentId != id) return;
      var oCount = $.dialog._oCurrentTab;
      this._previewDialogChange();
      var val = parseInt(oCount.find('.TabCount').html().replace('(', '').replace(')', ''));
      if (!isNaN(val) && val > 0){
        $.notificationDialog.externalComponentUsage('dialog', true);
        var id = oCount.attr('id');
        if (this._aPreview.hasOwnProperty(id))
          this._showPreview(id);// Preview already loaded
        else{
          var section_item = id.substr(id.indexOf('_', 0) + 1);
          var sMethodName = 'DlgPreview_' + section_item + '_' + this._q2_dialogId + '_' + this._q2_id;
          if (this._q2_id2 != null) sMethodName += '_' + this._q2_id2;
          $.longPolling.callMethod(sMethodName, function (val){
              $.dialog._aPreview[id] = val.replace("@@TITLE@@", $("#dialogPreview_" + section_item).find(".TabTitle").html());
              $.dialog._showPreview(id);
            });
        }
      }else
        $.notificationDialog.hide();
    },
    
    /**
     * @private Show Preview
     * @param id Id of the current item
     */
    _showPreview : function (id){
      var tabSheet = $('#' + id).parent();
      var tabOffset = tabSheet.offset();
      var iTabHeight = tabSheet.height();
      var iTop = tabOffset.top + iTabHeight + 8;
      var iMinLeft = $('#DIALOG_GENERAL').offset().left + 10;
      var iMaxWidth = $(window).width() - iMinLeft;
      var iRightWidth = $(window).width() - tabOffset.left - 10;
      
      $.notificationDialog.positionWithBorders({'top' : iTop, 'left' : iMinLeft});
      $.notificationDialog.content('<div class="dialogPreview">' + $.dialog._aPreview[id] + '<div id="dialogActionsListItem"></div></div>', 'dialog');
      $.notificationDialog.hide(true);
      var iWidth = $.notificationDialog.width(tabSheet.width() + 50);
      $.notificationDialog.show(true);
      iWidth = $.notificationDialog.width();
      $.notificationDialog.hide(true);
      if (iWidth > iMaxWidth)
        var iLeft = iMinLeft;
      else if (iRightWidth >= iWidth)
        var iLeft = tabOffset.left - 10;
      else
        var iLeft = tabOffset.left - (iWidth - iRightWidth);
      
      $.notificationDialog.positionWithBorders({'top' : iTop, 'left' : iLeft}, true);
      $.notificationDialog.show(false, function (){
        var iWidth = $.notificationDialog.width();
        if (iWidth > iMaxWidth)
          var iLeft = iMinLeft;
        else if (iRightWidth >= iWidth)
          var iLeft = tabOffset.left - 10;
        else
          var iLeft = tabOffset.left - (iWidth - iRightWidth);
        
        $.notificationDialog.positionWithBorders({'top' : iTop, 'left' : iLeft}, true);
      });
      
      var div = $('#dialogActionsListItem');
      div.mouseenter(function () { $.dialog._enterDialogActionsListItem(); });
      div.mouseleave(function () { $.dialog._leaveDialogActionsListItem(); });
      
      $(".dialog_sections_header_selected.currentVisibleSection").addClass('disabledSections bottomBarColor');//bottomBar2 bottomBarColor 
      tabSheet.removeClass('dialog_sections_header_unselected bottomBarColor').addClass('dialog_sections_header_selected topBarColor leftBarColor rightBarColor').corner("top");
      var position = tabSheet.position();
      if ($("#dialogSectionPreviewBottom").length == 0) tabSheet.append('<div id="dialogSectionPreviewBottom">&nbsp;</div>');
      $("#dialogSectionPreviewBottom").css('top', position.top + tabSheet.innerHeight()).css('left', position.left + parseInt(tabSheet.css('border-left-width'))).css('min-width', tabSheet.innerWidth()).show();
    },
    
    /**
     * @private Mouse Leave Event on a Tab
     */
    _mouseLeave : function(oCount){
      $.dialog._oCurrentTab = null;
      $.dialog._currentId = -1;
      $.notificationDialog.externalComponentUsage('dialog', false);
    },
    
    /**
     * @private Current "Actions List Item" associated to "dialogActionsListItem"
     */
    _currentActionsListItem : null,
    
    /**
     * @private Mouse is in (true) or out (false) of the div "dialogActionsListItem"
     */
    _bInDialogActionsListItem : false,
    
    /**
     * @private Mouse Enter Event in "dialogActionsListItem"
     */
    _enterDialogActionsListItem : function (){
      $.dialog._bInDialogActionsListItem = true;
      $.notificationDialog.externalComponentUsage('dialogActionsListItem', true);
    },
    
    /**
     * @private Mouse Leave Event in "dialogActionsListItem"
     */
    _leaveDialogActionsListItem : function (){
      $.dialog._bInDialogActionsListItem = false;
      $.notificationDialog.externalComponentUsage('dialogActionsListItem', false);
    },
    
    /**
     * Show Actions List of an item (simple preview mode)
     * 
     * @param imgId Id of the Item
     * @param divId Id of the div to show
     */
    showActionsListItem : function (imgId, divId){
      if (this._currentActionsListItem == divId){
        this._closeActionsListItem(true);
        return;
      }
      
      this._currentActionsListItem = divId;
      var div = $('#dialogActionsListItem');
      div.html($('#' + divId).html());
      div.show();
      var img = $("#notificationDialog").find('#' + imgId);
      var pos = img.offset();
      pos['top'] += img.height();
      div.offset({top : pos['top'], left : pos['left']});
      setTimeout("$.dialog._closeActionsListItem();", 2000);
    },
    
    /**
     * @private Close "dialogActionsListItem"
     */
    _closeActionsListItem : function(bForce){
      if (this._currentActionsListItem != null){
        if (bForce || !this._bInDialogActionsListItem){
          this._currentActionsListItem = null;
          $('#dialogActionsListItem').hide();
        }else
          setTimeout("$.dialog._closeActionsListItem();", 500);
      }
    },
    
    /**
     * @private Preview Dialog has Changed or is Closed 
     */
    _previewDialogChange : function (){
      $(".dialog_sections_header_selected.currentVisibleSection").removeClass('disabledSections');
      $(".dialog_sections_header_selected:not(.currentVisibleSection)").removeClass('dialog_sections_header_selected topBarColor leftBarColor rightBarColor').addClass('dialog_sections_header_unselected bottomBarColor');
      $("#dialogSectionPreviewBottom").hide();
      $.dialog._closeActionsListItem(true);
    },
    
    divDown_tabsheets_onclick : function(bForceShow){
      var div = $('#divDown_tabsheets');
      if ((div.is(':visible') && typeof(bForceShow) != "undefined" && bForceShow) || !div.is(':visible')){
        var img = $('#imgDown_tabsheets');
        var imgOffset = img.offset();
        div.show();
        var iTop = parseInt(imgOffset.top) + img.height() + 3;
        div.offset({ top : iTop, left : parseInt(imgOffset.left) - div.width() + img.width()});
        var iMaxHeight = $('#notificationToolbarWrap').offset().top - iTop;
        if (div.find('table').outerHeight() < iMaxHeight)
          iMaxHeight = div.find('table').outerHeight();
        div.height(iMaxHeight);
      }
      else
        div.hide();
    }
  }
 })(jQuery);/*!
 * jQuery Form Plugin
 * version: 2.83 (11-JUL-2011)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
  Usage Note:
  -----------
  Do not use both ajaxSubmit and ajaxForm on the same form.  These
  functions are intended to be exclusive.  Use ajaxSubmit if you want
  to bind your own submit handler to the form.  For example,

  $(document).ready(function() {
    $('#myForm').bind('submit', function(e) {
      e.preventDefault(); // <-- important
      $(this).ajaxSubmit({
        target: '#output'
      });
    });
  });

  Use ajaxForm when you want the plugin to manage all the event binding
  for you.  For example,

  $(document).ready(function() {
    $('#myForm').ajaxForm({
      target: '#output'
    });
  });

  When using ajaxForm, the ajaxSubmit function will be invoked for you
  at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
  // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
  if (!this.length) {
    log('ajaxSubmit: skipping submit process - no element selected');
    return this;
  }
  
  var method, action, url, $form = this;

  if (typeof options == 'function') {
    options = { success: options };
  }

  method = this.attr('method');
  action = this.attr('action');
  url = (typeof action === 'string') ? $.trim(action) : '';
  url = url || window.location.href || '';
  if (url) {
    // clean url (don't include hash vaue)
    url = (url.match(/^([^#]+)/)||[])[1];
  }

  options = $.extend(true, {
    url:  url,
    success: $.ajaxSettings.success,
    type: method || 'GET',
    iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
  }, options);

  // hook for manipulating the form data before it is extracted;
  // convenient for use with rich editors like tinyMCE or FCKEditor
  var veto = {};
  this.trigger('form-pre-serialize', [this, options, veto]);
  if (veto.veto) {
    log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
    return this;
  }

  // provide opportunity to alter form data before it is serialized
  if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
    log('ajaxSubmit: submit aborted via beforeSerialize callback');
    return this;
  }

  var n,v,a = this.formToArray(options.semantic);
  if (options.data) {
    options.extraData = options.data;
    for (n in options.data) {
      if(options.data[n] instanceof Array) {
        for (var k in options.data[n]) {
          a.push( { name: n, value: options.data[n][k] } );
        }
      }
      else {
        v = options.data[n];
        v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
        a.push( { name: n, value: v } );
      }
    }
  }

  // give pre-submit callback an opportunity to abort the submit
  if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
    log('ajaxSubmit: submit aborted via beforeSubmit callback');
    return this;
  }

  // fire vetoable 'validate' event
  this.trigger('form-submit-validate', [a, this, options, veto]);
  if (veto.veto) {
    log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
    return this;
  }

  var q = $.param(a);

  if (options.type.toUpperCase() == 'GET') {
    options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
    options.data = null;  // data is null for 'get'
  }
  else {
    options.data = q; // data is the query string for 'post'
  }

  var callbacks = [];
  if (options.resetForm) {
    callbacks.push(function() { $form.resetForm(); });
  }
  if (options.clearForm) {
    callbacks.push(function() { $form.clearForm(); });
  }

  // perform a load on the target only if dataType is not provided
  if (!options.dataType && options.target) {
    var oldSuccess = options.success || function(){};
    callbacks.push(function(data) {
      var fn = options.replaceTarget ? 'replaceWith' : 'html';
      $(options.target)[fn](data).each(oldSuccess, arguments);
    });
  }
  else if (options.success) {
    callbacks.push(options.success);
  }

  options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
    var context = options.context || options;   // jQuery 1.4+ supports scope context 
    for (var i=0, max=callbacks.length; i < max; i++) {
      callbacks[i].apply(context, [data, status, xhr || $form, $form]);
    }
  };

  // are there files to upload?
  var fileInputs = $('input:file', this).length > 0;
  var mp = 'multipart/form-data';
  var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

  // options.iframe allows user to force iframe mode
  // 06-NOV-09: now defaulting to iframe mode if file input is detected
   if (options.iframe !== false && (fileInputs || options.iframe || multipart)) {
     // hack to fix Safari hang (thanks to Tim Molendijk for this)
     // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
     if (options.closeKeepAlive) {
       $.get(options.closeKeepAlive, function() { fileUpload(a); });
    }
     else {
       fileUpload(a);
    }
   }
   else {
    // IE7 massage (see issue 57)
    if ($.browser.msie && method == 'get') { 
      var ieMeth = $form[0].getAttribute('method');
      if (typeof ieMeth === 'string')
        options.type = ieMeth;
    }
    $.ajax(options);
   }

  // fire 'notify' event
  this.trigger('form-submit-notify', [this, options]);
  return this;


  // private function for handling file uploads (hat tip to YAHOO!)
  function fileUpload(a) {
    var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
        var useProp = !!$.fn.prop;

        if (a) {
          // ensure that every serialized input is still enabled
            for (i=0; i < a.length; i++) {
                el = $(form[a[i].name]);
                el[ useProp ? 'prop' : 'attr' ]('disabled', false);
            }
        }

    if ($(':input[name=submit],:input[id=submit]', form).length) {
      // if there is an input with a name or id of 'submit' then we won't be
      // able to invoke the submit fn on the form (at least not x-browser)
      alert('Error: Form elements must not have name or id of "submit".');
      return;
    }
    
    s = $.extend(true, {}, $.ajaxSettings, options);
    s.context = s.context || s;
    id = 'jqFormIO' + (new Date().getTime());
    if (s.iframeTarget) {
      $io = $(s.iframeTarget);
      n = $io.attr('name');
      if (n == null)
        $io.attr('name', id);
      else
        id = n;
    }
    else {
      $io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
      $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
    }
    io = $io[0];


    xhr = { // mock object
      aborted: 0,
      responseText: null,
      responseXML: null,
      status: 0,
      statusText: 'n/a',
      getAllResponseHeaders: function() {},
      getResponseHeader: function() {},
      setRequestHeader: function() {},
      abort: function(status) {
        var e = (status === 'timeout' ? 'timeout' : 'aborted');
        log('aborting upload... ' + e);
        this.aborted = 1;
        $io.attr('src', s.iframeSrc); // abort op in progress
        xhr.error = e;
        s.error && s.error.call(s.context, xhr, e, status);
        g && $.event.trigger("ajaxError", [xhr, s, e]);
        s.complete && s.complete.call(s.context, xhr, e);
      }
    };

    g = s.global;
    // trigger ajax global events so that activity/block indicators work like normal
    if (g && ! $.active++) {
      $.event.trigger("ajaxStart");
    }
    if (g) {
      $.event.trigger("ajaxSend", [xhr, s]);
    }

    if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
      if (s.global) {
        $.active--;
      }
      return;
    }
    if (xhr.aborted) {
      return;
    }

    // add submitting element to data if we know it
    sub = form.clk;
    if (sub) {
      n = sub.name;
      if (n && !sub.disabled) {
        s.extraData = s.extraData || {};
        s.extraData[n] = sub.value;
        if (sub.type == "image") {
          s.extraData[n+'.x'] = form.clk_x;
          s.extraData[n+'.y'] = form.clk_y;
        }
      }
    }
    
    var CLIENT_TIMEOUT_ABORT = 1;
    var SERVER_ABORT = 2;

    function getDoc(frame) {
      var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
      return doc;
    }
    
    // take a breath so that pending repaints get some cpu time before the upload starts
    function doSubmit() {
      // make sure form attrs are set
      var t = $form.attr('target'), a = $form.attr('action');

      // update form attrs in IE friendly way
      form.setAttribute('target',id);
      if (!method) {
        form.setAttribute('method', 'POST');
      }
      if (a != s.url) {
        form.setAttribute('action', s.url);
      }

      // ie borks in some cases when setting encoding
      if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
        $form.attr({
          encoding: 'multipart/form-data',
          enctype:  'multipart/form-data'
        });
      }

      // support timout
      if (s.timeout) {
        timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
      }
      
      // look for server aborts
      function checkState() {
        try {
          var state = getDoc(io).readyState;
          log('state = ' + state);
          if (state.toLowerCase() == 'uninitialized')
            setTimeout(checkState,50);
        }
        catch(e) {
          log('Server abort: ' , e, ' (', e.name, ')');
          cb(SERVER_ABORT);
          timeoutHandle && clearTimeout(timeoutHandle);
          timeoutHandle = undefined;
        }
      }

      // add "extra" data to form if provided in options
      var extraInputs = [];
      try {
        if (s.extraData) {
          for (var n in s.extraData) {
            extraInputs.push(
              $('<input type="hidden" name="'+n+'" />').attr('value',s.extraData[n])
                .appendTo(form)[0]);
          }
        }

        if (!s.iframeTarget) {
          // add iframe to doc and submit the form
          $io.appendTo('body');
                  io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
        }
        setTimeout(checkState,15);
        form.submit();
      }
      finally {
        // reset attrs and remove "extra" input elements
        form.setAttribute('action',a);
        if(t) {
          form.setAttribute('target', t);
        } else {
          $form.removeAttr('target');
        }
        $(extraInputs).remove();
      }
    }

    if (s.forceSync) {
      doSubmit();
    }
    else {
      setTimeout(doSubmit, 10); // this lets dom updates render
    }

    var data, doc, domCheckCount = 50, callbackProcessed;

    function cb(e) {
      if (xhr.aborted || callbackProcessed) {
        return;
      }
      try {
        doc = getDoc(io);
      }
      catch(ex) {
        log('cannot access response document: ', ex);
        e = SERVER_ABORT;
      }
      if (e === CLIENT_TIMEOUT_ABORT && xhr) {
        xhr.abort('timeout');
        return;
      }
      else if (e == SERVER_ABORT && xhr) {
        xhr.abort('server abort');
        return;
      }

      if (!doc || doc.location.href == s.iframeSrc) {
        // response not received yet
        if (!timedOut)
          return;
      }
            io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

      var status = 'success', errMsg;
      try {
        if (timedOut) {
          throw 'timeout';
        }

        var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
        log('isXml='+isXml);
        if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
          if (--domCheckCount) {
            // in some browsers (Opera) the iframe DOM is not always traversable when
            // the onload callback fires, so we loop a bit to accommodate
            log('requeing onLoad callback, DOM not available');
            setTimeout(cb, 250);
            return;
          }
          // let this fall through because server response could be an empty document
          //log('Could not access iframe DOM after mutiple tries.');
          //throw 'DOMException: not available';
        }

        //log('response detected');
                var docRoot = doc.body ? doc.body : doc.documentElement;
                xhr.responseText = docRoot ? docRoot.innerHTML : null;
        xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
        if (isXml)
          s.dataType = 'xml';
        xhr.getResponseHeader = function(header){
          var headers = {'content-type': s.dataType};
          return headers[header];
        };
                // support for XHR 'status' & 'statusText' emulation :
                if (docRoot) {
                    xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
                    xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
                }

        var dt = s.dataType || '';
        var scr = /(json|script|text)/.test(dt.toLowerCase());
        if (scr || s.textarea) {
          // see if user embedded response in textarea
          var ta = doc.getElementsByTagName('textarea')[0];
          if (ta) {
            xhr.responseText = ta.value;
                        // support for XHR 'status' & 'statusText' emulation :
                        xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
                        xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
          }
          else if (scr) {
            // account for browsers injecting pre around json response
            var pre = doc.getElementsByTagName('pre')[0];
            var b = doc.getElementsByTagName('body')[0];
            if (pre) {
              xhr.responseText = pre.textContent ? pre.textContent : pre.innerHTML;
            }
            else if (b) {
              xhr.responseText = b.innerHTML;
            }
          }
        }
        else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
          xhr.responseXML = toXml(xhr.responseText);
        }

                try {
                    data = httpData(xhr, s.dataType, s);
                }
                catch (e) {
                    status = 'parsererror';
                    xhr.error = errMsg = (e || status);
                }
      }
      catch (e) {
        log('error caught: ',e);
        status = 'error';
                xhr.error = errMsg = (e || status);
      }

      if (xhr.aborted) {
        log('upload aborted');
        status = null;
      }

            if (xhr.status) { // we've set xhr.status
                status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
            }

      // ordering of these callbacks/triggers is odd, but that's how $.ajax does it
      if (status === 'success') {
        s.success && s.success.call(s.context, data, 'success', xhr);
        g && $.event.trigger("ajaxSuccess", [xhr, s]);
      }
            else if (status) {
        if (errMsg == undefined)
          errMsg = xhr.statusText;
        s.error && s.error.call(s.context, xhr, status, errMsg);
        g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
            }

      g && $.event.trigger("ajaxComplete", [xhr, s]);

      if (g && ! --$.active) {
        $.event.trigger("ajaxStop");
      }

      s.complete && s.complete.call(s.context, xhr, status);

      callbackProcessed = true;
      if (s.timeout)
        clearTimeout(timeoutHandle);

      // clean up
      setTimeout(function() {
        if (!s.iframeTarget)
          $io.remove();
        xhr.responseXML = null;
      }, 100);
    }

    var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
      if (window.ActiveXObject) {
        doc = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(s);
      }
      else {
        doc = (new DOMParser()).parseFromString(s, 'text/xml');
      }
      return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
    };
    var parseJSON = $.parseJSON || function(s) {
      return window['eval']('(' + s + ')');
    };

    var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

      var ct = xhr.getResponseHeader('content-type') || '',
        xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
        data = xml ? xhr.responseXML : xhr.responseText;

      if (xml && data.documentElement.nodeName === 'parsererror') {
        $.error && $.error('parsererror');
      }
      if (s && s.dataFilter) {
        data = s.dataFilter(data, type);
      }
      if (typeof data === 'string') {
        if (type === 'json' || !type && ct.indexOf('json') >= 0) {
          data = parseJSON(data);
        } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
          $.globalEval(data);
        }
      }
      return data;
    };
  }
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *  is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *  used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
  // in jQuery 1.3+ we can fix mistakes with the ready state
  if (this.length === 0) {
    var o = { s: this.selector, c: this.context };
    if (!$.isReady && o.s) {
      log('DOM not ready, queuing ajaxForm');
      $(function() {
        $(o.s,o.c).ajaxForm(options);
      });
      return this;
    }
    // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
    log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
    return this;
  }

  return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
    if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
      e.preventDefault();
      $(this).ajaxSubmit(options);
    }
  }).bind('click.form-plugin', function(e) {
    var target = e.target;
    var $el = $(target);
    if (!($el.is(":submit,input:image"))) {
      // is this a child element of the submit el?  (ex: a span within a button)
      var t = $el.closest(':submit');
      if (t.length == 0) {
        return;
      }
      target = t[0];
    }
    var form = this;
    form.clk = target;
    if (target.type == 'image') {
      if (e.offsetX != undefined) {
        form.clk_x = e.offsetX;
        form.clk_y = e.offsetY;
      } else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
        var offset = $el.offset();
        form.clk_x = e.pageX - offset.left;
        form.clk_y = e.pageY - offset.top;
      } else {
        form.clk_x = e.pageX - target.offsetLeft;
        form.clk_y = e.pageY - target.offsetTop;
      }
    }
    // clear form vars
    setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
  });
};

// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
  return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
  var a = [];
  if (this.length === 0) {
    return a;
  }

  var form = this[0];
  var els = semantic ? form.getElementsByTagName('*') : form.elements;
  if (!els) {
    return a;
  }

  var i,j,n,v,el,max,jmax;
  for(i=0, max=els.length; i < max; i++) {
    el = els[i];
    n = el.name;
    if (!n) {
      continue;
    }

    if (semantic && form.clk && el.type == "image") {
      // handle image inputs on the fly when semantic == true
      if(!el.disabled && form.clk == el) {
        a.push({name: n, value: $(el).val()});
        a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
      }
      continue;
    }

    v = $.fieldValue(el, true);
    if (v && v.constructor == Array) {
      for(j=0, jmax=v.length; j < jmax; j++) {
        a.push({name: n, value: v[j]});
      }
    }
    else if (v !== null && typeof v != 'undefined') {
      a.push({name: n, value: v});
    }
  }

  if (!semantic && form.clk) {
    // input type=='image' are not found in elements array! handle it here
    var $input = $(form.clk), input = $input[0];
    n = input.name;
    if (n && !input.disabled && input.type == 'image') {
      a.push({name: n, value: $input.val()});
      a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
    }
  }
  return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
  //hand off to jQuery.param for proper encoding
  return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
  var a = [];
  this.each(function() {
    var n = this.name;
    if (!n) {
      return;
    }
    var v = $.fieldValue(this, successful);
    if (v && v.constructor == Array) {
      for (var i=0,max=v.length; i < max; i++) {
        a.push({name: n, value: v[i]});
      }
    }
    else if (v !== null && typeof v != 'undefined') {
      a.push({name: this.name, value: v});
    }
  });
  //hand off to jQuery.param for proper encoding
  return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *    <input name="A" type="text" />
 *    <input name="A" type="text" />
 *    <input name="B" type="checkbox" value="B1" />
 *    <input name="B" type="checkbox" value="B2"/>
 *    <input name="C" type="radio" value="C1" />
 *    <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *     array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
  for (var val=[], i=0, max=this.length; i < max; i++) {
    var el = this[i];
    var v = $.fieldValue(el, successful);
    if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
      continue;
    }
    v.constructor == Array ? $.merge(val, v) : val.push(v);
  }
  return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
  var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
  if (successful === undefined) {
    successful = true;
  }

  if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
    (t == 'checkbox' || t == 'radio') && !el.checked ||
    (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
    tag == 'select' && el.selectedIndex == -1)) {
      return null;
  }

  if (tag == 'select') {
    var index = el.selectedIndex;
    if (index < 0) {
      return null;
    }
    var a = [], ops = el.options;
    var one = (t == 'select-one');
    var max = (one ? index+1 : ops.length);
    for(var i=(one ? index : 0); i < max; i++) {
      var op = ops[i];
      if (op.selected) {
        var v = op.value;
        if (!v) { // extra pain for IE...
          v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
        }
        if (one) {
          return v;
        }
        a.push(v);
      }
    }
    return a;
  }
  return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function() {
  return this.each(function() {
    $('input,select,textarea', this).clearFields();
  });
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function() {
  var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
  return this.each(function() {
    var t = this.type, tag = this.tagName.toLowerCase();
    if (re.test(t) || tag == 'textarea') {
      this.value = '';
    }
    else if (t == 'checkbox' || t == 'radio') {
      this.checked = false;
    }
    else if (tag == 'select') {
      this.selectedIndex = -1;
    }
  });
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
  return this.each(function() {
    // guard against an input with the name of 'reset'
    // note that IE reports the reset function as an 'object'
    if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
      this.reset();
    }
  });
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
  if (b === undefined) {
    b = true;
  }
  return this.each(function() {
    this.disabled = !b;
  });
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
  if (select === undefined) {
    select = true;
  }
  return this.each(function() {
    var t = this.type;
    if (t == 'checkbox' || t == 'radio') {
      this.checked = select;
    }
    else if (this.tagName.toLowerCase() == 'option') {
      var $sel = $(this).parent('select');
      if (select && $sel[0] && $sel[0].type == 'select-one') {
        // deselect all other options
        $sel.find('option').selected(false);
      }
      this.selected = select;
    }
  });
};

// helper fn for console logging
function log() {
  var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
  else if (window.opera && window.opera.postError) {
    window.opera.postError(msg);
  }
};

})(jQuery);
/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilzén and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */


/* ******************* */
/* Constructor & Init  */
/* ******************* */
var SWFUpload;

if (SWFUpload == undefined) {
	SWFUpload = function (settings) {
		this.initSWFUpload(settings);
	};
}

SWFUpload.prototype.initSWFUpload = function (settings) {
	try {
		this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
		this.settings = settings;
		this.eventQueue = [];
		this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
		this.movieElement = null;


		// Setup global control tracking
		SWFUpload.instances[this.movieName] = this;

		// Load the settings.  Load the Flash movie.
		this.initSettings();
		this.loadFlash();
		this.displayDebugInfo();
	} catch (ex) {
		delete SWFUpload.instances[this.movieName];
		throw ex;
	}
};

/* *************** */
/* Static Members  */
/* *************** */
SWFUpload.instances = {};
SWFUpload.movieCount = 0;
SWFUpload.version = "2.2.0 2009-03-25";
SWFUpload.QUEUE_ERROR = {
	QUEUE_LIMIT_EXCEEDED	  		: -100,
	FILE_EXCEEDS_SIZE_LIMIT  		: -110,
	ZERO_BYTE_FILE			  		: -120,
	INVALID_FILETYPE		  		: -130
};
SWFUpload.UPLOAD_ERROR = {
	HTTP_ERROR				  		: -200,
	MISSING_UPLOAD_URL	      		: -210,
	IO_ERROR				  		: -220,
	SECURITY_ERROR			  		: -230,
	UPLOAD_LIMIT_EXCEEDED	  		: -240,
	UPLOAD_FAILED			  		: -250,
	SPECIFIED_FILE_ID_NOT_FOUND		: -260,
	FILE_VALIDATION_FAILED	  		: -270,
	FILE_CANCELLED			  		: -280,
	UPLOAD_STOPPED					: -290
};
SWFUpload.FILE_STATUS = {
	QUEUED		 : -1,
	IN_PROGRESS	 : -2,
	ERROR		 : -3,
	COMPLETE	 : -4,
	CANCELLED	 : -5
};
SWFUpload.BUTTON_ACTION = {
	SELECT_FILE  : -100,
	SELECT_FILES : -110,
	START_UPLOAD : -120
};
SWFUpload.CURSOR = {
	ARROW : -1,
	HAND : -2
};
SWFUpload.WINDOW_MODE = {
	WINDOW : "window",
	TRANSPARENT : "transparent",
	OPAQUE : "opaque"
};

// Private: takes a URL, determines if it is relative and converts to an absolute URL
// using the current site. Only processes the URL if it can, otherwise returns the URL untouched
SWFUpload.completeURL = function(url) {
	if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//)) {
		return url;
	}
	
	var currentURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
	
	var indexSlash = window.location.pathname.lastIndexOf("/");
	if (indexSlash <= 0) {
		path = "/";
	} else {
		path = window.location.pathname.substr(0, indexSlash) + "/";
	}
	
	return /*currentURL +*/ path + url;
	
};


/* ******************** */
/* Instance Members  */
/* ******************** */

// Private: initSettings ensures that all the
// settings are set, getting a default value if one was not assigned.
SWFUpload.prototype.initSettings = function () {
	this.ensureDefault = function (settingName, defaultValue) {
		this.settings[settingName] = (this.settings[settingName] == undefined) ? defaultValue : this.settings[settingName];
	};
	
	// Upload backend settings
	this.ensureDefault("upload_url", "");
	this.ensureDefault("preserve_relative_urls", false);
	this.ensureDefault("file_post_name", "Filedata");
	this.ensureDefault("post_params", {});
	this.ensureDefault("use_query_string", false);
	this.ensureDefault("requeue_on_error", false);
	this.ensureDefault("http_success", []);
	this.ensureDefault("assume_success_timeout", 0);
	
	// File Settings
	this.ensureDefault("file_types", "*.*");
	this.ensureDefault("file_types_description", "All Files");
	this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
	this.ensureDefault("file_upload_limit", 0);
	this.ensureDefault("file_queue_limit", 0);

	// Flash Settings
	this.ensureDefault("flash_url", "swfupload.swf");
	this.ensureDefault("prevent_swf_caching", false);
	
	// Button Settings
	this.ensureDefault("button_image_url", "");
	this.ensureDefault("button_width", 1);
	this.ensureDefault("button_height", 1);
	this.ensureDefault("button_text", "");
	this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
	this.ensureDefault("button_text_top_padding", 0);
	this.ensureDefault("button_text_left_padding", 0);
	this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
	this.ensureDefault("button_disabled", false);
	this.ensureDefault("button_placeholder_id", "");
	this.ensureDefault("button_placeholder", null);
	this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
	this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);
	
	// Debug Settings
	this.ensureDefault("debug", false);
	this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API
	
	// Event Handlers
	this.settings.return_upload_start_handler = this.returnUploadStart;
	this.ensureDefault("swfupload_loaded_handler", null);
	this.ensureDefault("file_dialog_start_handler", null);
	this.ensureDefault("file_queued_handler", null);
	this.ensureDefault("file_queue_error_handler", null);
	this.ensureDefault("file_dialog_complete_handler", null);
	
	this.ensureDefault("upload_start_handler", null);
	this.ensureDefault("upload_progress_handler", null);
	this.ensureDefault("upload_error_handler", null);
	this.ensureDefault("upload_success_handler", null);
	this.ensureDefault("upload_complete_handler", null);
	
	this.ensureDefault("debug_handler", this.debugMessage);

	this.ensureDefault("custom_settings", {});

	// Other settings
	this.customSettings = this.settings.custom_settings;
	
	// Update the flash url if needed
	if (this.settings.prevent_swf_caching) {
		this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
	}
	
	if (!this.settings.preserve_relative_urls) {
		//this.settings.flash_url = SWFUpload.completeURL(this.settings.flash_url);	// Don't need to do this one since flash doesn't look at it
		this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
		this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
	}
	
	delete this.ensureDefault;
};

// Private: loadFlash replaces the button_placeholder element with the flash movie.
SWFUpload.prototype.loadFlash = function () {
	var targetElement, tempParent;

	// Make sure an element with the ID we are going to use doesn't already exist
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	// Get the element where we will be placing the flash movie
	targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

	if (targetElement == undefined) {
		throw "Could not find the placeholder element: " + this.settings.button_placeholder_id;
	}

	// Append the container and load the flash
	tempParent = document.createElement("div");
	tempParent.innerHTML = this.getFlashHTML();	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
	targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

	// Fix IE Flash/Form bug
	if (window[this.movieName] == undefined) {
		window[this.movieName] = this.getMovieElement();
	}
	
};

// Private: getFlashHTML generates the object tag needed to embed the flash in to the document
SWFUpload.prototype.getFlashHTML = function () {
	// Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
	return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', this.settings.flash_url, '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
				'<param name="wmode" value="', this.settings.button_window_mode, '" />',
				'<param name="movie" value="', this.settings.flash_url, '" />',
				'<param name="quality" value="high" />',
				'<param name="menu" value="false" />',
				'<param name="allowScriptAccess" value="always" />',
				'<param name="flashvars" value="' + this.getFlashVars() + '" />',
				'</object>'].join("");
};

// Private: getFlashVars builds the parameter string that will be passed
// to flash in the flashvars param.
SWFUpload.prototype.getFlashVars = function () {
	// Build a string from the post param object
	var paramString = this.buildParamString();
	var httpSuccessString = this.settings.http_success.join(",");
	
	// Build the parameter string
	return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
			"&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
};

// Public: getMovieElement retrieves the DOM reference to the Flash element added by SWFUpload
// The element is cached after the first lookup
SWFUpload.prototype.getMovieElement = function () {
	if (this.movieElement == undefined) {
		this.movieElement = document.getElementById(this.movieName);
	}

	if (this.movieElement === null) {
		throw "Could not find Flash element";
	}
	
	return this.movieElement;
};

// Private: buildParamString takes the name/value pairs in the post_params setting object
// and joins them up in to a string formatted "name=value&amp;name=value"
SWFUpload.prototype.buildParamString = function () {
	var postParams = this.settings.post_params; 
	var paramStringPairs = [];

	if (typeof(postParams) === "object") {
		for (var name in postParams) {
			if (postParams.hasOwnProperty(name)) {
				paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
			}
		}
	}

	return paramStringPairs.join("&amp;");
};

// Public: Used to remove a SWFUpload instance from the page. This method strives to remove
// all references to the SWF, and other objects so memory is properly freed.
// Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
// Credits: Major improvements provided by steffen
SWFUpload.prototype.destroy = function () {
	try {
		// Make sure Flash is done before we try to remove it
		this.cancelUpload(null, false);
		

		// Remove the SWFUpload DOM nodes
		var movieElement = null;
		movieElement = this.getMovieElement();
		
		if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			// Loop through all the movie's properties and remove all function references (DOM/JS IE 6/7 memory leak workaround)
			for (var i in movieElement) {
				try {
					if (typeof(movieElement[i]) === "function") {
						movieElement[i] = null;
					}
				} catch (ex1) {}
			}

			// Remove the Movie Element from the page
			try {
				movieElement.parentNode.removeChild(movieElement);
			} catch (ex) {}
		}
		
		// Remove IE form fix reference
		window[this.movieName] = null;

		// Destroy other references
		SWFUpload.instances[this.movieName] = null;
		delete SWFUpload.instances[this.movieName];

		this.movieElement = null;
		this.settings = null;
		this.customSettings = null;
		this.eventQueue = null;
		this.movieName = null;
		
		
		return true;
	} catch (ex2) {
		return false;
	}
};


// Public: displayDebugInfo prints out settings and configuration
// information about this SWFUpload instance.
// This function (and any references to it) can be deleted when placing
// SWFUpload in production.
SWFUpload.prototype.displayDebugInfo = function () {
	this.debug(
		[
			"---SWFUpload Instance Info---\n",
			"Version: ", SWFUpload.version, "\n",
			"Movie Name: ", this.movieName, "\n",
			"Settings:\n",
			"\t", "upload_url:               ", this.settings.upload_url, "\n",
			"\t", "flash_url:                ", this.settings.flash_url, "\n",
			"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
			"\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
			"\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
			"\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
			"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
			"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
			"\t", "file_types:               ", this.settings.file_types, "\n",
			"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
			"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
			"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
			"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
			"\t", "debug:                    ", this.settings.debug.toString(), "\n",

			"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

			"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
			"\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
			"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
			"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
			"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
			"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
			"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
			"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
			"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
			"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
			"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

			"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
			"Event Handlers:\n",
			"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
			"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
			"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
			"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
			"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
			"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
			"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
			"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
			"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
			"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n"
		].join("")
	);
};

/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	the maintain v2 API compatibility
*/
// Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
SWFUpload.prototype.addSetting = function (name, value, default_value) {
    if (value == undefined) {
        return (this.settings[name] = default_value);
    } else {
        return (this.settings[name] = value);
	}
};

// Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
SWFUpload.prototype.getSetting = function (name) {
    if (this.settings[name] != undefined) {
        return this.settings[name];
	}

    return "";
};



// Private: callFlash handles function calls made to the Flash element.
// Calls are made with a setTimeout for some functions to work around
// bugs in the ExternalInterface library.
SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
	argumentArray = argumentArray || [];
	
	var movieElement = this.getMovieElement();
	var returnValue, returnString;

	// Flash's method if calling ExternalInterface methods (code adapted from MooTools).
	try {
		returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
		returnValue = eval(returnString);
	} catch (ex) {
		throw "Call to " + functionName + " failed";
	}
	
	// Unescape file post param values
	if (returnValue != undefined && typeof returnValue.post === "object") {
		returnValue = this.unescapeFilePostParams(returnValue);
	}

	return returnValue;
};

/* *****************************
	-- Flash control methods --
	Your UI should use these
	to operate SWFUpload
   ***************************** */

// WARNING: this function does not work in Flash Player 10
// Public: selectFile causes a File Selection Dialog window to appear.  This
// dialog only allows 1 file to be selected.
SWFUpload.prototype.selectFile = function () {
	this.callFlash("SelectFile");
};

// WARNING: this function does not work in Flash Player 10
// Public: selectFiles causes a File Selection Dialog window to appear/ This
// dialog allows the user to select any number of files
// Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
// If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
// for this bug.
SWFUpload.prototype.selectFiles = function () {
	this.callFlash("SelectFiles");
};


// Public: startUpload starts uploading the first file in the queue unless
// the optional parameter 'fileID' specifies the ID 
SWFUpload.prototype.startUpload = function (fileID) {
	this.callFlash("StartUpload", [fileID]);
};

// Public: cancelUpload cancels any queued file.  The fileID parameter may be the file ID or index.
// If you do not specify a fileID the current uploading file or first file in the queue is cancelled.
// If you do not want the uploadError event to trigger you can specify false for the triggerErrorEvent parameter.
SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
	if (triggerErrorEvent !== false) {
		triggerErrorEvent = true;
	}
	this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
};

// Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
// If nothing is currently uploading then nothing happens.
SWFUpload.prototype.stopUpload = function () {
	this.callFlash("StopUpload");
};

/* ************************
 * Settings methods
 *   These methods change the SWFUpload settings.
 *   SWFUpload settings should not be changed directly on the settings object
 *   since many of the settings need to be passed to Flash in order to take
 *   effect.
 * *********************** */

// Public: getStats gets the file statistics object.
SWFUpload.prototype.getStats = function () {
	return this.callFlash("GetStats");
};

// Public: setStats changes the SWFUpload statistics.  You shouldn't need to 
// change the statistics but you can.  Changing the statistics does not
// affect SWFUpload accept for the successful_uploads count which is used
// by the upload_limit setting to determine how many files the user may upload.
SWFUpload.prototype.setStats = function (statsObject) {
	this.callFlash("SetStats", [statsObject]);
};

// Public: getFile retrieves a File object by ID or Index.  If the file is
// not found then 'null' is returned.
SWFUpload.prototype.getFile = function (fileID) {
	if (typeof(fileID) === "number") {
		return this.callFlash("GetFileByIndex", [fileID]);
	} else {
		return this.callFlash("GetFile", [fileID]);
	}
};

// Public: addFileParam sets a name/value pair that will be posted with the
// file specified by the Files ID.  If the name already exists then the
// exiting value will be overwritten.
SWFUpload.prototype.addFileParam = function (fileID, name, value) {
	return this.callFlash("AddFileParam", [fileID, name, value]);
};

// Public: removeFileParam removes a previously set (by addFileParam) name/value
// pair from the specified file.
SWFUpload.prototype.removeFileParam = function (fileID, name) {
	this.callFlash("RemoveFileParam", [fileID, name]);
};

// Public: setUploadUrl changes the upload_url setting.
SWFUpload.prototype.setUploadURL = function (url) {
	this.settings.upload_url = url.toString();
	this.callFlash("SetUploadURL", [url]);
};

// Public: setPostParams changes the post_params setting
SWFUpload.prototype.setPostParams = function (paramsObject) {
	this.settings.post_params = paramsObject;
	this.callFlash("SetPostParams", [paramsObject]);
};

// Public: addPostParam adds post name/value pair.  Each name can have only one value.
SWFUpload.prototype.addPostParam = function (name, value) {
	this.settings.post_params[name] = value;
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: removePostParam deletes post name/value pair.
SWFUpload.prototype.removePostParam = function (name) {
	delete this.settings.post_params[name];
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: setFileTypes changes the file_types setting and the file_types_description setting
SWFUpload.prototype.setFileTypes = function (types, description) {
	this.settings.file_types = types;
	this.settings.file_types_description = description;
	this.callFlash("SetFileTypes", [types, description]);
};

// Public: setFileSizeLimit changes the file_size_limit setting
SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
	this.settings.file_size_limit = fileSizeLimit;
	this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
};

// Public: setFileUploadLimit changes the file_upload_limit setting
SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
	this.settings.file_upload_limit = fileUploadLimit;
	this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
};

// Public: setFileQueueLimit changes the file_queue_limit setting
SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
	this.settings.file_queue_limit = fileQueueLimit;
	this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
};

// Public: setFilePostName changes the file_post_name setting
SWFUpload.prototype.setFilePostName = function (filePostName) {
	this.settings.file_post_name = filePostName;
	this.callFlash("SetFilePostName", [filePostName]);
};

// Public: setUseQueryString changes the use_query_string setting
SWFUpload.prototype.setUseQueryString = function (useQueryString) {
	this.settings.use_query_string = useQueryString;
	this.callFlash("SetUseQueryString", [useQueryString]);
};

// Public: setRequeueOnError changes the requeue_on_error setting
SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
	this.settings.requeue_on_error = requeueOnError;
	this.callFlash("SetRequeueOnError", [requeueOnError]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
	if (typeof http_status_codes === "string") {
		http_status_codes = http_status_codes.replace(" ", "").split(",");
	}
	
	this.settings.http_success = http_status_codes;
	this.callFlash("SetHTTPSuccess", [http_status_codes]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
	this.settings.assume_success_timeout = timeout_seconds;
	this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
};

// Public: setDebugEnabled changes the debug_enabled setting
SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
	this.settings.debug_enabled = debugEnabled;
	this.callFlash("SetDebugEnabled", [debugEnabled]);
};

// Public: setButtonImageURL loads a button image sprite
SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
	if (buttonImageURL == undefined) {
		buttonImageURL = "";
	}
	
	this.settings.button_image_url = buttonImageURL;
	this.callFlash("SetButtonImageURL", [buttonImageURL]);
};

// Public: setButtonDimensions resizes the Flash Movie and button
SWFUpload.prototype.setButtonDimensions = function (width, height) {
	this.settings.button_width = width;
	this.settings.button_height = height;
	
	var movie = this.getMovieElement();
	if (movie != undefined) {
		movie.style.width = width + "px";
		movie.style.height = height + "px";
	}
	
	this.callFlash("SetButtonDimensions", [width, height]);
};
// Public: setButtonText Changes the text overlaid on the button
SWFUpload.prototype.setButtonText = function (html) {
	this.settings.button_text = html;
	this.callFlash("SetButtonText", [html]);
};
// Public: setButtonTextPadding changes the top and left padding of the text overlay
SWFUpload.prototype.setButtonTextPadding = function (left, top) {
	this.settings.button_text_top_padding = top;
	this.settings.button_text_left_padding = left;
	this.callFlash("SetButtonTextPadding", [left, top]);
};

// Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
SWFUpload.prototype.setButtonTextStyle = function (css) {
	this.settings.button_text_style = css;
	this.callFlash("SetButtonTextStyle", [css]);
};
// Public: setButtonDisabled disables/enables the button
SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
	this.settings.button_disabled = isDisabled;
	this.callFlash("SetButtonDisabled", [isDisabled]);
};
// Public: setButtonAction sets the action that occurs when the button is clicked
SWFUpload.prototype.setButtonAction = function (buttonAction) {
	this.settings.button_action = buttonAction;
	this.callFlash("SetButtonAction", [buttonAction]);
};

// Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
SWFUpload.prototype.setButtonCursor = function (cursor) {
	this.settings.button_cursor = cursor;
	this.callFlash("SetButtonCursor", [cursor]);
};

/* *******************************
	Flash Event Interfaces
	These functions are used by Flash to trigger the various
	events.
	
	All these functions a Private.
	
	Because the ExternalInterface library is buggy the event calls
	are added to a queue and the queue then executed by a setTimeout.
	This ensures that events are executed in a determinate order and that
	the ExternalInterface bugs are avoided.
******************************* */

SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop
	
	if (argumentArray == undefined) {
		argumentArray = [];
	} else if (!(argumentArray instanceof Array)) {
		argumentArray = [argumentArray];
	}
	
	var self = this;
	if (typeof this.settings[handlerName] === "function") {
		// Queue the event
		this.eventQueue.push(function () {
			this.settings[handlerName].apply(this, argumentArray);
		});
		
		// Execute the next queued event
		setTimeout(function () {
			self.executeNextEvent();
		}, 0);
		
	} else if (this.settings[handlerName] !== null) {
		throw "Event handler " + handlerName + " is unknown or is not a function";
	}
};

// Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
// we must queue them in order to garentee that they are executed in order.
SWFUpload.prototype.executeNextEvent = function () {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop

	var  f = this.eventQueue ? this.eventQueue.shift() : null;
	if (typeof(f) === "function") {
		f.apply(this);
	}
};

// Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
// properties that contain characters that are not valid for JavaScript identifiers. To work around this
// the Flash Component escapes the parameter names and we must unescape again before passing them along.
SWFUpload.prototype.unescapeFilePostParams = function (file) {
	var reg = /[$]([0-9a-f]{4})/i;
	var unescapedPost = {};
	var uk;

	if (file != undefined) {
		for (var k in file.post) {
			if (file.post.hasOwnProperty(k)) {
				uk = k;
				var match;
				while ((match = reg.exec(uk)) !== null) {
					uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
				}
				unescapedPost[uk] = file.post[k];
			}
		}

		file.post = unescapedPost;
	}

	return file;
};

// Private: Called by Flash to see if JS can call in to Flash (test if External Interface is working)
SWFUpload.prototype.testExternalInterface = function () {
	try {
		return this.callFlash("TestExternalInterface");
	} catch (ex) {
		return false;
	}
};

// Private: This event is called by Flash when it has finished loading. Don't modify this.
// Use the swfupload_loaded_handler event setting to execute custom code when SWFUpload has loaded.
SWFUpload.prototype.flashReady = function () {
	// Check that the movie element is loaded correctly with its ExternalInterface methods defined
	var movieElement = this.getMovieElement();

	if (!movieElement) {
		this.debug("Flash called back ready but the flash movie can't be found.");
		return;
	}

	this.cleanUp(movieElement);
	
	this.queueEvent("swfupload_loaded_handler");
};

// Private: removes Flash added fuctions to the DOM node to prevent memory leaks in IE.
// This function is called by Flash each time the ExternalInterface functions are created.
SWFUpload.prototype.cleanUp = function (movieElement) {
	// Pro-actively unhook all the Flash functions
	try {
		if (this.movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
			for (var key in movieElement) {
				try {
					if (typeof(movieElement[key]) === "function") {
						movieElement[key] = null;
					}
				} catch (ex) {
				}
			}
		}
	} catch (ex1) {
	
	}

	// Fix Flashes own cleanup code so if the SWFMovie was removed from the page
	// it doesn't display errors.
	window["__flash__removeCallback"] = function (instance, name) {
		try {
			if (instance) {
				instance[name] = null;
			}
		} catch (flashEx) {
		
		}
	};

};


/* This is a chance to do something before the browse window opens */
SWFUpload.prototype.fileDialogStart = function () {
	this.queueEvent("file_dialog_start_handler");
};


/* Called when a file is successfully added to the queue. */
SWFUpload.prototype.fileQueued = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queued_handler", file);
};


/* Handle errors that occur when an attempt to queue a file fails. */
SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
};

/* Called after the file dialog has closed and the selected files have been queued.
	You could call startUpload here if you want the queued files to begin uploading immediately. */
SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
	this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
};

SWFUpload.prototype.uploadStart = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("return_upload_start_handler", file);
};

SWFUpload.prototype.returnUploadStart = function (file) {
	var returnValue;
	if (typeof this.settings.upload_start_handler === "function") {
		file = this.unescapeFilePostParams(file);
		returnValue = this.settings.upload_start_handler.call(this, file);
	} else if (this.settings.upload_start_handler != undefined) {
		throw "upload_start_handler must be a function";
	}

	// Convert undefined to true so if nothing is returned from the upload_start_handler it is
	// interpretted as 'true'.
	if (returnValue === undefined) {
		returnValue = true;
	}
	
	returnValue = !!returnValue;
	
	this.callFlash("ReturnUploadStart", [returnValue]);
};



SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
};

SWFUpload.prototype.uploadError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_error_handler", [file, errorCode, message]);
};

SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
};

SWFUpload.prototype.uploadComplete = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_complete_handler", file);
};

/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
   internal debug console.  You can override this event and have messages written where you want. */
SWFUpload.prototype.debug = function (message) {
	this.queueEvent("debug_handler", message);
};


/* **********************************
	Debug Console
	The debug console is a self contained, in page location
	for debug message to be sent.  The Debug Console adds
	itself to the body if necessary.

	The console is automatically scrolled as messages appear.
	
	If you are using your own debug handler or when you deploy to production and
	have debug disabled you can remove these functions to reduce the file size
	and complexity.
********************************** */
   
// Private: debugMessage is the default debug_handler.  If you want to print debug messages
// call the debug() function.  When overriding the function your own function should
// check to see if the debug setting is true before outputting debug information.
SWFUpload.prototype.debugMessage = function (message) {
	if (this.settings.debug) {
		var exceptionMessage, exceptionValues = [];

		// Check for an exception object and print it nicely
		if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
			for (var key in message) {
				if (message.hasOwnProperty(key)) {
					exceptionValues.push(key + ": " + message[key]);
				}
			}
			exceptionMessage = exceptionValues.join("\n") || "";
			exceptionValues = exceptionMessage.split("\n");
			exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
			SWFUpload.Console.writeLine(exceptionMessage);
		} else {
			SWFUpload.Console.writeLine(message);
		}
	}
};

SWFUpload.Console = {};
SWFUpload.Console.writeLine = function (message) {
	var console, documentForm;

	try {
		console = document.getElementById("SWFUpload_Console");

		if (!console) {
			documentForm = document.createElement("form");
			document.getElementsByTagName("body")[0].appendChild(documentForm);

			console = document.createElement("textarea");
			console.id = "SWFUpload_Console";
			console.style.fontFamily = "monospace";
			console.setAttribute("wrap", "off");
			console.wrap = "off";
			console.style.overflow = "auto";
			console.style.width = "700px";
			console.style.height = "350px";
			console.style.margin = "5px";
			documentForm.appendChild(console);
		}

		console.value += message + "\n";

		console.scrollTop = console.scrollHeight - console.clientHeight;
	} catch (ex) {
		alert("Exception: " + ex.name + " Message: " + ex.message);
	}
};
/*
 * SWFUpload jQuery Plugin v1.0.0
 *
 * Copyright (c) 2009 Adam Royle
 * Licensed under the MIT license.
 *
 */

(function($){
	
	var defaultHandlers = ['swfupload_loaded_handler','file_queued_handler','file_queue_error_handler','file_dialog_start_handler','file_dialog_complete_handler','upload_start_handler','upload_progress_handler','upload_error_handler','upload_success_handler','upload_complete_handler','queue_complete_handler'];
	var additionalHandlers = [];
	
	$.fn.swfupload = function(){
		var args = $.makeArray(arguments);
		return this.each(function(){
			var swfu;
			if (args.length == 1 && typeof(args[0]) == 'object') {
				swfu = $(this).data('__swfu');
				if (!swfu) {
					var settings = args[0];
					var $magicUploadControl = $(this);
					var handlers = [];
					$.merge(handlers, defaultHandlers);
					$.merge(handlers, additionalHandlers);
					$.each(handlers, function(i, v){
						var eventName = v.replace(/_handler$/, '').replace(/_([a-z])/g, function(){ return arguments[1].toUpperCase(); });
						settings[v] = function() {
							var event = $.Event(eventName);
							$magicUploadControl.trigger(event, $.makeArray(arguments));
							return !event.isDefaultPrevented();
						};
					});
					$(this).data('__swfu', new SWFUpload(settings));
				}
			} else if (args.length > 0 && typeof(args[0]) == 'string') {
				var methodName = args.shift();
				swfu = $(this).data('__swfu');
				if (swfu && swfu[methodName]) {
					swfu[methodName].apply(swfu, args);
				}
			}
		});
	};
	
	$.swfupload = {
		additionalHandlers: function() {
			if (arguments.length === 0) {
				return additionalHandlers.slice();
			} else {
				$(arguments).each(function(i, v){
					$.merge(additionalHandlers, $.makeArray(v));
				});
			}
		},
		defaultHandlers: function() {
			return defaultHandlers.slice();
		},
		getInstance: function(el) {
			return $(el).data('__swfu');
		}
	};
	
})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/iframe.js $
// Revision: 12122 $

// -- Changement du contenu d'une iframe en fonction d'un fichier
function change_iframe(iframe_name, file_name, div_name)
{
  //if (!exec_script(file_name, div_name))
  {
    if (document.getElementById(iframe_name) != null && document.getElementById(iframe_name).src != null)
    {
      document.getElementById(iframe_name).src = file_name;
      document.getElementById(iframe_name + '_div_name').innerHTML = div_name;
    }
  }
}

// -- Changement du contenu d'un DIV en fonction du contenu d'une iFrame
function change_div_iframe(iframe_name)
{
  var div_name = document.getElementById(iframe_name + '_div_name').innerHTML;

  if (div_name != "" && document.getElementById(div_name) != null && document.getElementById(iframe_name) != null)
  {
    if (document.getElementById(iframe_name) != null && document.getElementById(iframe_name).contentDocument != null && 
    document.getElementById(iframe_name).contentDocument.body != null)
    {
      document.getElementById(div_name).innerHTML = document.getElementById(iframe_name).contentDocument.body.innerHTML;
    }
    else if (document.frames != null && document.frames[iframe_name].document != null && document.frames[iframe_name].document.body != null)
    {
      document.getElementById(div_name).innerHTML = document.frames[iframe_name].document.body.innerHTML;
    }
    
    if (iframe_name != 'iframetmp')
    {
      if (document.getElementById(div_name) != null  && document.getElementById(div_name).style.visibility)
        document.getElementById(div_name).style.visibility = 'visible';
      
      if (document.getElementById(div_name) != null  && document.getElementById(div_name).style.display)
        document.getElementById(div_name).style.display = 'block';
    }
  }
  
  drawHtmlChrono();
}

function exec_script(file_name, div_name)
{
  var xhr_object = null;   
  if(window.XMLHttpRequest) // Firefox   
    xhr_object = new XMLHttpRequest();   
  else if(window.ActiveXObject) // Internet Explorer   
    xhr_object = new ActiveXObject("Microsoft.XMLHTTP");   
  else 
  {
    // XMLHttpRequest non supporté par le navigateur   
    return (false);   
  } 
  
  xhr_object.open("GET", file_name, true);
  xhr_object.onreadystatechange = function()
  {
    if(xhr_object.readyState == 4 && document.getElementById(div_name) != null)
      document.getElementById(div_name).innerHTML = xhr_object.responseText;
  }
  xhr_object.send(null);
  
  return (true);
}
    

/*
   repositionne les tables du niveau 1 et 2 en fonction du niveau 0.
 */
function placeMenu() {
	if (menuShownNiv1) {
		placeMenuNiv1(menuShownNiv1, cellSelectedNiv0);
	}
	if (menuShownNiv2) {
		placeMenuNiv2(menuShownNiv2, cellSelectedNiv0, cellSelectedNiv1);
	}
}

/*
	Positionne une table du niveau 1 (en absolu).
*/
function placeMenuNiv1(elemMenu, numCellNiv0) {

	var cellNiv0 = getDomElementMenu("menuCell_" + numCellNiv0);

	// Positionne les barres du niveau 1  
	elemMenu.style.left = getPosXMenu(cellNiv0) + 'px';  // aligne à gauche le niveau 1 sur le niveau 0
	var iTop = getPosYMenu(cellNiv0) + getHeightMenu(cellNiv0);  // positionne le niveau 1 juste sous le niveau 0
	elemMenu.style.top = iTop + 'px';

	// Ajustement pour certains navigateurs 
	if (fctIsMacIEMenu()) 
	{
		iTop = parseInt(getSizeMenu(elemMenu.style.top)) - 3;
		elemMenu.style.top = iTop + 'px';
	}
	else if (fctIsSafariMenu()) 
	{
		iTop = parseInt(getSizeMenu(elemMenu.style.top)) + 2;
		elemMenu.style.top = iTop + 'px';
	}
}
/*
 Repositionne l'élément du menu si en dehors de l'écran (bord droit si fenêtre ou résolution trop petite)
 */
function corrigePlaceNiv1(elemMenuNiv1) {
  var iOverflow = $(elemMenuNiv1).position().left + $(elemMenuNiv1).outerWidth() - $(document).scrollLeft() - $(window).width();
	if (iOverflow > 0) 
	{
    var iLeft = $(elemMenuNiv1).position().left - iOverflow;
		elemMenuNiv1.style.left = iLeft + 'px'; 
	}; 
}

/*
	Positionne une table du niveau 2 (en absolu).
*/
function placeMenuNiv2(elemMenu, numCellNiv0, numCellNiv1) {
	var cellNiv1 = getDomElementMenu("menuCell_" + numCellNiv0 + "_" + numCellNiv1);
  
  // Top position
	var iTop = getPosYMenu(cellNiv1) - 4; // positionne le niveau 1 juste sous le niveau 0
  var cellClassName = getDomElementMenu("menuNiv1_" + numCellNiv0).className;
  if (cellNiv1.offsetParent.className != "right" && cellClassName == 'menuNiv1Fix')
  {
    //iTop -= 100;
    iTop = $(cellNiv1).position().top - 4;
    
    // Gestion des sous menu trop grand
    if (elemMenu.clientHeight > 300)
      iTop = 0;
  }
  else if (elemMenu.clientHeight > 300)
  {
    // Cas standard
    // Gestion des sous menu trop grand
    iTop = iTop - (elemMenu.clientHeight - 300);
    if (iTop < 5)
      iTop = 5;
  }
	// Left position
  var iLeft = 0;
  //if (cellNiv1.offsetParent.className == "right")// && iLeft < )
  
  if (cellNiv1.offsetParent.className != "right") 
  {
    /* ouvre le sous menu à droite */
    iLeft = getPosXMenu(cellNiv1) + getWidthMenu(cellNiv1) + 3; // aligne à gauche sous la cellule du niveau 1 (le delta correspond au border)
    elemMenu.style.left = iLeft + 'px'; 
  }
  
  var menuWidth = getWidthMenu(elemMenu);
  if (cellNiv1.offsetParent.className == "right" || iLeft + menuWidth > $(window).width() + $(window).scrollLeft()) 
  {  
    /* ouvre le sous-menu à gauche */
    iLeft = getPosXMenu(cellNiv1) - menuWidth - 3;
    elemMenu.style.left = iLeft + 'px';
  } 
  
  elemMenu.style.top = iTop + 'px';
  elemMenu.style.left = iLeft + 'px';    
}

var menuShownNiv1;      // l'element (table) affiché pour le niveau 1 (ou null si niveau masqué)
var menuShownNiv2;      // l'element (table) affiché pour le niveau 2 (ou null si niveau masqué)

var cellSelectedNiv0;   // le numero de la cellule du niveau 0 correspondant au niveau 1 actuellement affiché (1-indexed)
var selectedAnchorNiv0; // le lien (<a>) selectionné au niveau 0
var previousClassNiv0;  // la classe css utilisée avant que l'item du niveau 0 ne soit selectionné
var previousAnchorNiv0;  // la classe css utilisée avant que l'item du niveau 0 ne soit selectionné

var cellSelectedNiv1;   // le numero de la cellule du niveau 1 correspondant au niveau 2 actuellement affiché (1-indexed)
var selectedCellNiv1; // le lien (<a>) selectionné au niveau 1
var previousClassNiv1;  // la classe css utilisée avant que l'item du niveau 1 ne soit selectionné

var imgActivatedNiv1;   // Id de l'image "RolledOn" sur le niveau 1
 

function showMenuNiv1(elemA, numMenu, theme_guid, idImg) {
	if (cellSelectedNiv0 && numMenu == cellSelectedNiv0) {
		/* cas de 2 appels consécutifs à showMenuNiv1 pour le même numero de menu 
		   cela ne devrait pas arriver, mais c'est bug qui arrive lorsqu'on survole une image */
		   return;
	}
	// hide existing menu
	hideMenuNiv1();	
	// store the menu to display
	selectedAnchorNiv0 = elemA;
	cellSelectedNiv0 = numMenu;
	menuShownNiv1 = getDomElementMenu("menuNiv1_" + numMenu);
	if (menuShownNiv1) 
  {
		//alert("showMenuNiv1 = " + menuShownNiv1);
		// change l'apparence  de la cellule du niveau 0
		previousClassNiv0 = getDomElementMenu("menuCell_" + numMenu).className;
		getDomElementMenu("menuCell_" + numMenu).className = "tabSelected_" + theme_guid + " bottomBar" + " topBar_" + theme_guid;
		selectedAnchorNiv0.className = "tabSelected_" + theme_guid;
		// move the menu to the right place
		placeMenuNiv1(menuShownNiv1, numMenu);
		// display it
		menuShownNiv1.className = "menuNiv1" + " bottomBar_" + theme_guid;
		corrigePlaceNiv1(menuShownNiv1);
		// hide the selects that can appeared beyond the menu
		if (fctIsWinIEMenu()) {
			setSelectVisibilityMenu(false,menuShownNiv1);
		}
		// rolls the image
		if (idImg) {
			activeImgMenu(idImg);
			imgActivatedNiv1 = idImg;
		}
	}
}
function hideMenuNiv1() {
	// hide niv2 first 
	hideMenuNiv2();
	// hide niv1 if exists
	if (menuShownNiv1) {
		// shows the selects that can appeared beyond the menu
		if (fctIsWinIEMenu()) {
			setSelectVisibilityMenu(true,menuShownNiv1);
		}
		
		if (menuShownNiv1.className != 'menuNiv1Fix')
		{
		  // hide menu
		  menuShownNiv1.className = 'menuNiv1Hidden';
		}
		
		// change l'apparence  de la cellule du niveau 0
		getDomElementMenu("menuCell_" + cellSelectedNiv0).className = previousClassNiv0;
		selectedAnchorNiv0.className = selectedAnchorNiv0;
		// this menu is no more shown
		menuShownNiv1 = null;
		// rolls the image
		if (imgActivatedNiv1) {
			deactiveImgMenu(imgActivatedNiv1);
			imgActivatedNiv1 = null;
		}
	}
	
	cellSelectedNiv0 = null;
}

function fctIsWinIEMenu() {
	var infoNav = navigator.userAgent.toLowerCase();
	return infoNav.indexOf("msie") != -1 && infoNav.indexOf("mac") == -1;
}
function fctIsMacIEMenu() {
	var infoNav = navigator.userAgent.toLowerCase();
	return infoNav.indexOf("msie") != -1 && infoNav.indexOf("mac") != -1;
}
function fctIsSafariMenu() {
	return navigator.userAgent.toLowerCase().indexOf("safari") != -1;
}
function getSizeMenu(sizeWithPx) {
	return sizeWithPx.substring(0, sizeWithPx.length - 2);
}


function showMenuNiv2(elemA, numMenuNiv1, numMenuNiv2, theme_guid) {
	if (cellSelectedNiv1 && numMenuNiv2 == cellSelectedNiv1) {
		/* cas de 2 appels consécutifs à showMenuNiv1 pour le même numero de menu 
		   cela ne devrait pas arriver, mais c'est bug qui arrive lorsqu'on survole une image */
		   return;
	}	
	// hide existing menu
	hideMenuNiv2();
	
	// On masque le menu ouvert si ce n'est pas le menu associé au sous menu
	if (cellSelectedNiv0 != numMenuNiv1)
  {
    hideMenuNiv1();
    cellSelectedNiv0 = numMenuNiv1;
  }
	
	// store the menu to display
	selectedCellNiv1 = elemA;
	cellSelectedNiv1 = numMenuNiv2;
	menuShownNiv2 = getDomElementMenu("menuNiv2_" + numMenuNiv1 + "_" +  numMenuNiv2);
	if (menuShownNiv2) {
		// change l'apparence  de la cellule du niveau 1
		previousClassNiv1 = selectedCellNiv1.className;
		selectedCellNiv1.className = selectedCellNiv1.className + "Selected";
		// display it
    menuShownNiv2.className = "menuNiv2" + " bottomBar_" + theme_guid + " topBar_" + theme_guid;
		// move the menu to the right place
		placeMenuNiv2(menuShownNiv2, cellSelectedNiv0, cellSelectedNiv1);
		//corrigePlaceNiv2(menuShownNiv1, menuShownNiv2);
		// hides the selects that can appeared beyond the menu
		if (fctIsWinIEMenu()) {
			setSelectVisibilityMenu(false,menuShownNiv2);
		}
	}
}
function hideMenuNiv2() {
	if (menuShownNiv2) {
		// shows the selects that can appeared beyond the menu
		if (fctIsWinIEMenu()) {
			setSelectVisibilityMenu(true,menuShownNiv2);
		}
		// hide menu
		menuShownNiv2.className = 'menuNiv2Hidden';
		// change l'apparence  de la cellule du niveau 1
		selectedCellNiv1.className = previousClassNiv1;
		// this menu is no more shown
		menuShownNiv2 = null;
	}
	
	cellSelectedNiv1 = null;
}


function getDomElementMenu(name) {
	if (document.getElementById) {
		return document.getElementById(name);
	} else if (document.all) {
		return document.all[name];
	} else if (document.layers)	{
		return document.layers[name];
	}
}

function getPosXMenu(obj) {
	var curleft = 0;
	if (obj.offsetParent) {
		while (obj.offsetParent) {
			curleft += obj.offsetLeft
			obj = obj.offsetParent;
		}
	} else if (obj.x) {
		curleft += obj.x;
	}
	return curleft;
}
function getPosYMenu(obj) {
	var curtop = 0;
	if (obj.offsetParent) {
		while (obj.offsetParent) {
			curtop += obj.offsetTop
			obj = obj.offsetParent;
		}
	} else if (obj.y) {
		curtop += obj.y;
	}
	return curtop;
}
function getWidthMenu(obj) {
	return obj.offsetWidth;
}
function getHeightMenu(obj) {
	return obj.offsetHeight;
}

function getWindowWidthMenu() {
   if (navigator.appName=="Netscape") {
     return window.innerWidth-16;
   } else {
     return document.body.offsetWidth-20;
   }
}
function getDivMenu(divId) {
	if (document.getElementById) {
		return document.getElementById(divId);
	} else if (document.all) {
		return document.all[divId];
	} else if (document.layers)	{
		return document.layers[divId];
	}
}
/*----------  Masquage du menu  ----------*/

var dernierSortiMenu = 0;

function leaveMenu() {
	eval("setTimeout('checkHideAllMenu(" + dernierSortiMenu + ")',1000);");
}
function enterMenu() {
	dernierSortiMenu++;
}
function checkHideAllMenu(bonDeSortie) {
	// si on n'est pas re-rentré depuis la sortie 'bonDeSortie', on cache le menu
	if (dernierSortiMenu == bonDeSortie) {
		hideMenuNiv1();
	}
}

/*------- Images -------------*/

function activeImgMenu(idImg) {
	var imageOn = eval(idImg + '_on');
	DstepRollMenu(idImg, imageOn.src, 'menuContainer');
}
function deactiveImgMenu(idImg) {
	var imageOff = eval(idImg + '_off');
	DstepRollMenu(idImg, imageOff.src, 'menuContainer');
}
function DstepRollMenu(ImgNam,Chemimg,Mylayon){
	var ns4=(document.layers)?true:false;
	var ie4=(document.all)?true:false;
	var ns6=(document.getElementById && !document.all)?true:false;
	var imgToRoll;
	if(Mylayon==0){
		if(document.images){imgToRoll=document.images[ImgNam];}
	} else {
		if (ns4){imgToRoll=document.layers[Mylayon].document.images[ImgNam];}
		if (ie4||ns6) {imgToRoll=document.images[ImgNam];}
	}
	
	if (imgToRoll) {
		imgToRoll.src=Chemimg;
	}
}


/*-----------  Gestion des elements select -----------------*/
/**
 * visible: true ou false, pour afficher ou masquer les select
 * elemMenu: l'element du menu qui définit la zone à masquer/afficher
 */
function setSelectVisibilityMenu(visible,elemMenu){ 

	var x = getPosXMenu(elemMenu);
	var y = getPosYMenu(elemMenu);
	var w = getWidthMenu(elemMenu);
	var h = getHeightMenu(elemMenu)

	var selx,sely,selw,selh,i 
	var sel=document.getElementsByTagName("SELECT") 
	for(i=0;i<sel.length;i++){ 
		selx=0; sely=0; var selp; 
		if(sel[i].offsetParent){ 
			selp=sel[i]; 
			while(selp.offsetParent){ 
				selp=selp.offsetParent; 
				selx+=selp.offsetLeft; 
				sely+=selp.offsetTop; 
			} 
		} 
		selx+=sel[i].offsetLeft; 
		sely+=sel[i].offsetTop; 
		selw=sel[i].offsetWidth; 
		selh=sel[i].offsetHeight;
		/*ajout seb pour ne pas masquer tous les select par verif si menu = false*/ 
		if(selx+selw>x && selx<x+w && sely+selh>y && sely<y+h && !sel[i].menu ){
			if(visible){
				if (updateCountHiddenMenu(sel[i],-1)==0){
					sel[i].style.visibility="visible"; 				
				}
			}else{
				updateCountHiddenMenu(sel[i],+1);
				sel[i].style.visibility="hidden";				
			}
		}
	} 
} 
function updateCountHiddenMenu(sel, delta) {
	if (!sel.countHidden) {  /* initialize to 0 */
		sel.countHidden = 0;
	}
	sel.countHidden += delta; 
	return sel.countHidden;
}

/*----------------  Gestion des info bulle ----------------*/

function showInfoBulleMenu(menuElem, idInfoBulle) {
	// Recupere l'info bulle
	var infoBulle = getDivMenu(idInfoBulle);
	// Positionne l'info bulle
	infoBulle.style.left = getPosXMenu(menuElem) + 'px';
	var iTop = getPosYMenu(menuElem) - 20;
	infoBulle.style.top = iTop + 'px';
	if (fctIsMacIEMenu()) {
		infoBulle.style.width = '150px';
	}
	// Affiche l'info bulle
	infoBulle.style.display = "inline";
}
function hideInfoBulleMenu(menuElem, idInfoBulle) {
	// Recupere l'info bulle
	var infoBulle = getDivMenu(idInfoBulle);
	// Masque l'info bulle
	infoBulle.style.display = "none";
}

/*
 * jQuery UI @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function($,undefined){$.ui=$.ui||{};if($.ui.version){return;}
$.extend($.ui,{version:"@VERSION",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});$.fn.extend({propAttr:$.fn.prop||$.fn.attr,_focus:$.fn.focus,focus:function(delay,fn){return typeof delay==="number"?this.each(function(){var elem=this;setTimeout(function(){$(elem).focus();if(fn){fn.call(elem);}},delay);}):this._focus.apply(this,arguments);},scrollParent:function(){var scrollParent;if(($.browser.msie&&(/(static|relative)/).test(this.css('position')))||(/absolute/).test(this.css('position'))){scrollParent=this.parents().filter(function(){return(/(relative|absolute|fixed)/).test($.curCSS(this,'position',1))&&(/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));}).eq(0);}else{scrollParent=this.parents().filter(function(){return(/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));}).eq(0);}
return(/fixed/).test(this.css('position'))||!scrollParent.length?$(document):scrollParent;},zIndex:function(zIndex){if(zIndex!==undefined){return this.css("zIndex",zIndex);}
if(this.length){var elem=$(this[0]),position,value;while(elem.length&&elem[0]!==document){position=elem.css("position");if(position==="absolute"||position==="relative"||position==="fixed"){value=parseInt(elem.css("zIndex"),10);if(!isNaN(value)&&value!==0){return value;}}
elem=elem.parent();}}
return 0;},disableSelection:function(){return this.bind(($.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(event){event.preventDefault();});},enableSelection:function(){return this.unbind(".ui-disableSelection");}});$.each(["Width","Height"],function(i,name){var side=name==="Width"?["Left","Right"]:["Top","Bottom"],type=name.toLowerCase(),orig={innerWidth:$.fn.innerWidth,innerHeight:$.fn.innerHeight,outerWidth:$.fn.outerWidth,outerHeight:$.fn.outerHeight};function reduce(elem,size,border,margin){$.each(side,function(){size-=parseFloat($.curCSS(elem,"padding"+this,true))||0;if(border){size-=parseFloat($.curCSS(elem,"border"+this+"Width",true))||0;}
if(margin){size-=parseFloat($.curCSS(elem,"margin"+this,true))||0;}});return size;}
$.fn["inner"+name]=function(size){if(size===undefined){return orig["inner"+name].call(this);}
return this.each(function(){$(this).css(type,reduce(this,size)+"px");});};$.fn["outer"+name]=function(size,margin){if(typeof size!=="number"){return orig["outer"+name].call(this,size);}
return this.each(function(){$(this).css(type,reduce(this,size,true,margin)+"px");});};});function focusable(element,isTabIndexNotNaN){var nodeName=element.nodeName.toLowerCase();if("area"===nodeName){var map=element.parentNode,mapName=map.name,img;if(!element.href||!mapName||map.nodeName.toLowerCase()!=="map"){return false;}
img=$("img[usemap=#"+mapName+"]")[0];return!!img&&visible(img);}
return(/input|select|textarea|button|object/.test(nodeName)?!element.disabled:"a"==nodeName?element.href||isTabIndexNotNaN:isTabIndexNotNaN)&&visible(element);}
function visible(element){return!$(element).parents().andSelf().filter(function(){return $.curCSS(this,"visibility")==="hidden"||$.expr.filters.hidden(this);}).length;}
$.extend($.expr[":"],{data:function(elem,i,match){return!!$.data(elem,match[3]);},focusable:function(element){return focusable(element,!isNaN($.attr(element,"tabindex")));},tabbable:function(element){var tabIndex=$.attr(element,"tabindex"),isTabIndexNaN=isNaN(tabIndex);return(isTabIndexNaN||tabIndex>=0)&&focusable(element,!isTabIndexNaN);}});$(function(){var body=document.body,div=body.appendChild(div=document.createElement("div"));$.extend(div.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});$.support.minHeight=div.offsetHeight===100;$.support.selectstart="onselectstart"in div;body.removeChild(div).style.display="none";});$.extend($.ui,{plugin:{add:function(module,option,set){var proto=$.ui[module].prototype;for(var i in set){proto.plugins[i]=proto.plugins[i]||[];proto.plugins[i].push([option,set[i]]);}},call:function(instance,name,args){var set=instance.plugins[name];if(!set||!instance.element[0].parentNode){return;}
for(var i=0;i<set.length;i++){if(instance.options[set[i][0]]){set[i][1].apply(instance.element,args);}}}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b);},hasScroll:function(el,a){if($(el).css("overflow")==="hidden"){return false;}
var scroll=(a&&a==="left")?"scrollLeft":"scrollTop",has=false;if(el[scroll]>0){return true;}
el[scroll]=1;has=(el[scroll]>0);el[scroll]=0;return has;},isOverAxis:function(x,reference,size){return(x>reference)&&(x<(reference+size));},isOver:function(y,x,top,left,height,width){return $.ui.isOverAxis(y,top,height)&&$.ui.isOverAxis(x,left,width);}});})(jQuery);/*
 * jQuery UI Widget @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function($,undefined){if($.cleanData){var _cleanData=$.cleanData;$.cleanData=function(elems){for(var i=0,elem;(elem=elems[i])!=null;i++){try{$(elem).triggerHandler("remove");}catch(e){}}
_cleanData(elems);};}else{var _remove=$.fn.remove;$.fn.remove=function(selector,keepData){return this.each(function(){if(!keepData){if(!selector||$.filter(selector,[this]).length){$("*",this).add([this]).each(function(){try{$(this).triggerHandler("remove");}catch(e){}});}}
return _remove.call($(this),selector,keepData);});};}
$.widget=function(name,base,prototype){var namespace=name.split(".")[0],fullName;name=name.split(".")[1];fullName=namespace+"-"+name;if(!prototype){prototype=base;base=$.Widget;}
$.expr[":"][fullName]=function(elem){return!!$.data(elem,name);};$[namespace]=$[namespace]||{};$[namespace][name]=function(options,element){if(arguments.length){this._createWidget(options,element);}};var basePrototype=new base();basePrototype.options=$.extend(true,{},basePrototype.options);$[namespace][name].prototype=$.extend(true,basePrototype,{namespace:namespace,widgetName:name,widgetEventPrefix:$[namespace][name].prototype.widgetEventPrefix||name,widgetBaseClass:fullName},prototype);$.widget.bridge(name,$[namespace][name]);};$.widget.bridge=function(name,object){$.fn[name]=function(options){var isMethodCall=typeof options==="string",args=Array.prototype.slice.call(arguments,1),returnValue=this;options=!isMethodCall&&args.length?$.extend.apply(null,[true,options].concat(args)):options;if(isMethodCall&&options.charAt(0)==="_"){return returnValue;}
if(isMethodCall){this.each(function(){var instance=$.data(this,name),methodValue=instance&&$.isFunction(instance[options])?instance[options].apply(instance,args):instance;if(methodValue!==instance&&methodValue!==undefined){returnValue=methodValue;return false;}});}else{this.each(function(){var instance=$.data(this,name);if(instance){instance.option(options||{})._init();}else{$.data(this,name,new object(options,this));}});}
return returnValue;};};$.Widget=function(options,element){if(arguments.length){this._createWidget(options,element);}};$.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(options,element){$.data(element,this.widgetName,this);this.element=$(element);this.options=$.extend(true,{},this.options,this._getCreateOptions(),options);var self=this;this.element.bind("remove."+this.widgetName,function(){self.destroy();});this._create();this._trigger("create");this._init();},_getCreateOptions:function(){return $.metadata&&$.metadata.get(this.element[0])[this.widgetName];},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled");},widget:function(){return this.element;},option:function(key,value){var options=key;if(arguments.length===0){return $.extend({},this.options);}
if(typeof key==="string"){if(value===undefined){return this.options[key];}
options={};options[key]=value;}
this._setOptions(options);return this;},_setOptions:function(options){var self=this;$.each(options,function(key,value){self._setOption(key,value);});return this;},_setOption:function(key,value){this.options[key]=value;if(key==="disabled"){this.widget()
[value?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",value);}
return this;},enable:function(){return this._setOption("disabled",false);},disable:function(){return this._setOption("disabled",true);},_trigger:function(type,event,data){var callback=this.options[type];event=$.Event(event);event.type=(type===this.widgetEventPrefix?type:this.widgetEventPrefix+type).toLowerCase();data=data||{};if(event.originalEvent){for(var i=$.event.props.length,prop;i;){prop=$.event.props[--i];event[prop]=event.originalEvent[prop];}}
this.element.trigger(event,data);return!($.isFunction(callback)&&callback.call(this.element[0],event,data)===false||event.isDefaultPrevented());}};})(jQuery);/*
 * jQuery UI Progressbar @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function($,undefined){$.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()});this.valueDiv=$("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);this.oldValue=this._value();this._refreshValue();},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");this.valueDiv.remove();$.Widget.prototype.destroy.apply(this,arguments);},value:function(newValue){if(newValue===undefined){return this._value();}
this._setOption("value",newValue);return this;},_setOption:function(key,value){if(key==="value"){this.options.value=value;this._refreshValue();if(this._value()===this.options.max){this._trigger("complete");}}
$.Widget.prototype._setOption.apply(this,arguments);},_value:function(){var val=this.options.value;if(typeof val!=="number"){val=0;}
return Math.min(this.options.max,Math.max(this.min,val));},_percentage:function(){return 100*this._value()/this.options.max;},_refreshValue:function(){var value=this.value();var percentage=this._percentage();if(this.oldValue!==value){this.oldValue=value;this._trigger("change");}
this.valueDiv.toggle(value>this.min).toggleClass("ui-corner-right",value===this.options.max).width(percentage.toFixed(0)+"%");this.element.attr("aria-valuenow",value);}});$.extend($.ui.progressbar,{version:"@VERSION"});})(jQuery);/*
 * jQuery UI Datepicker 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.16" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',
	
	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},
	
	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				removeAttr("disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				attr("disabled", "disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + 
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (event) {
				$.datepicker.log(event);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show. 
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			if ( $.datepicker._datepickerShowing ) {
				$.datepicker._triggerOnClose($.datepicker._curInst);
			}
			$.datepicker._curInst.dpDiv.stop(true, true);
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
            //false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
		var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
    // [LD] : Positionne la fenêtre de saisie au dessus du champ uniquement s'il y a la place (évite le chevauchement du champ de saisie)
    if (dpHeight < inst.input.offset().top)
		  offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
  			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Trigger custom callback of onClose. */
	_triggerOnClose: function(inst) {
		var onClose = this._get(inst, 'onClose');
		if (onClose)
			onClose.apply((inst.input ? inst.input[0] : null),
						  [(inst.input ? inst.input.val() : ''), inst]);
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
				this._curInst = null;
			};
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			$.datepicker._triggerOnClose(inst);
			this._datepickerShowing = false;
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;
		var $target = $(event.target);
		if ($target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.hasClass($.datepicker._triggerClass) &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			throw "Extra/unparsed characters found in date: " + value.substring(iValue);
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
    if (name == 'dateFormat' && datepickerRegionalDateFormat != undefined) return datepickerRegionalDateFormat;
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._hideDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._gotoToday(\'#' + inst.id + '\');"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' onclick="DP_jQuery_' + dpuuid + '.datepicker._selectDay(\'#' +
							inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' + 
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" ' +
				'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
			 	'>';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" ' +
					'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
					'>';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';
				
				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */ 
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.bind('mouseout', function(event) {
			var elem = $( event.target ).closest( selector );
			if ( !elem.length ) {
				return;
			}
			elem.removeClass( "ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover" );
		})
		.bind('mouseover', function(event) {
			var elem = $( event.target ).closest( selector );
			if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
					!elem.length ) {
				return;
			}
			elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
			elem.addClass('ui-state-hover');
			if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');
			if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
		(a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){
	
	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}
	
	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find('body').append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.8.16";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
/*!
 * jQuery UI Mouse @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
				    $.removeData(event.target, self.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
/*
 * jQuery UI Draggable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data('draggable')) return;
		this.element
			.removeData("draggable")
			.unbind(".draggable")
			.removeClass("ui-draggable"
				+ " ui-draggable-dragging"
				+ " ui-draggable-disabled");
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		if ( o.iframeFix ) {
			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});
		}

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.helper.addClass("ui-draggable-dragging");
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is removed, don't bother to continue if helper is set to "original"
		if((!this.element[0] || !this.element[0].parentNode) && this.options.helper == "original")
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger("stop", event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$("div.ui-draggable-iframeFix").each(function() { 
				this.parentNode.removeChild(this); 
			}); //Remove frame helpers
		}
		
		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: "1.8.16"
});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);
/*
 * jQuery UI Droppable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass("ui-droppable ui-droppable-disabled")
			.removeData("droppable")
			.unbind(".droppable");

		return this;
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: "1.8.16"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = dropped || this._drop.call(this, event);

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( ":not(body,html)" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(':data(droppable):eq(0)');
				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( ":not(body,html)" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
/*
 * jQuery UI Sortable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	widgetEventPrefix: "sort",
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

	},

	destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled")
			.removeData("sortable")
			.unbind(".sortable");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData("sortable-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, 'sortable-item') == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, 'sortable-item') == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(sortable-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data('sortable-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		// get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue 
				if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				// container doesn't intersect. trigger "out" event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		// if no intersecting containers found, return 
		if(!innermostContainer) return; 

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) { 

			//When entering a new container, we will find the item with the least distance and append our item near it 
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top']; 
			for (var j = this.items.length - 1; j >= 0; j--) { 
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; 
				var cur = this.items[j][this.containers[innermostIndex].floating ? 'left' : 'top']; 
				if(Math.abs(cur - base) < dist) { 
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; 
				} 
			} 

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled 
				return; 

			this.currentContainer = this.containers[innermostIndex]; 
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); 
			this._trigger("change", event, this._uiHash()); 
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)); 

			//Update the placeholder 
			this.options.placeholder.update(this.currentContainer, this.placeholder); 
		
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)); 
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
			for (var i = this.containers.length - 1; i >= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: "1.8.16"
});

})(jQuery);
/*
 * jQuery UI Position @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions (see #5280)
		position.left = Math.round( position.left );
		position.top = Math.round( position.top );

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

}( jQuery ));
/*
 * jQuery UI Autocomplete @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	options: {
		appendTo: "body",
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null
	},

	pending: 0,

	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument,
			suppressKeyPress;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" )
			// TODO verify these actually work as intended
			.attr({
				role: "textbox",
				"aria-autocomplete": "list",
				"aria-haspopup": "true"
			})
			.bind( "keydown.autocomplete", function( event ) {
				if ( self.options.disabled || self.element.propAttr( "readOnly" ) ) {
					return;
				}

				suppressKeyPress = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( "nextPage", event );
					break;
				case keyCode.UP:
					self._move( "previous", event );
					// prevent moving cursor to beginning of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.DOWN:
					self._move( "next", event );
					// prevent moving cursor to end of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( self.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
					}
					//passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				default:
					// keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						// only search if the value has changed
						if ( self.term != self.element.val() ) {
							self.selectedItem = null;
							self.search( null, event );
						}
					}, self.options.delay );
					break;
				}
			})
			.bind( "keypress.autocomplete", function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
				}
			})
			.bind( "focus.autocomplete", function() {
				if ( self.options.disabled ) {
					return;
				}

				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( "blur.autocomplete", function( event ) {
				if ( self.options.disabled ) {
					return;
				}

				clearTimeout( self.searching );
				// clicks on the menu (or a button to trigger a search) will cause a blur event
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.response = function() {
			return self._response.apply( self, arguments );
		};
		this.menu = $( "<ul></ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( $( this.options.appendTo || "body", doc )[0] )
			// prevent the close-on-blur in case of a "slow" click on the menu (long mousedown)
			.mousedown(function( event ) {
				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = self.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					setTimeout(function() {
						$( document ).one( 'mousedown', function( event ) {
							if ( event.target !== self.element[ 0 ] &&
								event.target !== menuElement &&
								!$.ui.contains( menuElement, event.target ) ) {
								self.close();
							}
						});
					}, 1 );
				}

				// use another timeout to make sure the blur-event-handler on the input was already triggered
				setTimeout(function() {
					clearTimeout( self.closing );
				}, 13);
			})
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" );
					if ( false !== self._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( /^key/.test(event.originalEvent.type) ) {
							self.element.val( item.value );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" ),
						previous = self.previous;

					// only trigger when focus was lost (click on menu)
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						setTimeout(function() {
							self.previous = previous;
							self.selectedItem = item;
						}, 1);
					}

					if ( false !== self._trigger( "select", event, { item: item } ) ) {
						self.element.val( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					self.term = self.element.val();

					self.close( event );
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					// don't set the value of the text field if it's already correct
					// this prevents moving the cursor unnecessarily
					if ( self.menu.element.is(":visible") &&
						( self.element.val() !== self.term ) ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( "menu" );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
	},

	destroy: function() {
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-autocomplete" )
			.removeAttr( "aria-haspopup" );
		this.menu.element.remove();
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( $( value || "body", this.element[0].ownerDocument )[0] )
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_initSource: function() {
		var self = this,
			array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( self.xhr ) {
					self.xhr.abort();
				}
				self.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					autocompleteRequest: ++requestIndex,
					success: function( data, status ) {
						if ( this.autocompleteRequest === requestIndex ) {
							response( data );
						}
					},
					error: function() {
						if ( this.autocompleteRequest === requestIndex ) {
							response( [] );
						}
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();

		// always save the actual value, not the one passed as an argument
		this.term = this.element.val();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );

		this.source( { term: value }, this.response );
	},

	_response: function( content ) {
		if ( !this.options.disabled && content && content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( "open" );
		} else {
			this.close();
		}
		this.pending--;
		if ( !this.pending ) {
			this.element.removeClass( "ui-autocomplete-loading" );
		}
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(":visible") ) {
			this.menu.element.hide();
			this.menu.deactivate();
			this._trigger( "close", event );
		}
	},
	
	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next( new $.Event("mouseover") );
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			ul.width( "" ).outerWidth(),
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
		return $( "<li></li>" )
			.data( "item.autocomplete", item )
			.append( $( "<a></a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(":visible") ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() && /^previous/.test(direction) ||
				this.menu.last() && /^next/.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 * 
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget("ui.menu", {
	_create: function() {
		var self = this;
		this.element
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.attr({
				role: "listbox",
				"aria-activedescendant": "ui-active-menuitem"
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( ".ui-menu-item a" ).length ) {
					return;
				}
				// temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},
	
	refresh: function() {
		var self = this;

		// don't refresh list items that are already adapted
		var items = this.element.children("li:not(.ui-menu-item):has(a)")
			.addClass("ui-menu-item")
			.attr("role", "menuitem");
		
		items.children("a")
			.addClass("ui-corner-all")
			.attr("tabindex", -1)
			// mouseenter doesn't work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.scrollTop(),
				elementHeight = this.element.height();
			if (offset < 0) {
				this.element.scrollTop( scroll + offset);
			} else if (offset >= elementHeight) {
				this.element.scrollTop( scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children("a")
				.addClass("ui-state-hover")
				.attr("id", "ui-active-menuitem")
			.end();
		this._trigger("focus", event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children("a")
			.removeClass("ui-state-hover")
			.removeAttr("id");
		this._trigger("blur");
		this.active = null;
	},

	next: function(event) {
		this.move("next", ".ui-menu-item:first", event);
	},

	previous: function(event) {
		this.move("prev", ".ui-menu-item:last", event);
	},

	first: function() {
		return this.active && !this.active.prevAll(".ui-menu-item").length;
	},

	last: function() {
		return this.active && !this.active.nextAll(".ui-menu-item").length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + "All"](".ui-menu-item").eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	// TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(".ui-menu-item:first"));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:last");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.last() ? ":first" : ":last"));
		}
	},

	// TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(".ui-menu-item:last"));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height();
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:first");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.first() ? ":last" : ":first"));
		}
	},

	hasScroll: function() {
		return this.element.height() < this.element[ $.fn.prop ? "prop" : "attr" ]("scrollHeight");
	},

	select: function( event ) {
		this._trigger("selected", event, { item: this.active });
	}
});

}(jQuery));
/*
 * jQuery UI Resizable @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Opera fix for relative positioning
			if (/relative/.test(this.element.css('position')) && $.browser.opera)
				this.element.css({ position: 'relative', top: 'auto', left: 'auto' });

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// increase zIndex of sw, se, ne, nw axis
				//TODO : this modifies original option
				if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.hover(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				},
				function(){
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		//Opera fixing relative position
		if ($.browser.opera && (/relative/).test(el.css('position')))
			el.css({ position: 'relative', top: 'auto', left: 'auto' });

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "@VERSION"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10),
					position: el.css('position') // to reset Opera on stop()
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, 
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				// Opera fixing relative position
				if ($.browser.opera && /relative/.test(el.css('position'))) {
					self._revertToRelativePosition = true;
					el.css({ position: 'absolute', top: 'auto', left: 'auto' });
				}

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _reset = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				// reset position for Opera - no need to verify it was changed
				el.css({ position: el.data("resizable-alsoresize").position });
			});
		};

		if (self._revertToRelativePosition) {
			self._revertToRelativePosition = false;
			if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function (exp) { _reset(exp); });
			}else{
				_reset(o.alsoResize);
			}
		}

		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / o.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * o.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
/*
 * jQuery UI Dialog @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
		'ui-dialog ' +
		'ui-widget ' +
		'ui-widget-content ' +
		'ui-corner-all ',
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},
	// support for jQuery 1.3.2 - handle common attrFn methods for dialog
	attrFn = $.attrFn || {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true,
		click: true
	};

$.widget("ui.dialog", {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: 'close',
		dialogClass: '',
		draggable: true,
		hide: null,
		height: 'auto',
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: 'center',
			at: 'center',
			collision: 'fit',
			// ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset < 0) {
					$(this).css('top', pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: '',
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr('title');
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || '&#160;',
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $('<div></div>'))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				// setting outline to 0 prevents a border on focus in Mozilla
				.attr('tabIndex', -1).css('outline', 0).keydown(function(event) {
					if (options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: 'dialog',
					'aria-labelledby': titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr('title')
				.addClass(
					'ui-dialog-content ' +
					'ui-widget-content')
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>'))
				.addClass(
					'ui-dialog-titlebar ' +
					'ui-widget-header ' +
					'ui-corner-all ' +
					'ui-helper-clearfix'
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $('<a href="#"></a>')
				.addClass(
					'ui-dialog-titlebar-close ' +
					'ui-corner-all'
				)
				.attr('role', 'button')
				.hover(
					function() {
						uiDialogTitlebarClose.addClass('ui-state-hover');
					},
					function() {
						uiDialogTitlebarClose.removeClass('ui-state-hover');
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass('ui-state-focus');
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass('ui-state-focus');
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>'))
				.addClass(
					'ui-icon ' +
					'ui-icon-closethick'
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $('<span></span>')
				.addClass('ui-dialog-title')
				.attr('id', titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		//handling of deprecated beforeclose (vs beforeClose) option
		//Ticket #4669 http://dev.jqueryui.com/ticket/4669
		//TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();

		if (options.draggable && $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable && $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.hide();
		self.element
			.unbind('.dialog')
			.removeData('dialog')
			.removeClass('ui-dialog-content ui-widget-content')
			.hide().appendTo('body');
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr('title', self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function(event) {
		var self = this,
			maxZ, thisZ;
		
		if (false === self._trigger('beforeClose', event)) {
			return;
		}

		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.unbind('keypress.ui-dialog');

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger('close', event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger('close', event);
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$('.ui-dialog').each(function() {
				if (this !== self.uiDialog[0]) {
					thisZ = $(this).css('z-index');
					if(!isNaN(thisZ)) {
						maxZ = Math.max(maxZ, thisZ);
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal && !force) ||
			(!options.stack && !options.modal)) {
			return self._trigger('focus', event);
		}

		if (options.zIndex > $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		//Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		//  http://ui.jquery.com/bugs/ticket/3193
		saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css('z-index', $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger('focus', event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		// prevent tabbing out of modal dialogs
		if (options.modal) {
			uiDialog.bind('keypress.ui-dialog', function(event) {
				if (event.keyCode !== $.ui.keyCode.TAB) {
					return;
				}

				var tabbables = $(':tabbable', this),
					first = tabbables.filter(':first'),
					last  = tabbables.filter(':last');

				if (event.target === last[0] && !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] && event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(':tabbable').get().concat(
			uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger('open');

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $('<div></div>')
				.addClass(
					'ui-dialog-buttonpane ' +
					'ui-widget-content ' +
					'ui-helper-clearfix'
				),
			uiButtonSet = $( "<div></div>" )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		// if we already have a button pane, remove it
		self.uiDialog.find('.ui-dialog-buttonpane').remove();

		if (typeof buttons === 'object' && buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $('<button type="button"></button>')
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				// can't use .attr( props, true ) with jQuery 1.3.2.
				$.each( props, function( key, value ) {
					if ( key === "click" ) {
						return;
					}
					if ( key in attrFn ) {
						button[ key ]( value );
					} else {
						button.attr( key, value );
					}
				});
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
			handle: '.ui-dialog-titlebar',
			containment: 'document',
			start: function(event, ui) {
				heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height();
				$(this).height($(this).height()).addClass("ui-dialog-dragging");
				self._trigger('dragStart', event, filteredUi(ui));
			},
			drag: function(event, ui) {
				self._trigger('drag', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag);
				self._trigger('dragStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css('position'),
			resizeHandles = (typeof handles === 'string' ?
				handles	:
				'n,e,s,w,se,sw,ne,nw'
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: '.ui-dialog-content',
			containment: 'document',
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass("ui-dialog-resizing");
				self._trigger('resizeStart', event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger('resize', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass("ui-dialog-resizing");
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger('resizeStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css('position', position)
		.find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se');
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === 'auto') {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],
			isVisible;

		if (position) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
				myAt = position.split ? position.split(' ') : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each(['left', 'top'], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(" "),
					at: myAt.join(" "),
					offset: offset.join(" ")
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(':visible');
		if (!isVisible) {
			this.uiDialog.show();
		}
		this.uiDialog
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.position($.extend({ of: window }, position));
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			//handling of deprecated beforeclose (vs beforeClose) option
			//Ticket #4669 http://dev.jqueryui.com/ticket/4669
			//TODO: remove in 1.9pre
			case "beforeclose":
				key = "beforeClose";
				break;
			case "buttons":
				self._createButtons(value);
				break;
			case "closeText":
				// ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text("" + value);
				break;
			case "dialogClass":
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case "disabled":
				if (value) {
					uiDialog.addClass('ui-dialog-disabled');
				} else {
					uiDialog.removeClass('ui-dialog-disabled');
				}
				break;
			case "draggable":
				var isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}
				
				if ( !isDraggable && value ) {
					self._makeDraggable();
				}
				break;
			case "position":
				self._position(value);
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( ":data(resizable)" );
				if (isResizable && !value) {
					uiDialog.resizable('destroy');
				}

				// currently resizable, changing handles
				if (isResizable && typeof value === 'string') {
					uiDialog.resizable('option', 'handles', value);
				}

				// currently non-resizable, becoming resizable
				if (!isResizable && value !== false) {
					self._makeResizable(value);
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;'));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var options = this.options,
			nonContentHeight,
			minContentHeight,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: 'auto',
			minHeight: 0,
			height: 0
		});

		if (options.minWidth > options.width) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: 'auto',
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is(':data(resizable)')) {
			this.uiDialog.resizable('option', 'minHeight', this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: "@VERSION",

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr('id');
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return 'ui-dialog-title-' + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','),
		function(event) { return event + '.dialog-overlay'; }).join(' '),
	create: function(dialog) {
		if (this.instances.length === 0) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
							return false;
						}
					});
				}
			}, 1);

			// allow closing by pressing the escape key
			$(document).bind('keydown.dialog-overlay', function(event) {
				if (dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			// handle window resize
			$(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay'))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		var indexOf = $.inArray($el, this.instances);
		if (indexOf != -1){
			this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
		}

		if (this.instances.length === 0) {
			$([document, window]).unbind('.dialog-overlay');
		}

		$el.remove();
		
		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css('z-index'));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE 6
		if ($.browser.msie && $.browser.version < 7) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight < offsetHeight) {
				return $(window).height() + 'px';
			} else {
				return scrollHeight + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).height() + 'px';
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth < offsetWidth) {
				return $(window).width() + 'px';
			} else {
				return scrollWidth + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).width() + 'px';
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $([]);
		$.each($.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add(this);
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));
/*
 * jQuery UI Slider @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" + 
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			}, function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.keydown(function( event ) {
				var ret = true,
					index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						ret = false;
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
	
				return ret;
	
			})
			.keyup(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.unbind( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) && 
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.propAttr( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.propAttr( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "@VERSION"
});

}(jQuery));
(function($){$.extend($.ui,{timepicker:{version:"0.9.7"}});function Timepicker(){this.regional=[];this.regional['']={currentText:'Now',closeText:'Done',ampm:false,amNames:['AM','A'],pmNames:['PM','P'],timeFormat:'hh:mm tt',timeSuffix:'',timeOnlyTitle:'Choose Time',timeText:'Time',hourText:'Hour',minuteText:'Minute',secondText:'Second',millisecText:'Millisecond',timezoneText:'Time Zone'};this._defaults={showButtonPanel:true,timeOnly:false,showHour:true,showMinute:true,showSecond:false,showMillisec:false,showTimezone:false,showTime:true,stepHour:0.05,stepMinute:0.05,stepSecond:0.05,stepMillisec:0.5,hour:0,minute:0,second:0,millisec:0,timezone:'+0000',hourMin:0,minuteMin:0,secondMin:0,millisecMin:0,hourMax:23,minuteMax:59,secondMax:59,millisecMax:999,minDateTime:null,maxDateTime:null,onSelect:null,hourGrid:0,minuteGrid:0,secondGrid:0,millisecGrid:0,alwaysSetTime:true,separator:' ',altFieldTimeOnly:true,showTimepicker:true,timezoneIso8609:false,timezoneList:null};$.extend(this._defaults,this.regional['']);}
$.extend(Timepicker.prototype,{$input:null,$altInput:null,$timeObj:null,inst:null,hour_slider:null,minute_slider:null,second_slider:null,millisec_slider:null,timezone_select:null,hour:0,minute:0,second:0,millisec:0,timezone:'+0000',hourMinOriginal:null,minuteMinOriginal:null,secondMinOriginal:null,millisecMinOriginal:null,hourMaxOriginal:null,minuteMaxOriginal:null,secondMaxOriginal:null,millisecMaxOriginal:null,ampm:'',formattedDate:'',formattedTime:'',formattedDateTime:'',timezoneList:null,setDefaults:function(settings){extendRemove(this._defaults,settings||{});return this;},_newInst:function($input,o){var tp_inst=new Timepicker(),inlineSettings={};for(var attrName in this._defaults){var attrValue=$input.attr('time:'+attrName);if(attrValue){try{inlineSettings[attrName]=eval(attrValue);}catch(err){inlineSettings[attrName]=attrValue;}}}
tp_inst._defaults=$.extend({},this._defaults,inlineSettings,o,{beforeShow:function(input,dp_inst){if($.isFunction(o.beforeShow))
o.beforeShow(input,dp_inst,tp_inst);},onChangeMonthYear:function(year,month,dp_inst){tp_inst._updateDateTime(dp_inst);if($.isFunction(o.onChangeMonthYear))
o.onChangeMonthYear.call($input[0],year,month,dp_inst,tp_inst);},onClose:function(dateText,dp_inst){if(tp_inst.timeDefined===true&&$input.val()!='')
tp_inst._updateDateTime(dp_inst);if($.isFunction(o.onClose))
o.onClose.call($input[0],dateText,dp_inst,tp_inst);},timepicker:tp_inst});tp_inst.amNames=$.map(tp_inst._defaults.amNames,function(val){return val.toUpperCase()});tp_inst.pmNames=$.map(tp_inst._defaults.pmNames,function(val){return val.toUpperCase()});if(tp_inst._defaults.timezoneList===null){var timezoneList=[];for(var i=-11;i<=12;i++)
timezoneList.push((i>=0?'+':'-')+('0'+Math.abs(i).toString()).slice(-2)+'00');if(tp_inst._defaults.timezoneIso8609)
timezoneList=$.map(timezoneList,function(val){return val=='+0000'?'Z':(val.substring(0,3)+':'+val.substring(3));});tp_inst._defaults.timezoneList=timezoneList;}
tp_inst.hour=tp_inst._defaults.hour;tp_inst.minute=tp_inst._defaults.minute;tp_inst.second=tp_inst._defaults.second;tp_inst.millisec=tp_inst._defaults.millisec;tp_inst.ampm='';tp_inst.$input=$input;if(o.altField)
tp_inst.$altInput=$(o.altField).css({cursor:'pointer'}).focus(function(){$input.trigger("focus");});if(tp_inst._defaults.minDate==0||tp_inst._defaults.minDateTime==0)
{tp_inst._defaults.minDate=new Date();}
if(tp_inst._defaults.maxDate==0||tp_inst._defaults.maxDateTime==0)
{tp_inst._defaults.maxDate=new Date();}
if(tp_inst._defaults.minDate!==undefined&&tp_inst._defaults.minDate instanceof Date)
tp_inst._defaults.minDateTime=new Date(tp_inst._defaults.minDate.getTime());if(tp_inst._defaults.minDateTime!==undefined&&tp_inst._defaults.minDateTime instanceof Date)
tp_inst._defaults.minDate=new Date(tp_inst._defaults.minDateTime.getTime());if(tp_inst._defaults.maxDate!==undefined&&tp_inst._defaults.maxDate instanceof Date)
tp_inst._defaults.maxDateTime=new Date(tp_inst._defaults.maxDate.getTime());if(tp_inst._defaults.maxDateTime!==undefined&&tp_inst._defaults.maxDateTime instanceof Date)
tp_inst._defaults.maxDate=new Date(tp_inst._defaults.maxDateTime.getTime());return tp_inst;},_addTimePicker:function(dp_inst){var currDT=(this.$altInput&&this._defaults.altFieldTimeOnly)?this.$input.val()+' '+this.$altInput.val():this.$input.val();this.timeDefined=this._parseTime(currDT);this._limitMinMaxDateTime(dp_inst,false);this._injectTimePicker();},_parseTime:function(timeString,withDate){var regstr=this._defaults.timeFormat.toString().replace(/h{1,2}/ig,'(\\d?\\d)').replace(/m{1,2}/ig,'(\\d?\\d)').replace(/s{1,2}/ig,'(\\d?\\d)').replace(/l{1}/ig,'(\\d?\\d?\\d)').replace(/t{1,2}/ig,this._getPatternAmpm()).replace(/z{1}/ig,'(z|[-+]\\d\\d:?\\d\\d)?').replace(/\s/g,'\\s?')+this._defaults.timeSuffix+'$',order=this._getFormatPositions(),ampm='',treg;if(!this.inst)this.inst=$.datepicker._getInst(this.$input[0]);if(withDate||!this._defaults.timeOnly){var dp_dateFormat=$.datepicker._get(this.inst,'dateFormat');var specials=new RegExp("[.*+?|()\\[\\]{}\\\\]","g");regstr='.{'+dp_dateFormat.length+',}'+this._defaults.separator.replace(specials,"\\$&")+regstr;}
treg=timeString.match(new RegExp(regstr,'i'));if(treg==null&&(!withDate||this._defaults.timeOnly))
{var regstr=this._defaults.timeFormat.toString().replace(/h{1,2}/ig,'(\\d?\\d)').replace(/m{1,2}/ig,'(\\d?\\d)').replace(/:s{1,2}/ig,'').replace(/l{1}/ig,'(\\d?\\d?\\d)').replace(/t{1,2}/ig,this._getPatternAmpm()).replace(/z{1}/ig,'(z|[-+]\\d\\d:?\\d\\d)?').replace(/\s/g,'\\s?')+this._defaults.timeSuffix+'$',order=this._getFormatPositions(),ampm='',treg;treg=timeString.match(new RegExp(regstr,'i'));}
if(treg){if(order.t!==-1){if(treg[order.t]===undefined||treg[order.t].length===0){ampm='';this.ampm='';}else{ampm=$.inArray(treg[order.t].toUpperCase(),this.amNames)!==-1?'AM':'PM';this.ampm=this._defaults[ampm=='AM'?'amNames':'pmNames'][0];}}
if(order.h!==-1){if(ampm=='AM'&&treg[order.h]=='12')
this.hour=0;else if(ampm=='PM'&&treg[order.h]!='12')
this.hour=(parseFloat(treg[order.h])+12).toFixed(0);else this.hour=Number(treg[order.h]);}
if(order.m!==-1)this.minute=Number(treg[order.m]);if(order.s!==-1){this.second=Number(treg[order.s]);if(isNaN(this.second))this.second=0;}
if(order.l!==-1)this.millisec=Number(treg[order.l]);if(order.z!==-1&&treg[order.z]!==undefined){var tz=treg[order.z].toUpperCase();switch(tz.length){case 1:tz=this._defaults.timezoneIso8609?'Z':'+0000';break;case 5:if(this._defaults.timezoneIso8609)
tz=tz.substring(1)=='0000'?'Z':tz.substring(0,3)+':'+tz.substring(3);break;case 6:if(!this._defaults.timezoneIso8609)
tz=tz=='Z'||tz.substring(1)=='00:00'?'+0000':tz.replace(/:/,'');else if(tz.substring(1)=='00:00')
tz='Z';break;}
this.timezone=tz;}
return true;}
return false;},_getPatternAmpm:function(){var markers=[];o=this._defaults;if(o.amNames)
$.merge(markers,o.amNames);if(o.pmNames)
$.merge(markers,o.pmNames);markers=$.map(markers,function(val){return val.replace(/[.*+?|()\[\]{}\\]/g,'\\$&')});return'('+markers.join('|')+')?';},_getFormatPositions:function(){var finds=this._defaults.timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z)/g),orders={h:-1,m:-1,s:-1,l:-1,t:-1,z:-1};if(finds)
for(var i=0;i<finds.length;i++)
if(orders[finds[i].toString().charAt(0)]==-1)
orders[finds[i].toString().charAt(0)]=i+1;return orders;},_injectTimePicker:function(){var $dp=this.inst.dpDiv,o=this._defaults,tp_inst=this,hourMax=(o.hourMax-((o.hourMax-o.hourMin)%o.stepHour)).toFixed(0),minMax=(o.minuteMax-((o.minuteMax-o.minuteMin)%o.stepMinute)).toFixed(0),secMax=(o.secondMax-((o.secondMax-o.secondMin)%o.stepSecond)).toFixed(0),millisecMax=(o.millisecMax-((o.millisecMax-o.millisecMin)%o.stepMillisec)).toFixed(0),dp_id=this.inst.id.toString().replace(/([^A-Za-z0-9_])/g,'');if($dp.find("div#ui-timepicker-div-"+dp_id).length===0&&o.showTimepicker){var noDisplay=' style="display:none;"',html='<div class="ui-timepicker-div" id="ui-timepicker-div-'+dp_id+'"><dl>'+'<dt class="ui_tpicker_time_label" id="ui_tpicker_time_label_'+dp_id+'"'+
((o.showTime)?'':noDisplay)+'>'+o.timeText+'</dt>'+'<dd class="ui_tpicker_time" id="ui_tpicker_time_'+dp_id+'"'+
((o.showTime)?'':noDisplay)+'></dd>'+'<dt class="ui_tpicker_hour_label" id="ui_tpicker_hour_label_'+dp_id+'"'+
((o.showHour)?'':noDisplay)+'>'+o.hourText+'</dt>',hourGridSize=0,minuteGridSize=0,secondGridSize=0,millisecGridSize=0,size;if(o.showHour&&o.hourGrid>0){html+='<dd class="ui_tpicker_hour">'+'<div id="ui_tpicker_hour_'+dp_id+'"'+((o.showHour)?'':noDisplay)+'></div>'+'<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';for(var h=o.hourMin;h<=hourMax;h+=parseInt(o.hourGrid,10)){hourGridSize++;var tmph=(o.ampm&&h>12)?h-12:h;if(tmph<10)tmph='0'+tmph;if(o.ampm){if(h==0)tmph=12+'a';else if(h<12)tmph+='a';else tmph+='p';}
html+='<td>'+tmph+'</td>';}
html+='</tr></table></div>'+'</dd>';}else html+='<dd class="ui_tpicker_hour" id="ui_tpicker_hour_'+dp_id+'"'+
((o.showHour)?'':noDisplay)+'></dd>';html+='<dt class="ui_tpicker_minute_label" id="ui_tpicker_minute_label_'+dp_id+'"'+
((o.showMinute)?'':noDisplay)+'>'+o.minuteText+'</dt>';if(o.showMinute&&o.minuteGrid>0){html+='<dd class="ui_tpicker_minute ui_tpicker_minute_'+o.minuteGrid+'">'+'<div id="ui_tpicker_minute_'+dp_id+'"'+
((o.showMinute)?'':noDisplay)+'></div>'+'<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';for(var m=o.minuteMin;m<=minMax;m+=parseInt(o.minuteGrid,10)){minuteGridSize++;html+='<td>'+((m<10)?'0':'')+m+'</td>';}
html+='</tr></table></div>'+'</dd>';}else html+='<dd class="ui_tpicker_minute" id="ui_tpicker_minute_'+dp_id+'"'+
((o.showMinute)?'':noDisplay)+'></dd>';html+='<dt class="ui_tpicker_second_label" id="ui_tpicker_second_label_'+dp_id+'"'+
((o.showSecond)?'':noDisplay)+'>'+o.secondText+'</dt>';if(o.showSecond&&o.secondGrid>0){html+='<dd class="ui_tpicker_second ui_tpicker_second_'+o.secondGrid+'">'+'<div id="ui_tpicker_second_'+dp_id+'"'+
((o.showSecond)?'':noDisplay)+'></div>'+'<div style="padding-left: 1px"><table><tr>';for(var s=o.secondMin;s<=secMax;s+=parseInt(o.secondGrid,10)){secondGridSize++;html+='<td>'+((s<10)?'0':'')+s+'</td>';}
html+='</tr></table></div>'+'</dd>';}else html+='<dd class="ui_tpicker_second" id="ui_tpicker_second_'+dp_id+'"'+
((o.showSecond)?'':noDisplay)+'></dd>';html+='<dt class="ui_tpicker_millisec_label" id="ui_tpicker_millisec_label_'+dp_id+'"'+
((o.showMillisec)?'':noDisplay)+'>'+o.millisecText+'</dt>';if(o.showMillisec&&o.millisecGrid>0){html+='<dd class="ui_tpicker_millisec ui_tpicker_millisec_'+o.millisecGrid+'">'+'<div id="ui_tpicker_millisec_'+dp_id+'"'+
((o.showMillisec)?'':noDisplay)+'></div>'+'<div style="padding-left: 1px"><table><tr>';for(var l=o.millisecMin;l<=millisecMax;l+=parseInt(o.millisecGrid,10)){millisecGridSize++;html+='<td>'+((l<10)?'0':'')+s+'</td>';}
html+='</tr></table></div>'+'</dd>';}else html+='<dd class="ui_tpicker_millisec" id="ui_tpicker_millisec_'+dp_id+'"'+
((o.showMillisec)?'':noDisplay)+'></dd>';html+='<dt class="ui_tpicker_timezone_label" id="ui_tpicker_timezone_label_'+dp_id+'"'+
((o.showTimezone)?'':noDisplay)+'>'+o.timezoneText+'</dt>';html+='<dd class="ui_tpicker_timezone" id="ui_tpicker_timezone_'+dp_id+'"'+
((o.showTimezone)?'':noDisplay)+'></dd>';html+='</dl></div>';$tp=$(html);if(o.timeOnly===true){$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">'+'<div class="ui-datepicker-title">'+o.timeOnlyTitle+'</div>'+'</div>');$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();}
this.hour_slider=$tp.find('#ui_tpicker_hour_'+dp_id).slider({orientation:"horizontal",value:this.hour,min:o.hourMin,max:hourMax,step:o.stepHour,slide:function(event,ui){tp_inst.hour_slider.slider("option","value",ui.value);tp_inst._onTimeChange();}});this.minute_slider=$tp.find('#ui_tpicker_minute_'+dp_id).slider({orientation:"horizontal",value:this.minute,min:o.minuteMin,max:minMax,step:o.stepMinute,slide:function(event,ui){tp_inst.minute_slider.slider("option","value",ui.value);tp_inst._onTimeChange();}});this.second_slider=$tp.find('#ui_tpicker_second_'+dp_id).slider({orientation:"horizontal",value:this.second,min:o.secondMin,max:secMax,step:o.stepSecond,slide:function(event,ui){tp_inst.second_slider.slider("option","value",ui.value);tp_inst._onTimeChange();}});this.millisec_slider=$tp.find('#ui_tpicker_millisec_'+dp_id).slider({orientation:"horizontal",value:this.millisec,min:o.millisecMin,max:millisecMax,step:o.stepMillisec,slide:function(event,ui){tp_inst.millisec_slider.slider("option","value",ui.value);tp_inst._onTimeChange();}});this.timezone_select=$tp.find('#ui_tpicker_timezone_'+dp_id).append('<select></select>').find("select");$.fn.append.apply(this.timezone_select,$.map(o.timezoneList,function(val,idx){return $("<option />").val(typeof val=="object"?val.value:val).text(typeof val=="object"?val.label:val);}));this.timezone_select.val((typeof this.timezone!="undefined"&&this.timezone!=null&&this.timezone!="")?this.timezone:o.timezone);this.timezone_select.change(function(){tp_inst._onTimeChange();});if(o.showHour&&o.hourGrid>0){size=100*hourGridSize*o.hourGrid/(hourMax-o.hourMin);$tp.find(".ui_tpicker_hour table").css({width:size+"%",marginLeft:(size/(-2*hourGridSize))+"%",borderCollapse:'collapse'}).find("td").each(function(index){$(this).click(function(){var h=$(this).html();if(o.ampm){var ap=h.substring(2).toLowerCase(),aph=parseInt(h.substring(0,2),10);if(ap=='a'){if(aph==12)h=0;else h=aph;}else if(aph==12)h=12;else h=aph+12;}
tp_inst.hour_slider.slider("option","value",h);tp_inst._onTimeChange();tp_inst._onSelectHandler();}).css({cursor:'pointer',width:(100/hourGridSize)+'%',textAlign:'center',overflow:'hidden'});});}
if(o.showMinute&&o.minuteGrid>0){size=100*minuteGridSize*o.minuteGrid/(minMax-o.minuteMin);$tp.find(".ui_tpicker_minute table").css({width:size+"%",marginLeft:(size/(-2*minuteGridSize))+"%",borderCollapse:'collapse'}).find("td").each(function(index){$(this).click(function(){tp_inst.minute_slider.slider("option","value",$(this).html());tp_inst._onTimeChange();tp_inst._onSelectHandler();}).css({cursor:'pointer',width:(100/minuteGridSize)+'%',textAlign:'center',overflow:'hidden'});});}
if(o.showSecond&&o.secondGrid>0){$tp.find(".ui_tpicker_second table").css({width:size+"%",marginLeft:(size/(-2*secondGridSize))+"%",borderCollapse:'collapse'}).find("td").each(function(index){$(this).click(function(){tp_inst.second_slider.slider("option","value",$(this).html());tp_inst._onTimeChange();tp_inst._onSelectHandler();}).css({cursor:'pointer',width:(100/secondGridSize)+'%',textAlign:'center',overflow:'hidden'});});}
if(o.showMillisec&&o.millisecGrid>0){$tp.find(".ui_tpicker_millisec table").css({width:size+"%",marginLeft:(size/(-2*millisecGridSize))+"%",borderCollapse:'collapse'}).find("td").each(function(index){$(this).click(function(){tp_inst.millisec_slider.slider("option","value",$(this).html());tp_inst._onTimeChange();tp_inst._onSelectHandler();}).css({cursor:'pointer',width:(100/millisecGridSize)+'%',textAlign:'center',overflow:'hidden'});});}
var $buttonPanel=$dp.find('.ui-datepicker-buttonpane');if($buttonPanel.length)$buttonPanel.before($tp);else $dp.append($tp);this.$timeObj=$tp.find('#ui_tpicker_time_'+dp_id);if(this.inst!==null){var timeDefined=this.timeDefined;this._onTimeChange();this.timeDefined=timeDefined;}
var onSelectDelegate=function(){tp_inst._onSelectHandler();};this.hour_slider.bind('slidestop',onSelectDelegate);this.minute_slider.bind('slidestop',onSelectDelegate);this.second_slider.bind('slidestop',onSelectDelegate);this.millisec_slider.bind('slidestop',onSelectDelegate);}},_limitMinMaxDateTime:function(dp_inst,adjustSliders){var o=this._defaults,dp_date=new Date(dp_inst.selectedYear,dp_inst.selectedMonth,dp_inst.selectedDay);if(!this._defaults.showTimepicker)return;if($.datepicker._get(dp_inst,'minDateTime')!==null&&$.datepicker._get(dp_inst,'minDateTime')!==undefined&&dp_date){var minDateTime=$.datepicker._get(dp_inst,'minDateTime'),minDateTimeDate=new Date(minDateTime.getFullYear(),minDateTime.getMonth(),minDateTime.getDate(),0,0,0,0);if(this.hourMinOriginal===null||this.minuteMinOriginal===null||this.secondMinOriginal===null||this.millisecMinOriginal===null){this.hourMinOriginal=o.hourMin;this.minuteMinOriginal=o.minuteMin;this.secondMinOriginal=o.secondMin;this.millisecMinOriginal=o.millisecMin;}
if(dp_inst.settings.timeOnly||minDateTimeDate.getTime()==dp_date.getTime()){this._defaults.hourMin=minDateTime.getHours();if(this.hour<=this._defaults.hourMin){this.hour=this._defaults.hourMin;this._defaults.minuteMin=minDateTime.getMinutes();if(this.minute<=this._defaults.minuteMin){this.minute=this._defaults.minuteMin;this._defaults.secondMin=minDateTime.getSeconds();}else if(this.second<=this._defaults.secondMin){this.second=this._defaults.secondMin;this._defaults.millisecMin=minDateTime.getMilliseconds();}else{if(this.millisec<this._defaults.millisecMin)
this.millisec=this._defaults.millisecMin;this._defaults.millisecMin=this.millisecMinOriginal;}}else{this._defaults.minuteMin=this.minuteMinOriginal;this._defaults.secondMin=this.secondMinOriginal;this._defaults.millisecMin=this.millisecMinOriginal;}}else{this._defaults.hourMin=this.hourMinOriginal;this._defaults.minuteMin=this.minuteMinOriginal;this._defaults.secondMin=this.secondMinOriginal;this._defaults.millisecMin=this.millisecMinOriginal;}}
if($.datepicker._get(dp_inst,'maxDateTime')!==null&&$.datepicker._get(dp_inst,'maxDateTime')!==undefined&&dp_date){var maxDateTime=$.datepicker._get(dp_inst,'maxDateTime'),maxDateTimeDate=new Date(maxDateTime.getFullYear(),maxDateTime.getMonth(),maxDateTime.getDate(),0,0,0,0);if(this.hourMaxOriginal===null||this.minuteMaxOriginal===null||this.secondMaxOriginal===null){this.hourMaxOriginal=o.hourMax;this.minuteMaxOriginal=o.minuteMax;this.secondMaxOriginal=o.secondMax;this.millisecMaxOriginal=o.millisecMax;}
if(dp_inst.settings.timeOnly||maxDateTimeDate.getTime()==dp_date.getTime()){this._defaults.hourMax=maxDateTime.getHours();if(this.hour>=this._defaults.hourMax){this.hour=this._defaults.hourMax;this._defaults.minuteMax=maxDateTime.getMinutes();if(this.minute>=this._defaults.minuteMax){this.minute=this._defaults.minuteMax;this._defaults.secondMax=maxDateTime.getSeconds();}else if(this.second>=this._defaults.secondMax){this.second=this._defaults.secondMax;this._defaults.millisecMax=maxDateTime.getMilliseconds();}else{if(this.millisec>this._defaults.millisecMax)this.millisec=this._defaults.millisecMax;this._defaults.millisecMax=this.millisecMaxOriginal;}}else{this._defaults.minuteMax=this.minuteMaxOriginal;this._defaults.secondMax=this.secondMaxOriginal;this._defaults.millisecMax=this.millisecMaxOriginal;}}else{this._defaults.hourMax=this.hourMaxOriginal;this._defaults.minuteMax=this.minuteMaxOriginal;this._defaults.secondMax=this.secondMaxOriginal;this._defaults.millisecMax=this.millisecMaxOriginal;}}
if(adjustSliders!==undefined&&adjustSliders===true){var hourMax=(this._defaults.hourMax-((this._defaults.hourMax-this._defaults.hourMin)%this._defaults.stepHour)).toFixed(0),minMax=(this._defaults.minuteMax-((this._defaults.minuteMax-this._defaults.minuteMin)%this._defaults.stepMinute)).toFixed(0),secMax=(this._defaults.secondMax-((this._defaults.secondMax-this._defaults.secondMin)%this._defaults.stepSecond)).toFixed(0),millisecMax=(this._defaults.millisecMax-((this._defaults.millisecMax-this._defaults.millisecMin)%this._defaults.stepMillisec)).toFixed(0);if(this.hour_slider)
this.hour_slider.slider("option",{min:this._defaults.hourMin,max:hourMax}).slider('value',this.hour);if(this.minute_slider)
this.minute_slider.slider("option",{min:this._defaults.minuteMin,max:minMax}).slider('value',this.minute);if(this.second_slider)
this.second_slider.slider("option",{min:this._defaults.secondMin,max:secMax}).slider('value',this.second);if(this.millisec_slider)
this.millisec_slider.slider("option",{min:this._defaults.millisecMin,max:millisecMax}).slider('value',this.millisec);}},_onTimeChange:function(){var hour=(this.hour_slider)?this.hour_slider.slider('value'):false,minute=(this.minute_slider)?this.minute_slider.slider('value'):false,second=(this.second_slider)?this.second_slider.slider('value'):false,millisec=(this.millisec_slider)?this.millisec_slider.slider('value'):false,timezone=(this.timezone_select)?this.timezone_select.val():false,o=this._defaults;if(typeof(hour)=='object')hour=false;if(typeof(minute)=='object')minute=false;if(typeof(second)=='object')second=false;if(typeof(millisec)=='object')millisec=false;if(typeof(timezone)=='object')timezone=false;if(hour!==false)hour=parseInt(hour,10);if(minute!==false)minute=parseInt(minute,10);if(second!==false)second=parseInt(second,10);if(millisec!==false)millisec=parseInt(millisec,10);var ampm=o[hour<12?'amNames':'pmNames'][0];var hasChanged=(hour!=this.hour||minute!=this.minute||second!=this.second||millisec!=this.millisec||(this.ampm.length>0&&(hour<12)!=($.inArray(this.ampm.toUpperCase(),this.amNames)!==-1))||timezone!=this.timezone);if(hasChanged){if(hour!==false)this.hour=hour;if(minute!==false)this.minute=minute;if(second!==false)this.second=second;if(millisec!==false)this.millisec=millisec;if(timezone!==false)this.timezone=timezone;if(!this.inst)this.inst=$.datepicker._getInst(this.$input[0]);this._limitMinMaxDateTime(this.inst,true);}
if(o.ampm)this.ampm=ampm;this._formatTime();if(this.$timeObj)this.$timeObj.text(this.formattedTime+o.timeSuffix);this.timeDefined=true;if(hasChanged)this._updateDateTime();},_onSelectHandler:function(){var onSelect=this._defaults.onSelect;var inputEl=this.$input?this.$input[0]:null;if(onSelect&&inputEl){onSelect.apply(inputEl,[this.formattedDateTime,this]);}},_formatTime:function(time,format,ampm){if(ampm==undefined)ampm=this._defaults.ampm;time=time||{hour:this.hour,minute:this.minute,second:this.second,millisec:this.millisec,ampm:this.ampm,timezone:this.timezone};var tmptime=(format||this._defaults.timeFormat).toString();var hour=parseInt(time.hour,10);if(ampm){if(!$.inArray(time.ampm.toUpperCase(),this.amNames)!==-1)
hour=hour%12;if(hour===0)
hour=12;}
tmptime=tmptime.replace(/(?:hh?|mm?|ss?|[tT]{1,2}|[lz])/g,function(match){switch(match.toLowerCase()){case'hh':return('0'+hour).slice(-2);case'h':return hour;case'mm':return('0'+time.minute).slice(-2);case'm':return time.minute;case'ss':return('0'+time.second).slice(-2);case's':return time.second;case'l':return('00'+time.millisec).slice(-3);case'z':return time.timezone;case't':case'tt':if(ampm){var _ampm=time.ampm;if(match.length==1)
_ampm=_ampm.charAt(0);return match.charAt(0)=='T'?_ampm.toUpperCase():_ampm.toLowerCase();}
return'';}});if(arguments.length)return tmptime;else this.formattedTime=tmptime;},_updateDateTime:function(dp_inst){dp_inst=this.inst||dp_inst,dt=new Date(dp_inst.selectedYear,dp_inst.selectedMonth,dp_inst.selectedDay),dateFmt=$.datepicker._get(dp_inst,'dateFormat'),formatCfg=$.datepicker._getFormatConfig(dp_inst),timeAvailable=dt!==null&&this.timeDefined;this.formattedDate=$.datepicker.formatDate(dateFmt,(dt===null?new Date():dt),formatCfg);var formattedDateTime=this.formattedDate;if(dp_inst.lastVal!==undefined&&(dp_inst.lastVal.length>0&&this.$input.val().length===0))
return;if(this._defaults.timeOnly===true){formattedDateTime=this.formattedTime;}else if(this._defaults.timeOnly!==true&&(this._defaults.alwaysSetTime||timeAvailable)){formattedDateTime+=this._defaults.separator+this.formattedTime+this._defaults.timeSuffix;}
this.formattedDateTime=formattedDateTime;if(!this._defaults.showTimepicker){this.$input.val(this.formattedDate);}else if(this.$altInput&&this._defaults.altFieldTimeOnly===true){this.$altInput.val(this.formattedTime);this.$input.val(this.formattedDate);}else if(this.$altInput){this.$altInput.val(formattedDateTime);this.$input.val(formattedDateTime);}else{this.$input.val(formattedDateTime);}
this.$input.trigger("change");}});$.fn.extend({timepicker:function(o){o=o||{};var tmp_args=arguments;if(typeof o=='object')tmp_args[0]=$.extend(o,{timeOnly:true});return $(this).each(function(){$.fn.datetimepicker.apply($(this),tmp_args);});},datetimepicker:function(o){o=o||{};var $input=this,tmp_args=arguments;if(typeof(o)=='string'){if(o=='getDate')
return $.fn.datepicker.apply($(this[0]),tmp_args);else
return this.each(function(){var $t=$(this);$t.datepicker.apply($t,tmp_args);});}
else
return this.each(function(){var $t=$(this);$t.datepicker($.timepicker._newInst($t,o)._defaults);});}});$.datepicker._base_selectDate=$.datepicker._selectDate;$.datepicker._selectDate=function(id,dateStr){var inst=this._getInst($(id)[0]),tp_inst=this._get(inst,'timepicker');if(tp_inst){tp_inst._limitMinMaxDateTime(inst,true);inst.inline=inst.stay_open=true;this._base_selectDate(id,dateStr);inst.inline=inst.stay_open=false;this._notifyChange(inst);this._updateDatepicker(inst);}
else this._base_selectDate(id,dateStr);};$.datepicker._base_updateDatepicker=$.datepicker._updateDatepicker;$.datepicker._updateDatepicker=function(inst){var input=inst.input[0];if($.datepicker._curInst&&$.datepicker._curInst!=inst&&$.datepicker._datepickerShowing&&$.datepicker._lastInput!=input){return;}
if(typeof(inst.stay_open)!=='boolean'||inst.stay_open===false){this._base_updateDatepicker(inst);var tp_inst=this._get(inst,'timepicker');if(tp_inst)tp_inst._addTimePicker(inst);}};$.datepicker._base_doKeyPress=$.datepicker._doKeyPress;$.datepicker._doKeyPress=function(event){var inst=$.datepicker._getInst(event.target),tp_inst=$.datepicker._get(inst,'timepicker');if(tp_inst){if($.datepicker._get(inst,'constrainInput')){var ampm=tp_inst._defaults.ampm,dateChars=$.datepicker._possibleChars($.datepicker._get(inst,'dateFormat')),datetimeChars=tp_inst._defaults.timeFormat.toString().replace(/[hms]/g,'').replace(/TT/g,ampm?'APM':'').replace(/Tt/g,ampm?'AaPpMm':'').replace(/tT/g,ampm?'AaPpMm':'').replace(/T/g,ampm?'AP':'').replace(/tt/g,ampm?'apm':'').replace(/t/g,ampm?'ap':'')+" "+
tp_inst._defaults.separator+
tp_inst._defaults.timeSuffix+
(tp_inst._defaults.showTimezone?tp_inst._defaults.timezoneList.join(''):'')+
(tp_inst._defaults.amNames.join(''))+
(tp_inst._defaults.pmNames.join(''))+
dateChars,chr=String.fromCharCode(event.charCode===undefined?event.keyCode:event.charCode);return event.ctrlKey||(chr<' '||!dateChars||datetimeChars.indexOf(chr)>-1);}}
return $.datepicker._base_doKeyPress(event);};$.datepicker._base_doKeyUp=$.datepicker._doKeyUp;$.datepicker._doKeyUp=function(event){var inst=$.datepicker._getInst(event.target),tp_inst=$.datepicker._get(inst,'timepicker');if(tp_inst){if(tp_inst._defaults.timeOnly&&(inst.input.val()!=inst.lastVal)){try{$.datepicker._updateDatepicker(inst);}
catch(err){$.datepicker.log(err);}}}
return $.datepicker._base_doKeyUp(event);};$.datepicker._base_gotoToday=$.datepicker._gotoToday;$.datepicker._gotoToday=function(id){var inst=this._getInst($(id)[0]),$dp=inst.dpDiv;this._base_gotoToday(id);var now=new Date();var tp_inst=this._get(inst,'timepicker');if(tp_inst._defaults.showTimezone&&tp_inst.timezone_select){var tzoffset=now.getTimezoneOffset();var tzsign=tzoffset>0?'-':'+';tzoffset=Math.abs(tzoffset);var tzmin=tzoffset%60
tzoffset=tzsign+('0'+(tzoffset-tzmin)/60).slice(-2)+('0'+tzmin).slice(-2);if(tp_inst._defaults.timezoneIso8609)
tzoffset=tzoffset.substring(0,3)+':'+tzoffset.substring(3);tp_inst.timezone_select.val(tzoffset);}
this._setTime(inst,now);$('.ui-datepicker-today',$dp).click();};$.datepicker._disableTimepickerDatepicker=function(target,date,withDate){var inst=this._getInst(target),tp_inst=this._get(inst,'timepicker');$(target).datepicker('getDate');if(tp_inst){tp_inst._defaults.showTimepicker=false;tp_inst._updateDateTime(inst);}};$.datepicker._enableTimepickerDatepicker=function(target,date,withDate){var inst=this._getInst(target),tp_inst=this._get(inst,'timepicker');$(target).datepicker('getDate');if(tp_inst){tp_inst._defaults.showTimepicker=true;tp_inst._addTimePicker(inst);tp_inst._updateDateTime(inst);}};$.datepicker._setTime=function(inst,date){var tp_inst=this._get(inst,'timepicker');if(tp_inst){var defaults=tp_inst._defaults,hour=date?date.getHours():defaults.hour,minute=date?date.getMinutes():defaults.minute,second=date?date.getSeconds():defaults.second,millisec=date?date.getMilliseconds():defaults.millisec;if((hour<defaults.hourMin||hour>defaults.hourMax)||(minute<defaults.minuteMin||minute>defaults.minuteMax)||(second<defaults.secondMin||second>defaults.secondMax)||(millisec<defaults.millisecMin||millisec>defaults.millisecMax)){hour=defaults.hourMin;minute=defaults.minuteMin;second=defaults.secondMin;millisec=defaults.millisecMin;}
tp_inst.hour=hour;tp_inst.minute=minute;tp_inst.second=second;tp_inst.millisec=millisec;if(tp_inst.hour_slider)tp_inst.hour_slider.slider('value',hour);if(tp_inst.minute_slider)tp_inst.minute_slider.slider('value',minute);if(tp_inst.second_slider)tp_inst.second_slider.slider('value',second);if(tp_inst.millisec_slider)tp_inst.millisec_slider.slider('value',millisec);tp_inst._onTimeChange();tp_inst._updateDateTime(inst);}};$.datepicker._setTimeDatepicker=function(target,date,withDate){var inst=this._getInst(target),tp_inst=this._get(inst,'timepicker');if(tp_inst){this._setDateFromField(inst);var tp_date;if(date){if(typeof date=="string"){tp_inst._parseTime(date,withDate);tp_date=new Date();tp_date.setHours(tp_inst.hour,tp_inst.minute,tp_inst.second,tp_inst.millisec);}
else tp_date=new Date(date.getTime());if(tp_date.toString()=='Invalid Date')tp_date=undefined;this._setTime(inst,tp_date);}}};$.datepicker._base_setDateDatepicker=$.datepicker._setDateDatepicker;$.datepicker._setDateDatepicker=function(target,date){var inst=this._getInst(target),tp_date=(date instanceof Date)?new Date(date.getTime()):date;this._updateDatepicker(inst);this._base_setDateDatepicker.apply(this,arguments);this._setTimeDatepicker(target,tp_date,true);};$.datepicker._base_getDateDatepicker=$.datepicker._getDateDatepicker;$.datepicker._getDateDatepicker=function(target,noDefault){var inst=this._getInst(target),tp_inst=this._get(inst,'timepicker');if(tp_inst){this._setDateFromField(inst,noDefault);var date=this._getDate(inst);if(date&&tp_inst._parseTime($(target).val(),tp_inst.timeOnly))date.setHours(tp_inst.hour,tp_inst.minute,tp_inst.second,tp_inst.millisec);return date;}
return this._base_getDateDatepicker(target,noDefault);};$.datepicker._base_parseDate=$.datepicker.parseDate;$.datepicker.parseDate=function(format,value,settings){var date;try{date=this._base_parseDate(format,value,settings);}catch(err){date=this._base_parseDate(format,value.substring(0,value.length-(err.length-err.indexOf(':')-2)),settings);}
return date;};$.datepicker._base_formatDate=$.datepicker._formatDate;$.datepicker._formatDate=function(inst,day,month,year){var tp_inst=this._get(inst,'timepicker');if(tp_inst)
{if(day)
var b=this._base_formatDate(inst,day,month,year);tp_inst._updateDateTime();return tp_inst.$input.val();}
return this._base_formatDate(inst);}
$.datepicker._base_optionDatepicker=$.datepicker._optionDatepicker;$.datepicker._optionDatepicker=function(target,name,value){var inst=this._getInst(target),tp_inst=this._get(inst,'timepicker');if(tp_inst){var min,max,onselect;if(typeof name=='string'){if(name==='minDate'||name==='minDateTime')
min=value;else if(name==='maxDate'||name==='maxDateTime')
max=value;else if(name==='onSelect')
onselect=value;}else if(typeof name=='object'){if(name.minDate)
min=name.minDate;else if(name.minDateTime)
min=name.minDateTime;else if(name.maxDate)
max=name.maxDate;else if(name.maxDateTime)
max=name.maxDateTime;}
if(min){if(min==0)
min=new Date();else
min=new Date(min);tp_inst._defaults.minDate=min;tp_inst._defaults.minDateTime=min;}else if(max){if(max==0)
max=new Date();else
max=new Date(max);tp_inst._defaults.maxDate=max;tp_inst._defaults.maxDateTime=max;}
else if(onselect)
tp_inst._defaults.onSelect=onselect;}
this._base_optionDatepicker(target,name,value);};function extendRemove(target,props){$.extend(target,props);for(var name in props)
if(props[name]===null||props[name]===undefined)
target[name]=props[name];return target;}
$.timepicker=new Timepicker();$.timepicker.version="0.9.7";})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/splitter/splitter.js $
// Revision: 15685 $

/**
 * utilitaires divers (DOM constantes, position, event target, etc.)
 */
var utils = function()
{
  function getRealTarget(t)
  {
    return t && t.nodeType == document.TEXT_NODE ? t.kNode : t;
  }
 
  function getTarget_IE(e)
  {
    var E = e || window.event;
    return getRealTarget(t = E && E.srcElement ? E.srcElement : null);
  }
 
  function getTarget_W3C(e)
  {
    return getRealTarget(e && e.target ? e.target : null);
  }
  
  function getTarget(e)
  {
    var E = e || window.event;

    if (E && E.srcElement)
    {
      utils.getTarget = getTarget_IE;
      return utils.getTarget(e);
    }
    else if (E && E.target)
    {
      utils.getTarget = getTarget_W3C;
      return utils.getTarget(e);
    }
    return null;
  }
 
  function getX(e)
  {
    var
      E = e || window.event,
      x = E.pageX;
    if (!x && 0 !== x)
      x = E.clientX || 0;
    return x;
  }

  function getY(e)
  {
    var
      E = e || window.event,
      y = E.pageY;
    if (!y && 0 !== y)
      y = E.clientY || 0;
    return y;
  }

  /**
  * Définition des constantes DOM indispensables (ELEMENT_NODE et TEXT_NODE) que certains clients n'exposent pas (comme IE6)
  * @public
  */
  (
    function()
    {
      var
        i,
        D = document,
        T = [
          'ELEMENT_NODE', 'ATTRIBUTE_NODE', 'TEXT_NODE',
          'CDATA_SECTION_NODE', 'ENTITY_REFERENCE_NODE',
          'ENTITY_NODE', 'PROCESSING_INSTRUCTION_NODE',
          'COMMENT_NODE', 'DOCUMENT_NODE', 'DOCUMENT_TYPE_NODE',
          'DOCUMENT_FRAGMENT_NODE', 'DOCUMENT_NOTATION_MODE'
          ];
      for (i = 0; i < T.length; i++)
      {
        if (typeof D[T[i]] == 'undefined' || D[T[i]] === null )
          D[T[i]] = 1 + i;
      }
    }()
  );

  return {
    getX:getX, getY:getY,
    getTarget:getTarget
  }
}();

/**
 * Splitters : Division d'une partie de l'écran en 2 zones : 
 *           |
 *    GAUCHE | DROITE
 *           |        
 */
var splittersV = function()
{
  var source_drag, panels = {}, infos = {};
  var iCloseWidth = 5;
  // Indique si on peut ouvrir/fermer le panneau de gauche via un clic sur son entête
  var bCanClicOnLeftPanel = true;

  /**
   * Le bouton gauche de la souris a été appuyé
   * @param e (event) : événement associé à l'appui sur le bouton gauche de la souris
   * @return boolean : True si l'appui n'a pas été fait sur le séparateur, sinon False
   */
  function mousedown(e)
  {
    var target = utils.getTarget(e);
    // On vérifie que la souris se trouve sur le séparateur et que le panneau de gauche est ouvert
    if (target && target.id == panels.splitV.id && panels.splitOpenState && panels.splitV.enabled)
    {
      document.onmousemove = mousemove;
      document.onmouseup = mouseup;
      source_drag = target;
      return false;
    }
    return true;
  }
 
  /**
   * La souris a été déplacée
   * @param e (event) : événement associé au déplacement de la souris
   * @return true
   */
  function mousemove(e)
  {
    var delta;
    
    if (source_drag)
    {
      delta = utils.getX(e);
      var iWidth = _getScreenWidth();
      if (delta > iWidth - panels.splitV.clientWidth - 50)
        delta = iWidth - panels.splitV.clientWidth - 50;
      
      if (delta < infos.panelLeftMinSize)
        delta = infos.panelLeftMinSize;
      
      source_drag.style.left = delta + "px";

      // Sauvegarde des positions
      infos.panelLeftWidth = _getSizeSplitter(panels.panelLeft.style.width);
      
      // redimensionnement des div
      _resizeDiv();
    }
    return true;
  }
 
  /**
   * Le bouton gauche de la souris a été relâché
   * @param e (event) : événement associé au relâchement du bouton gauche de la souris
   * @return true
   */
  function mouseup(e)
  {
    // ici on peut enregister la position des splitters sur le serveur
    source_drag = null;
    document.onmousemove = null;
    document.onmouseup = null;
    
    // sauvegarde de la position du panneau de gauche
    if (infos.strUrlAjax != '')
      url_ajax(infos.strUrlAjax + '&action=panelLeftWidth&value=' + infos.panelLeftWidth, '');
    
    return true;
  }

  /**
   * Redimensionne les panneaux gauche et droit
   */
  function _resizeDiv()
  {
    var iWidth = _getScreenWidth();
    var splitVLeft = _getSizeSplitter(panels.splitV.style.left)
    var panelLeftWidth = splitVLeft;
    
    panels.panelLeft.style.top = "0px";
    panels.panelLeft.style.left = "0px";
    panels.panelLeft.style.width = panelLeftWidth + "px";
	
	panels.splitController.style.top = "0px";
    panels.splitController.style.left = "0px"; 
    
    var panelRightLeft = panelLeftWidth + panels.splitController.clientWidth + panels.splitV.clientWidth + 5;
    panels.panelRight.style.top = "0px";
    panels.panelRight.style.left = panelRightLeft + "px";
	
	panels.splitV.style.left = panelRightLeft + "px";
  }
  
  /**
   * Positionne le séparateur
   */
  function _resizeScreen ()
  {
    if (panels.panelLeft.clientHeight > panels.panelRight.clientHeight)
      var splitVHeight = panels.panelLeft.clientHeight;
    else
      var splitVHeight = panels.panelRight.clientHeight;
    
    var splitVLeft = infos.panelLeftWidth;
    panels.splitV.style.top = "0px";
    // On vérifie que le panneau de gauche est ouvert
    if (panels.splitOpenState)
      panels.splitV.style.left = splitVLeft + "px";
    else
      panels.splitV.style.left = iCloseWidth + "px";
    panels.splitV.style.height = splitVHeight + "px";

    _resizeDiv();
	//apply_effects();
  }

  /**
   * Récupération d'une valeur écrite en pixel pour la transformer en nombre
   * @param sizePx : Valeur en pixel
   * @return Entier correspondant à la valeur passée
   */
  function _getSizeSplitter(sizePx)
  {
    return parseInt(sizePx.toLowerCase().replace("px", ""));
  }

  /**
   * Récupération de la largeur de l'écran
   */
  function _getScreenWidth()
  {
    if (window.innerWidth)
      iWidth = window.innerWidth;
    else
      iWidth = screen.availWidth;
    
    if (iWidth < 800)
      iWidth = 800;
    
    return (iWidth);
  }
  
  /**
   * Masque le panneau de gauche
   * @param e (event) : événement ayant conduit à l'appel de cette fonction
   * @return true
   */
  function hideLeftPanel(e)
  {
    // Ajout de la fonction permettant de réouvrir le panneau de gauche
    if (bCanClicOnLeftPanel)
    {
      panels.splitController.onmousedown = showLeftPanel;
      panels.splitController.className = "splitter_control_closed";
    }
    else
    {
      panels.splitController.className = "splitter_control_always_closed";
    }
    
    // Indique que le panneau de gauche est fermé
    panels.splitOpenState = false;
    // Sauvegarde de la position du panneau de gauche
    if (infos.strUrlAjax != '')
      url_ajax(infos.strUrlAjax + '&action=panelLeftState&value=false', '');
    
    if (e == null || e == undefined)
    {
      // On cache le panneau de gauche
      panels.panelLeft.style.display = "none";
      panels.panelLeft.style.visibility = "hidden";
	  // On cache le séparateur
	  panels.splitV.style.display = "none";
      panels.splitV.style.visibility = "hidden";
      
      // Redessine le contenu de l'écran
      _resizeScreen();
    }
    else
    {
      $("#modulesContent").animate({width:'toggle'},600, function(){
        // On cache le panneau de gauche
        panels.panelLeft.style.display = "none";
        panels.panelLeft.style.visibility = "hidden";
		// On cache le séparateur
		panels.splitV.style.display = "none";
		panels.splitV.style.visibility = "hidden";
        
        // Redessine le contenu de l'écran
        _resizeScreen();
      });
    }
    
    return (true);
  }
  
  /**
   * Ouverture du panneau de gauche
   * @param e (event) : événement ayant conduit à l'appel de cette fonction
   * @return true
   */
  function showLeftPanel(e)
  {
    // Ajout de la fonction permettant de masquer le panneau de gauche
    if (bCanClicOnLeftPanel)
    {
      panels.splitController.onmousedown = hideLeftPanel;
      panels.splitController.className = "splitter_control_opened";
    }
    else
      panels.splitController.className = "splitter_control_always_opened";
    
    // Indique que le panneau de gauche est ouvert
    panels.splitOpenState = true;
    // Sauvegarde de la position du panneau de gauche
    if (infos.strUrlAjax != '')
      url_ajax(infos.strUrlAjax + '&action=panelLeftState&value=true', '');
      
    if (e == null || e == undefined)
    {
      // On affiche le panneau de gauche
      panels.panelLeft.style.display = "block";
      panels.panelLeft.style.visibility = "visible";
	  // On affiche le séparateur
	  panels.splitV.style.display = "block";
      panels.splitV.style.visibility = "visible";
      
      // Redessine le contenu de l'écran
      _resizeScreen();
    }
    else
    {
      $("#modulesContent").animate({width:'toggle'},600, function(){
        // On affiche le panneau de gauche
        panels.panelLeft.style.display = "block";
        panels.panelLeft.style.visibility = "visible";
		// On affiche le séparateur
		panels.splitV.style.display = "block";
		panels.splitV.style.visibility = "visible";
        
        // Redessine le contenu de l'écran
        _resizeScreen();
      });
    }
    
    return (true);
  }
  
  return {
    /**
     * Fonction initialisant le splitter 
     * @param strUrlAjax (string) : Url d'appel du fichier AJAX servant à suavegarder des infos au niveau PHP
     * @param strLeft (string) : ID du div servant de panneau gauche
     * @param strRight (string) : ID du div servant de panneau droit
     * @param panelLeftWidth (int) : Largeur de départ du panneau gauche 
     * @param panelLeftMinSize (int) : Largeur minimum du panneau de gauche (par défaut = 0)
     * @param bPanelLeftOpened (boolean) : Largeur minimum du panneau de gauche (par défaut = 0)
     */
    init:function(strUrlAjax, strLeft, strRight, panelLeftWidth, panelLeftMinSize, bPanelLeftOpened)
    {
      panels.panelLeft = document.getElementById(strLeft);
      panels.panelLeft.className = "splitter_content_left";
      panels.panelRight = document.getElementById(strRight);
      panels.panelRight.className = "splitter_content";
      
      // On crée un parent dont le style force la position à relative
      // Ainsi, les div enfants seront en position absolue par rapport à ce parent
      
      // -- Création du DIV parent
      var objDiv = document.createElement("DIV");
      objDiv.setAttribute("id", "__splitter_parent_div__");
      // positionnement du DIV avant le panneau de gauche
      panels.panelLeft.parentNode.insertBefore(objDiv, panels.panelLeft);
      // -- positionnement du style position à relatif
      objDivElt = document.getElementById("__splitter_parent_div__");
      objDivElt.style.position = "relative";
      
      // -- Déplacement du panneau gauche
      objTmp = document.createElement("DIV");
      objDivElt.appendChild(objTmp);
      objDivElt.replaceChild(panels.panelLeft, objTmp);
	  
	  // -- Ajout d'une zone permettant de masquer la partie gauche
      panels.splitController = document.createElement("DIV");
      panels.splitController.setAttribute("id", "__splitter_parent_div_control__");
      panels.splitController.setAttribute("class", "splitter_control_opened");
      objDivElt.appendChild(panels.splitController);
      
      // Création du séparateur du séparateur
      panels.splitV = document.createElement("DIV");
      objDiv.setAttribute("id", "__splitter_div__");
      if (false)
      {
        // Active la barre verticale amovible
        panels.splitV.className = "splitter_vertical";
        panels.splitV.enabled = true;
      }
      else
      {
        // Désactive la barre verticale amovible
        panels.splitV.className = "splitter_vertical_disabled";
        panels.splitV.enabled = false
      }
      objDivElt.appendChild(panels.splitV);
      panels.splitV.onmousedown = mousedown;
      
      // Déplacement du panneau droit
      objTmp = document.createElement("DIV");
      objDivElt.appendChild(objTmp);
      objDivElt.replaceChild(panels.panelRight, objTmp);
      
      // On ajoute un style pour les div enfants directs du panneau de gauche
      var node = panels.panelLeft.firstChild;
      while (node != null)
      {
        if (node.nodeName.toUpperCase() == 'DIV')
          node.className = "splitter_content_module";
          
        node = node.nextSibling;
      }
      
      // ** Infos global à la classe
      // URL AJAX pour sauvegarder des infos au niveau du PHP
      infos.strUrlAjax = strUrlAjax;
      // Position du panneau gauche
      infos.panelLeftWidth = panelLeftWidth;
      if (!isNaN(panelLeftMinSize) && !isNaN(parseInt(panelLeftMinSize)) && panelLeftMinSize > 0)
        infos.panelLeftMinSize = panelLeftMinSize;
      else
        infos.panelLeftMinSize = 0;
      
      if (bPanelLeftOpened)
      {
        // Affiche le panneau de gauche
        showLeftPanel(null);
      }
      else
      {
        // Masque le panneau de gauche
        hideLeftPanel(null);
      }
    }
  };
}();

/**
 * Classe pemettant de rendre un panneau rétractable en appuyant sur son entête  
 */
var SplitterPanel = function()
{
  var infos = [];
  
  /**
   * Gère l'agrandissement et la réduction d'un panneau
   * @param strContentDivId (string) : ID du DIV représentant le contenu du panneau
   * @param strControlDivId (string) :  ID du DIV contenant la partie gérant l'ouverture et la fermeture du panneau  
   */
  function _clickPanel(strContentDivId, strControlDivId)
  {
    if (document.getElementById(strContentDivId) != null)
    { 
      if (document.getElementById(strContentDivId).style.display == "block")
        bOpenPanel = false;
      else
        bOpenPanel = true;
        
      _openContent(strContentDivId, strControlDivId, bOpenPanel);
        
      // Sauvegarde de la position du panneau de gauche
      if (infos[strContentDivId].strUrlAjax != '')
      {
        if (bOpenPanel)
          url_ajax(infos[strContentDivId].strUrlAjax + '&action=' + strContentDivId + '&value=true', '');
        else
          url_ajax(infos[strContentDivId].strUrlAjax + '&action=' + strContentDivId + '&value=false', '');
      }
    }
  }
  
  /**
   * Gère l'ouverture et la fermeture du panneau
   * @param strContentDivId (string) : ID du DIV représentant le contenu du panneau
   * @param strControlDivId (string) :  ID du DIV contenant la partie gérant l'ouverture et la fermeture du panneau
   * @param bOpenPanel (boolean) : indique si le panneau est ouvert ou fermé 
   */
  function _openContent(strContentDivId, strControlDivId, bOpenPanel)
  { 
    if (document.getElementById(strContentDivId) != null)
    { 
      if (bOpenPanel)
      {
        document.getElementById(strContentDivId).style.display = "block";
        document.getElementById(strContentDivId).style.visible = "visible";
        
        if (document.getElementById(strControlDivId) != null)
          document.getElementById(strControlDivId).className = "splitter_panel_downed";
      }
      else
      {
        document.getElementById(strContentDivId).style.display = "none";
        document.getElementById(strContentDivId).style.visible = "hidden";
        
        if (document.getElementById(strControlDivId) != null)
          document.getElementById(strControlDivId).className = "splitter_panel_uped";
      }
    }
  }
  
  return {
    /**
     * Génération d'un panneau dont le corps est masquable
     * @param strUrlAjax (string) : Url d'appel du fichier AJAX servant à suavegarder des infos au niveau PHP
     * @param strHeaderDivId (string) : ID du DIV contenant le header du panneau
     * @param strContentDivId (string) : ID du DIV contenant le contenu du panneau affiché lorsque ce dernier est ouvert
     * @param strClassHearderName (string) : Nom de la classe à utiliser pour dans l'entête
     * @param bPanelOpened (boolean) : Indique si le panneau est ouvert par défaut
     */
    createPanel : function (strUrlAjax, strHeaderDivId, strContentDivId, strClassHearderName, bPanelOpened)
    {
      if (document.getElementById(strHeaderDivId) != null && document.getElementById(strContentDivId) != null)
      {
        // URL AJAX pour sauvegarder des infos au niveau du PHP
        infos[strContentDivId] = {};
        infos[strContentDivId].strUrlAjax = strUrlAjax;
        
        // Création d'un DIV parent
        var objDiv = document.createElement("DIV");
        objDiv.setAttribute("id", "__splitter_panel__" + strHeaderDivId);
        // positionnement du DIV avant le panneau
        document.getElementById(strHeaderDivId).parentNode.insertBefore(objDiv, document.getElementById(strHeaderDivId));
        document.getElementById("__splitter_panel__" + strHeaderDivId).style.width = "100%";
        
        // Création de la zone permettant de réduire ou agrandir le panneau
        var objTable = document.createElement("TABLE");
        objTable.setAttribute("cellspacing", "0");
        objTable.setAttribute("cellpadding", "0");
        objTable.setAttribute("width", "100%");
        objTable.className = strClassHearderName;
        objDiv.appendChild(objTable);
        // TBODY obligatoire pour que cela fonctionne sous IE
        var objTbody = document.createElement("TBODY");
        objTable.appendChild(objTbody);
        var objTr = document.createElement("TR");
        objTbody.appendChild(objTr);
        // Récupération du header initial
        var objTd = document.createElement("TD");
        objTr.appendChild(objTd);
        objTd.appendChild(document.getElementById(strHeaderDivId));
        // Création de la partie permettant de réduire / agrandir le panneau 
        var objDiv = document.createElement("DIV");
        objDiv.setAttribute("id", "__splitter_panel_control__" + strHeaderDivId);
        objDiv.setAttribute("style", "float:right;");
        objDiv.innerHTML = "&nbsp;";
        objTd = document.createElement("TD");
        objTd.appendChild(objDiv);
        objTr.appendChild(objTd);
        document.getElementById("__splitter_panel_control__" + strHeaderDivId).onmousedown = function (e) 
          {
            _clickPanel(strContentDivId, "__splitter_panel_control__" + strHeaderDivId);
          }
        
        // Récupération de la partie masquable du panneau
        objTr = document.createElement("TR");
        objTbody.appendChild(objTr);
        var objTd = document.createElement("TD");
        objTd.setAttribute("colspan", "2");
        objTr.appendChild(objTd);
        objTd.appendChild(document.getElementById(strContentDivId));
        
        // Etat du panneau
        _openContent(strContentDivId, "__splitter_panel_control__" + strHeaderDivId, bPanelOpened);
      }
    }
  };
}();
/**
 *
 * Color picker
 * Author: Stefan Petre www.eyecon.ro
 * 
 * Dual licensed under the MIT and GPL licenses
 * 
 */
(function ($) {
	var ColorPicker = function () {
		var
			ids = {},
			inAction,
			charMin = 65,
			visible,
			tpl = '<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',
			defaults = {
				eventName: 'click',
				onShow: function () {},
				onBeforeShow: function(){},
				onHide: function () {},
				onChange: function () {},
				onSubmit: function () {},
				color: 'ff0000',
				livePreview: true,
				flat: false
			},
			fillRGBFields = function  (hsb, cal) {
				var rgb = HSBToRGB(hsb);
				$(cal).data('colorpicker').fields
					.eq(1).val(rgb.r).end()
					.eq(2).val(rgb.g).end()
					.eq(3).val(rgb.b).end();
			},
			fillHSBFields = function  (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(4).val(hsb.h).end()
					.eq(5).val(hsb.s).end()
					.eq(6).val(hsb.b).end();
			},
			fillHexFields = function (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(0).val(HSBToHex(hsb)).end();
			},
			setSelector = function (hsb, cal) {
				$(cal).data('colorpicker').selector.css('backgroundColor', '#' + HSBToHex({h: hsb.h, s: 100, b: 100}));
				$(cal).data('colorpicker').selectorIndic.css({
					left: parseInt(150 * hsb.s/100, 10),
					top: parseInt(150 * (100-hsb.b)/100, 10)
				});
			},
			setHue = function (hsb, cal) {
				$(cal).data('colorpicker').hue.css('top', parseInt(150 - 150 * hsb.h/360, 10));
			},
			setCurrentColor = function (hsb, cal) {
				$(cal).data('colorpicker').currentColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			setNewColor = function (hsb, cal) {
				$(cal).data('colorpicker').newColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			keyDown = function (ev) {
				var pressedKey = ev.charCode || ev.keyCode || -1;
				if ((pressedKey > charMin && pressedKey <= 90) || pressedKey == 32) {
					return false;
				}
				var cal = $(this).parent().parent();
				if (cal.data('colorpicker').livePreview === true) {
					change.apply(this);
				}
			},
			change = function (ev) {
				var cal = $(this).parent().parent(), col;
				if (this.parentNode.className.indexOf('_hex') > 0) {
					cal.data('colorpicker').color = col = HexToHSB(fixHex(this.value));
				} else if (this.parentNode.className.indexOf('_hsb') > 0) {
					cal.data('colorpicker').color = col = fixHSB({
						h: parseInt(cal.data('colorpicker').fields.eq(4).val(), 10),
						s: parseInt(cal.data('colorpicker').fields.eq(5).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(6).val(), 10)
					});
				} else {
					cal.data('colorpicker').color = col = RGBToHSB(fixRGB({
						r: parseInt(cal.data('colorpicker').fields.eq(1).val(), 10),
						g: parseInt(cal.data('colorpicker').fields.eq(2).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(3).val(), 10)
					}));
				}
				if (ev) {
					fillRGBFields(col, cal.get(0));
					fillHexFields(col, cal.get(0));
					fillHSBFields(col, cal.get(0));
				}
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
				cal.data('colorpicker').onChange.apply(cal, [col, HSBToHex(col), HSBToRGB(col)]);
			},
			blur = function (ev) {
				var cal = $(this).parent().parent();
				cal.data('colorpicker').fields.parent().removeClass('colorpicker_focus');
			},
			focus = function () {
				charMin = this.parentNode.className.indexOf('_hex') > 0 ? 70 : 65;
				$(this).parent().parent().data('colorpicker').fields.parent().removeClass('colorpicker_focus');
				$(this).parent().addClass('colorpicker_focus');
			},
			downIncrement = function (ev) {
				var field = $(this).parent().find('input').focus();
				var current = {
					el: $(this).parent().addClass('colorpicker_slider'),
					max: this.parentNode.className.indexOf('_hsb_h') > 0 ? 360 : (this.parentNode.className.indexOf('_hsb') > 0 ? 100 : 255),
					y: ev.pageY,
					field: field,
					val: parseInt(field.val(), 10),
					preview: $(this).parent().parent().data('colorpicker').livePreview					
				};
				$(document).bind('mouseup', current, upIncrement);
				$(document).bind('mousemove', current, moveIncrement);
			},
			moveIncrement = function (ev) {
				ev.data.field.val(Math.max(0, Math.min(ev.data.max, parseInt(ev.data.val + ev.pageY - ev.data.y, 10))));
				if (ev.data.preview) {
					change.apply(ev.data.field.get(0), [true]);
				}
				return false;
			},
			upIncrement = function (ev) {
				change.apply(ev.data.field.get(0), [true]);
				ev.data.el.removeClass('colorpicker_slider').find('input').focus();
				$(document).unbind('mouseup', upIncrement);
				$(document).unbind('mousemove', moveIncrement);
				return false;
			},
			downHue = function (ev) {
				var current = {
					cal: $(this).parent(),
					y: $(this).offset().top
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upHue);
				$(document).bind('mousemove', current, moveHue);
			},
			moveHue = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(4)
						.val(parseInt(360*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.y))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upHue = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upHue);
				$(document).unbind('mousemove', moveHue);
				return false;
			},
			downSelector = function (ev) {
				var current = {
					cal: $(this).parent(),
					pos: $(this).offset()
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upSelector);
				$(document).bind('mousemove', current, moveSelector);
			},
			moveSelector = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(6)
						.val(parseInt(100*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.pos.top))))/150, 10))
						.end()
						.eq(5)
						.val(parseInt(100*(Math.max(0,Math.min(150,(ev.pageX - ev.data.pos.left))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upSelector = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upSelector);
				$(document).unbind('mousemove', moveSelector);
				return false;
			},
			enterSubmit = function (ev) {
				$(this).addClass('colorpicker_focus');
			},
			leaveSubmit = function (ev) {
				$(this).removeClass('colorpicker_focus');
			},
			clickSubmit = function (ev) {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').color;
				cal.data('colorpicker').origColor = col;
				setCurrentColor(col, cal.get(0));
				cal.data('colorpicker').onSubmit(col, HSBToHex(col), HSBToRGB(col), cal.data('colorpicker').el);
			},
			show = function (ev) {
				var cal = $('#' + $(this).data('colorpickerId'));
				cal.data('colorpicker').onBeforeShow.apply(this, [cal.get(0)]);
				var pos = $(this).offset();
				var viewPort = getViewport();
				var top = pos.top + this.offsetHeight;
				var left = pos.left;
				if (top + 176 > viewPort.t + viewPort.h) {
					top -= this.offsetHeight + 176;
				}
				if (left + 356 > viewPort.l + viewPort.w) {
					left -= 356;
				}
				cal.css({left: left + 'px', top: top + 'px'});
				if (cal.data('colorpicker').onShow.apply(this, [cal.get(0)]) != false) {
					cal.show();
				}
				$(document).bind('mousedown', {cal: cal}, hide);
				return false;
			},
			hide = function (ev) {
				if (!isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
					if (ev.data.cal.data('colorpicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
						ev.data.cal.hide();
					}
					$(document).unbind('mousedown', hide);
				}
			},
			isChildOf = function(parentEl, el, container) {
				if (parentEl == el) {
					return true;
				}
				if (parentEl.contains) {
					return parentEl.contains(el);
				}
				if ( parentEl.compareDocumentPosition ) {
					return !!(parentEl.compareDocumentPosition(el) & 16);
				}
				var prEl = el.parentNode;
				while(prEl && prEl != container) {
					if (prEl == parentEl)
						return true;
					prEl = prEl.parentNode;
				}
				return false;
			},
			getViewport = function () {
				var m = document.compatMode == 'CSS1Compat';
				return {
					l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
					t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
					w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
					h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
				};
			},
			fixHSB = function (hsb) {
				return {
					h: Math.min(360, Math.max(0, hsb.h)),
					s: Math.min(100, Math.max(0, hsb.s)),
					b: Math.min(100, Math.max(0, hsb.b))
				};
			}, 
			fixRGB = function (rgb) {
				return {
					r: Math.min(255, Math.max(0, rgb.r)),
					g: Math.min(255, Math.max(0, rgb.g)),
					b: Math.min(255, Math.max(0, rgb.b))
				};
			},
			fixHex = function (hex) {
				var len = 6 - hex.length;
				if (len > 0) {
					var o = [];
					for (var i=0; i<len; i++) {
						o.push('0');
					}
					o.push(hex);
					hex = o.join('');
				}
				return hex;
			}, 
			HexToRGB = function (hex) {
				var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
				return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
			},
			HexToHSB = function (hex) {
				return RGBToHSB(HexToRGB(hex));
			},
			RGBToHSB = function (rgb) {
				var hsb = {
					h: 0,
					s: 0,
					b: 0
				};
				var min = Math.min(rgb.r, rgb.g, rgb.b);
				var max = Math.max(rgb.r, rgb.g, rgb.b);
				var delta = max - min;
				hsb.b = max;
				if (max != 0) {
					
				}
				hsb.s = max != 0 ? 255 * delta / max : 0;
				if (hsb.s != 0) {
					if (rgb.r == max) {
						hsb.h = (rgb.g - rgb.b) / delta;
					} else if (rgb.g == max) {
						hsb.h = 2 + (rgb.b - rgb.r) / delta;
					} else {
						hsb.h = 4 + (rgb.r - rgb.g) / delta;
					}
				} else {
					hsb.h = -1;
				}
				hsb.h *= 60;
				if (hsb.h < 0) {
					hsb.h += 360;
				}
				hsb.s *= 100/255;
				hsb.b *= 100/255;
				return hsb;
			},
			HSBToRGB = function (hsb) {
				var rgb = {};
				var h = Math.round(hsb.h);
				var s = Math.round(hsb.s*255/100);
				var v = Math.round(hsb.b*255/100);
				if(s == 0) {
					rgb.r = rgb.g = rgb.b = v;
				} else {
					var t1 = v;
					var t2 = (255-s)*v/255;
					var t3 = (t1-t2)*(h%60)/60;
					if(h==360) h = 0;
					if(h<60) {rgb.r=t1;	rgb.b=t2; rgb.g=t2+t3}
					else if(h<120) {rgb.g=t1; rgb.b=t2;	rgb.r=t1-t3}
					else if(h<180) {rgb.g=t1; rgb.r=t2;	rgb.b=t2+t3}
					else if(h<240) {rgb.b=t1; rgb.r=t2;	rgb.g=t1-t3}
					else if(h<300) {rgb.b=t1; rgb.g=t2;	rgb.r=t2+t3}
					else if(h<360) {rgb.r=t1; rgb.g=t2;	rgb.b=t1-t3}
					else {rgb.r=0; rgb.g=0;	rgb.b=0}
				}
				return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
			},
			RGBToHex = function (rgb) {
				var hex = [
					rgb.r.toString(16),
					rgb.g.toString(16),
					rgb.b.toString(16)
				];
				$.each(hex, function (nr, val) {
					if (val.length == 1) {
						hex[nr] = '0' + val;
					}
				});
				return hex.join('');
			},
			HSBToHex = function (hsb) {
				return RGBToHex(HSBToRGB(hsb));
			},
			restoreOriginal = function () {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').origColor;
				cal.data('colorpicker').color = col;
				fillRGBFields(col, cal.get(0));
				fillHexFields(col, cal.get(0));
				fillHSBFields(col, cal.get(0));
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
			};
		return {
			init: function (opt) {
				opt = $.extend({}, defaults, opt||{});
				if (typeof opt.color == 'string') {
					opt.color = HexToHSB(opt.color);
				} else if (opt.color.r != undefined && opt.color.g != undefined && opt.color.b != undefined) {
					opt.color = RGBToHSB(opt.color);
				} else if (opt.color.h != undefined && opt.color.s != undefined && opt.color.b != undefined) {
					opt.color = fixHSB(opt.color);
				} else {
					return this;
				}
				return this.each(function () {
					if (!$(this).data('colorpickerId')) {
						var options = $.extend({}, opt);
						options.origColor = opt.color;
						var id = 'collorpicker_' + parseInt(Math.random() * 1000);
						$(this).data('colorpickerId', id);
						var cal = $(tpl).attr('id', id);
						if (options.flat) {
							cal.appendTo(this).show();
						} else {
							cal.appendTo(document.body);
						}
						options.fields = cal
											.find('input')
												.bind('keyup', keyDown)
												.bind('change', change)
												.bind('blur', blur)
												.bind('focus', focus);
						cal
							.find('span').bind('mousedown', downIncrement).end()
							.find('>div.colorpicker_current_color').bind('click', restoreOriginal);
						options.selector = cal.find('div.colorpicker_color').bind('mousedown', downSelector);
						options.selectorIndic = options.selector.find('div div');
						options.el = this;
						options.hue = cal.find('div.colorpicker_hue div');
						cal.find('div.colorpicker_hue').bind('mousedown', downHue);
						options.newColor = cal.find('div.colorpicker_new_color');
						options.currentColor = cal.find('div.colorpicker_current_color');
						cal.data('colorpicker', options);
						cal.find('div.colorpicker_submit')
							.bind('mouseenter', enterSubmit)
							.bind('mouseleave', leaveSubmit)
							.bind('click', clickSubmit);
						fillRGBFields(options.color, cal.get(0));
						fillHSBFields(options.color, cal.get(0));
						fillHexFields(options.color, cal.get(0));
						setHue(options.color, cal.get(0));
						setSelector(options.color, cal.get(0));
						setCurrentColor(options.color, cal.get(0));
						setNewColor(options.color, cal.get(0));
						if (options.flat) {
							cal.css({
								position: 'relative',
								display: 'block'
							});
						} else {
							$(this).bind(options.eventName, show);
						}
					}
				});
			},
			showPicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						show.apply(this);
					}
				});
			},
			hidePicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						$('#' + $(this).data('colorpickerId')).hide();
					}
				});
			},
			setColor: function(col) {
				if (typeof col == 'string') {
					col = HexToHSB(col);
				} else if (col.r != undefined && col.g != undefined && col.b != undefined) {
					col = RGBToHSB(col);
				} else if (col.h != undefined && col.s != undefined && col.b != undefined) {
					col = fixHSB(col);
				} else {
					return this;
				}
				return this.each(function(){
					if ($(this).data('colorpickerId')) {
						var cal = $('#' + $(this).data('colorpickerId'));
						cal.data('colorpicker').color = col;
						cal.data('colorpicker').origColor = col;
						fillRGBFields(col, cal.get(0));
						fillHSBFields(col, cal.get(0));
						fillHexFields(col, cal.get(0));
						setHue(col, cal.get(0));
						setSelector(col, cal.get(0));
						setCurrentColor(col, cal.get(0));
						setNewColor(col, cal.get(0));
					}
				});
			}
		};
	}();
	$.fn.extend({
		ColorPicker: ColorPicker.init,
		ColorPickerHide: ColorPicker.hidePicker,
		ColorPickerShow: ColorPicker.showPicker,
		ColorPickerSetColor: ColorPicker.setColor
	});
})(jQuery)/*!
 * jQuery corner plugin: simple corner rounding
 * Examples and documentation at: http://jquery.malsup.com/corner/
 * version 2.11 (15-JUN-2010)
 * Requires jQuery v1.3.2 or later
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Authors: Dave Methvin and Mike Alsup
 */

/**
 *  corner() takes a single string argument:  $('#myDiv').corner("effect corners width")
 *
 *  effect:  name of the effect to apply, such as round, bevel, notch, bite, etc (default is round). 
 *  corners: one or more of: top, bottom, tr, tl, br, or bl.  (default is all corners)
 *  width:   width of the effect; in the case of rounded corners this is the radius. 
 *           specify this value using the px suffix such as 10px (yes, it must be pixels).
 */
;(function($) { 

var style = document.createElement('div').style,
    moz = style['MozBorderRadius'] !== undefined,
    webkit = style['WebkitBorderRadius'] !== undefined,
    radius = style['borderRadius'] !== undefined || style['BorderRadius'] !== undefined,
    mode = document.documentMode || 0,
    noBottomFold = $.browser.msie && (($.browser.version < 8 && !mode) || mode < 8),

    expr = $.browser.msie && (function() {
        var div = document.createElement('div');
        try { div.style.setExpression('width','0+0'); div.style.removeExpression('width'); }
        catch(e) { return false; }
        return true;
    })();

$.support = $.support || {};
$.support.borderRadius = moz || webkit || radius; // so you can do:  if (!$.support.borderRadius) $('#myDiv').corner();

function sz(el, p) { 
    return parseInt($.css(el,p))||0; 
};
function hex2(s) {
    var s = parseInt(s).toString(16);
    return ( s.length < 2 ) ? '0'+s : s;
};
function gpc(node) {
    while(node) {
        var v = $.css(node,'backgroundColor'), rgb;
        if (v && v != 'transparent' && v != 'rgba(0, 0, 0, 0)') {
            if (v.indexOf('rgb') >= 0) { 
                rgb = v.match(/\d+/g); 
                return '#'+ hex2(rgb[0]) + hex2(rgb[1]) + hex2(rgb[2]);
            }
            return v;
        }
        if (node.nodeName.toLowerCase() == 'html')
            break;
        node = node.parentNode; // keep walking if transparent
    }
    return '#ffffff';
};

function getWidth(fx, i, width) {
    switch(fx) {
    case 'round':  return Math.round(width*(1-Math.cos(Math.asin(i/width))));
    case 'cool':   return Math.round(width*(1+Math.cos(Math.asin(i/width))));
    case 'sharp':  return Math.round(width*(1-Math.cos(Math.acos(i/width))));
    case 'bite':   return Math.round(width*(Math.cos(Math.asin((width-i-1)/width))));
    case 'slide':  return Math.round(width*(Math.atan2(i,width/i)));
    case 'jut':    return Math.round(width*(Math.atan2(width,(width-i-1))));
    case 'curl':   return Math.round(width*(Math.atan(i)));
    case 'tear':   return Math.round(width*(Math.cos(i)));
    case 'wicked': return Math.round(width*(Math.tan(i)));
    case 'long':   return Math.round(width*(Math.sqrt(i)));
    case 'sculpt': return Math.round(width*(Math.log((width-i-1),width)));
    case 'dogfold':
    case 'dog':    return (i&1) ? (i+1) : width;
    case 'dog2':   return (i&2) ? (i+1) : width;
    case 'dog3':   return (i&3) ? (i+1) : width;
    case 'fray':   return (i%2)*width;
    case 'notch':  return width; 
    case 'bevelfold':
    case 'bevel':  return i+1;
    }
};

$.fn.corner = function(options) {
    // in 1.3+ we can fix mistakes with the ready state
    if (this.length == 0) {
        if (!$.isReady && this.selector) {
            var s = this.selector, c = this.context;
            $(function() {
                $(s,c).corner(options);
            });
        }
        return this;
    }

    return this.each(function(index){
        var $this = $(this),
            // meta values override options
            o = [$this.attr($.fn.corner.defaults.metaAttr) || '', options || ''].join(' ').toLowerCase(),
            keep = /keep/.test(o),                       // keep borders?
            cc = ((o.match(/cc:(#[0-9a-f]+)/)||[])[1]),  // corner color
            sc = ((o.match(/sc:(#[0-9a-f]+)/)||[])[1]),  // strip color
            width = parseInt((o.match(/(\d+)px/)||[])[1]) || 10, // corner width
            re = /round|bevelfold|bevel|notch|bite|cool|sharp|slide|jut|curl|tear|fray|wicked|sculpt|long|dog3|dog2|dogfold|dog/,
            fx = ((o.match(re)||['round'])[0]),
            fold = /dogfold|bevelfold/.test(o),
            edges = { T:0, B:1 },
            opts = {
                TL:  /top|tl|left/.test(o),       TR:  /top|tr|right/.test(o),
                BL:  /bottom|bl|left/.test(o),    BR:  /bottom|br|right/.test(o)
            },
            // vars used in func later
            strip, pad, cssHeight, j, bot, d, ds, bw, i, w, e, c, common, $horz;
        
        if ( !opts.TL && !opts.TR && !opts.BL && !opts.BR )
            opts = { TL:1, TR:1, BL:1, BR:1 };
            
        // support native rounding
        if ($.fn.corner.defaults.useNative && fx == 'round' && (radius || moz || webkit) && !cc && !sc) {
            if (opts.TL)
                $this.css(radius ? 'border-top-left-radius' : moz ? '-moz-border-radius-topleft' : '-webkit-border-top-left-radius', width + 'px');
            if (opts.TR)
                $this.css(radius ? 'border-top-right-radius' : moz ? '-moz-border-radius-topright' : '-webkit-border-top-right-radius', width + 'px');
            if (opts.BL)
                $this.css(radius ? 'border-bottom-left-radius' : moz ? '-moz-border-radius-bottomleft' : '-webkit-border-bottom-left-radius', width + 'px');
            if (opts.BR)
                $this.css(radius ? 'border-bottom-right-radius' : moz ? '-moz-border-radius-bottomright' : '-webkit-border-bottom-right-radius', width + 'px');
            return;
        }
            
        strip = document.createElement('div');
        $(strip).css({
            overflow: 'hidden',
            height: '1px',
            minHeight: '1px',
            fontSize: '1px',
            backgroundColor: sc || 'transparent',
            borderStyle: 'solid'
        });
    
        pad = {
            T: parseInt($.css(this,'paddingTop'))||0,     R: parseInt($.css(this,'paddingRight'))||0,
            B: parseInt($.css(this,'paddingBottom'))||0,  L: parseInt($.css(this,'paddingLeft'))||0
        };

        if (typeof this.style.zoom != undefined) this.style.zoom = 1; // force 'hasLayout' in IE
        if (!keep) this.style.border = 'none';
        strip.style.borderColor = cc || gpc(this.parentNode);
        cssHeight = $(this).outerHeight();

        for (j in edges) {
            bot = edges[j];
            // only add stips if needed
            if ((bot && (opts.BL || opts.BR)) || (!bot && (opts.TL || opts.TR))) {
                strip.style.borderStyle = 'none '+(opts[j+'R']?'solid':'none')+' none '+(opts[j+'L']?'solid':'none');
                d = document.createElement('div');
                $(d).addClass('jquery-corner');
                ds = d.style;

                bot ? this.appendChild(d) : this.insertBefore(d, this.firstChild);

                if (bot && cssHeight != 'auto') {
                    if ($.css(this,'position') == 'static')
                        this.style.position = 'relative';
                    ds.position = 'absolute';
                    ds.bottom = ds.left = ds.padding = ds.margin = '0';
                    if (expr)
                        ds.setExpression('width', 'this.parentNode.offsetWidth');
                    else
                        ds.width = '100%';
                }
                else if (!bot && $.browser.msie) {
                    if ($.css(this,'position') == 'static')
                        this.style.position = 'relative';
                    ds.position = 'absolute';
                    ds.top = ds.left = ds.right = ds.padding = ds.margin = '0';
                    
                    // fix ie6 problem when blocked element has a border width
                    if (expr) {
                        bw = sz(this,'borderLeftWidth') + sz(this,'borderRightWidth');
                        ds.setExpression('width', 'this.parentNode.offsetWidth - '+bw+'+ "px"');
                    }
                    else
                        ds.width = '100%';
                }
                else {
                    ds.position = 'relative';
                    ds.margin = !bot ? '-'+pad.T+'px -'+pad.R+'px '+(pad.T-width)+'px -'+pad.L+'px' : 
                                        (pad.B-width)+'px -'+pad.R+'px -'+pad.B+'px -'+pad.L+'px';                
                }

                for (i=0; i < width; i++) {
                    w = Math.max(0,getWidth(fx,i, width));
                    e = strip.cloneNode(false);
                    e.style.borderWidth = '0 '+(opts[j+'R']?w:0)+'px 0 '+(opts[j+'L']?w:0)+'px';
                    bot ? d.appendChild(e) : d.insertBefore(e, d.firstChild);
                }
                
                if (fold && $.support.boxModel) {
                    if (bot && noBottomFold) continue;
                    for (c in opts) {
                        if (!opts[c]) continue;
                        if (bot && (c == 'TL' || c == 'TR')) continue;
                        if (!bot && (c == 'BL' || c == 'BR')) continue;
                        
                        common = { position: 'absolute', border: 'none', margin: 0, padding: 0, overflow: 'hidden', backgroundColor: strip.style.borderColor };
                        $horz = $('<div/>').css(common).css({ width: width + 'px', height: '1px' });
                        switch(c) {
                        case 'TL': $horz.css({ bottom: 0, left: 0 }); break;
                        case 'TR': $horz.css({ bottom: 0, right: 0 }); break;
                        case 'BL': $horz.css({ top: 0, left: 0 }); break;
                        case 'BR': $horz.css({ top: 0, right: 0 }); break;
                        }
                        d.appendChild($horz[0]);
                        
                        var $vert = $('<div/>').css(common).css({ top: 0, bottom: 0, width: '1px', height: width + 'px' });
                        switch(c) {
                        case 'TL': $vert.css({ left: width }); break;
                        case 'TR': $vert.css({ right: width }); break;
                        case 'BL': $vert.css({ left: width }); break;
                        case 'BR': $vert.css({ right: width }); break;
                        }
                        d.appendChild($vert[0]);
                    }
                }
            }
        }
    });
};

$.fn.uncorner = function() { 
    if (radius || moz || webkit)
        this.css(radius ? 'border-radius' : moz ? '-moz-border-radius' : '-webkit-border-radius', 0);
    $('div.jquery-corner', this).remove();
    return this;
};

// expose options
$.fn.corner.defaults = {
    useNative: true, // true if plugin should attempt to use native browser support for border radius rounding
    metaAttr:  'data-corner' // name of meta attribute to use for options
};
    
})(jQuery);
/**
 * @author Terry Wooton
 * @desc Adds a background layer to an element
 * @version 1.1
 * @example
 * $("#element").add_background("url('/test.gif') bottom left no-repeat");
 * @license free
 * @param background css
 *
 */
(function($) {

  $.fn.add_layer = function(bg,params) {
    $(this).each(function() {
  
      s = $(this).extend({},params || {});      
      
      $last = ($(this).find('.add_background:last').length > 0 ? $(this).find('.add_background:last') : $(this));
  		$last.html('<div class="add_background"><div>'+$last.html()+'</div></div>');
  		$last = $(this).find('.add_background:last');
  		$last.css({'background':bg,'width':'100%','height':'100%'});

      $last = $(this).find('.add_background div:last');
            
      if(s.insideCss){
   		  $last.css(s.insideCss);
  		}
      if(s.insideClass)
  		  $last.addClass(s.insideClass);  		  
    });
  }
        
})(jQuery);/**
* hoverIntent is similar to jQuery's built-in "hover" function except that
* instead of firing the onMouseOver event immediately, hoverIntent checks
* to see if the user's mouse has slowed down (beneath the sensitivity
* threshold) before firing the onMouseOver event.
* 
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* hoverIntent is currently available for use in all personal or commercial 
* projects under both MIT and GPL licenses. This means that you can choose 
* the license that best suits your project, and use it accordingly.
* 
* // basic usage (just like .hover) receives onMouseOver and onMouseOut functions
* $("ul li").hoverIntent( showNav , hideNav );
* 
* // advanced usage receives configuration object only
* $("ul li").hoverIntent({
*	sensitivity: 7, // number = sensitivity threshold (must be 1 or higher)
*	interval: 100,   // number = milliseconds of polling interval
*	over: showNav,  // function = onMouseOver callback (required)
*	timeout: 0,   // number = milliseconds delay before onMouseOut function call
*	out: hideNav    // function = onMouseOut callback (required)
* });
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($) {
	$.fn.hoverIntent = function(f,g) {
		// default configuration options
		var cfg = {
			sensitivity: 7,
			interval: 100,
			timeout: 0
		};
		// override configuration options with user supplied object
		cfg = $.extend(cfg, g ? { over: f, out: g } : f );

		// instantiate variables
		// cX, cY = current X and Y position of mouse, updated by mousemove event
		// pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
		var cX, cY, pX, pY;

		// A private function for getting mouse position
		var track = function(ev) {
			cX = ev.pageX;
			cY = ev.pageY;
		};

		// A private function for comparing current and previous mouse position
		var compare = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			// compare mouse positions to see if they've crossed the threshold
			if ( ( Math.abs(pX-cX) + Math.abs(pY-cY) ) < cfg.sensitivity ) {
				$(ob).unbind("mousemove",track);
				// set hoverIntent state to true (so mouseOut can be called)
				ob.hoverIntent_s = 1;
				return cfg.over.apply(ob,[ev]);
			} else {
				// set previous coordinates for next time
				pX = cX; pY = cY;
				// use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
				ob.hoverIntent_t = setTimeout( function(){compare(ev, ob);} , cfg.interval );
			}
		};

		// A private function for delaying the mouseOut function
		var delay = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			ob.hoverIntent_s = 0;
			return cfg.out.apply(ob,[ev]);
		};

		// A private function for handling mouse 'hovering'
		var handleHover = function(e) {
			// copy objects to be passed into t (required for event object to be passed in IE)
			var ev = jQuery.extend({},e);
			var ob = this;

			// cancel hoverIntent timer if it exists
			if (ob.hoverIntent_t) { ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); }

			// if e.type == "mouseenter"
			if (e.type == "mouseenter") {
				// set "previous" X and Y position based on initial entry point
				pX = ev.pageX; pY = ev.pageY;
				// update "current" X and Y position based on mousemove
				$(ob).bind("mousemove",track);
				// start polling interval (self-calling timeout) to compare mouse coordinates over time
				if (ob.hoverIntent_s != 1) { ob.hoverIntent_t = setTimeout( function(){compare(ev,ob);} , cfg.interval );}

			// else e.type == "mouseleave"
			} else {
				// unbind expensive mousemove event
				$(ob).unbind("mousemove",track);
				// if hoverIntent state is true, then call the mouseOut function after the specified delay
				if (ob.hoverIntent_s == 1) { ob.hoverIntent_t = setTimeout( function(){delay(ev,ob);} , cfg.timeout );}
			}
		};

		// bind the function to the two event listeners
		return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover);
	};
})(jQuery);/* Copyright (c) 2009 Brandon Aaron (http://brandonaaron.net)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 *
 * Version: 3.0.2
 * 
 * Requires: 1.2.2+
 */
(function(c){var a=["DOMMouseScroll","mousewheel"];c.event.special.mousewheel={setup:function(){if(this.addEventListener){for(var d=a.length;d;){this.addEventListener(a[--d],b,false)}}else{this.onmousewheel=b}},teardown:function(){if(this.removeEventListener){for(var d=a.length;d;){this.removeEventListener(a[--d],b,false)}}else{this.onmousewheel=null}}};c.fn.extend({mousewheel:function(d){return d?this.bind("mousewheel",d):this.trigger("mousewheel")},unmousewheel:function(d){return this.unbind("mousewheel",d)}});function b(f){var d=[].slice.call(arguments,1),g=0,e=true;f=c.event.fix(f||window.event);f.type="mousewheel";if(f.wheelDelta){g=f.wheelDelta/120}if(f.detail){g=-f.detail/3}d.unshift(f,g);return c.event.handle.apply(this,d)}})(jQuery);/**
 * @see http://github.com/NV/placeholder.js
 */
jQuery.fn.textPlaceholder = function () {

	return this.each(function(){

		var that = this;

		if (that.placeholder && 'placeholder' in document.createElement(that.tagName)) return;

		var placeholder = that.getAttribute('placeholder');
		var input = jQuery(that);

		if (that.value === '' || that.value == placeholder) {
			input.addClass('text-placeholder');
			that.value = placeholder;
		}

		input.focus(function(){
			if (input.hasClass('text-placeholder')) {
				this.value = '';
				input.removeClass('text-placeholder')
			}
		});

		input.blur(function(){
			if (this.value === '') {
				input.addClass('text-placeholder');
				this.value = placeholder;
			} else {
				input.removeClass('text-placeholder');
			}
		});

		that.form && jQuery(that.form).submit(function(){
			if (input.hasClass('text-placeholder')) {
				that.value = '';
			}
		});

	});

};
//////////////////////////////////////////////////////////////////////////////////
// CloudCarousel V1.0.4
// (c) 2010 by R Cecco. <http://www.professorcloud.com>
// MIT License
//
// Reflection code based on plugin by Christophe Beyls <http://www.digitalia.be>
//
// Please retain this copyright header in all versions of the software
//////////////////////////////////////////////////////////////////////////////////
(function($){function Reflection(a,b,c){var d,cntx,imageWidth=a.width,imageHeight=a.width,gradient,parent;parent=$(a.parentNode);if($.browser.msie){this.element=d=parent.append("<img class='reflection' style='position:absolute'/>").find(':last')[0];d.src=a.src;d.style.filter="flipv progid:DXImageTransform.Microsoft.Alpha(opacity="+(c*100)+", style=1, finishOpacity=0, startx=0, starty=0, finishx=0, finishy="+(b/imageHeight*100)+")"}else{this.element=d=parent.append("<canvas class='reflection' style='position:absolute'/>").find(':last')[0];if(!d.getContext){return}cntx=d.getContext("2d");try{$(d).attr({width:imageWidth,height:b});cntx.save();cntx.translate(0,imageHeight-1);cntx.scale(1,-1);cntx.drawImage(a,0,0,imageWidth,imageHeight);cntx.restore();cntx.globalCompositeOperation="destination-out";gradient=cntx.createLinearGradient(0,0,0,b);gradient.addColorStop(0,"rgba(255, 255, 255, "+(1-c)+")");gradient.addColorStop(1,"rgba(255, 255, 255, 1.0)");cntx.fillStyle=gradient;cntx.fillRect(0,0,imageWidth,b)}catch(e){return}}$(d).attr({'alt':$(a).attr('alt'),title:$(a).attr('title')})}var s=function(a,b){this.orgWidth=a.width;this.orgHeight=a.height;this.image=a;this.reflection=null;this.alt=a.alt;this.title=a.title;this.imageOK=false;this.options=b;this.imageOK=true;if(this.options.reflHeight>0){this.reflection=new Reflection(this.image,this.options.reflHeight,this.options.reflOpacity)}$(this.image).css('position','absolute')};var t=function(o,p,q){var r=[],funcSin=Math.sin,funcCos=Math.cos,ctx=this;this.controlTimer=0;this.stopped=false;this.container=o;this.xRadius=q.xRadius;this.yRadius=q.yRadius;this.showFrontTextTimer=0;this.autoRotateTimer=0;if(q.xRadius===0){this.xRadius=($(o).width()/2.3)}if(q.yRadius===0){this.yRadius=($(o).height()/6)}this.xCentre=q.xPos;this.yCentre=q.yPos;this.frontIndex=0;this.rotation=this.destRotation=Math.PI/2;this.timeDelay=1000/q.FPS;if(q.altBox!==null){$(q.altBox).css('display','block');$(q.titleBox).css('display','block')}$(o).css({position:'relative',overflow:'hidden'});$(q.buttonLeft).css('display','inline');$(q.buttonRight).css('display','inline');$(q.buttonLeft).bind('mouseup',this,function(a){a.data.rotate(-1);return false});$(q.buttonRight).bind('mouseup',this,function(a){a.data.rotate(1);return false});if(q.mouseWheel){$(o).bind('mousewheel',this,function(a,b){a.data.rotate(b);return false})}$(o).bind('mouseover click',this,function(a){clearInterval(a.data.autoRotateTimer);var b=$(a.target).attr('alt');if(b!==undefined&&b!==null){clearTimeout(a.data.showFrontTextTimer);$(q.altBox).html(($(a.target).attr('alt')));$(q.titleBox).html(($(a.target).attr('title')));if(q.bringToFront&&a.type=='click'){var c=$(a.target).data('itemIndex');var d=a.data.frontIndex;var e=c-d;a.data.rotate(-e)}}});$(o).bind('mouseout',this,function(a){var b=a.data;clearTimeout(b.showFrontTextTimer);b.showFrontTextTimer=setTimeout(function(){b.showFrontText()},1000);b.autoRotate()});$(o).bind('mousedown',this,function(a){a.data.container.focus();return false});o.onselectstart=function(){return false};this.innerWrapper=$(o).wrapInner('<div style="position:absolute;width:100%;height:100%;"/>').children()[0];this.showFrontText=function(){if(r[this.frontIndex]===undefined){return}$(q.titleBox).html($(r[this.frontIndex].image).attr('title'));$(q.altBox).html($(r[this.frontIndex].image).attr('alt'))};this.go=function(){if(this.controlTimer!==0){return}var a=this;this.controlTimer=setTimeout(function(){a.updateAll()},this.timeDelay)};this.stop=function(){clearTimeout(this.controlTimer);this.controlTimer=0};this.rotate=function(a){this.frontIndex-=a;this.frontIndex%=r.length;this.destRotation+=(Math.PI/r.length)*(2*a);this.showFrontText();this.go()};this.autoRotate=function(){if(q.autoRotate!=='no'){var a=(q.autoRotate==='right')?1:-1;this.autoRotateTimer=setInterval(function(){ctx.rotate(a)},q.autoRotateDelay)}};this.updateAll=function(){var a=q.minScale;var b=(1-a)*0.5;var w,h,x,y,scale,item,sinVal;var c=(this.destRotation-this.rotation);var d=Math.abs(c);this.rotation+=c*q.speed;if(d<0.001){this.rotation=this.destRotation}var e=r.length;var f=(Math.PI/e)*2;var g=this.rotation;var j=$.browser.msie;this.innerWrapper.style.display='none';var k;var l='px',reflHeight;var m=this;for(var i=0;i<e;i++){item=r[i];sinVal=funcSin(g);scale=((sinVal+1)*b)+a;x=this.xCentre+(((funcCos(g)*this.xRadius)-(item.orgWidth*0.5))*scale);y=this.yCentre+(((sinVal*this.yRadius))*scale);if(item.imageOK){var n=item.image;w=n.width=item.orgWidth*scale;h=n.height=item.orgHeight*scale;n.style.left=x+l;n.style.top=y+l;n.style.zIndex=""+(scale*100)>>0;if(item.reflection!==null){reflHeight=q.reflHeight*scale;k=item.reflection.element.style;k.left=x+l;k.top=y+h+q.reflGap*scale+l;k.width=w+l;if(j){k.filter.finishy=(reflHeight/h*100)}else{k.height=reflHeight+l}}}g+=f}this.innerWrapper.style.display='block';if(d>=0.001){this.controlTimer=setTimeout(function(){m.updateAll()},this.timeDelay)}else{this.stop()}};this.checkImagesLoaded=function(){var i;for(i=0;i<p.length;i++){if((p[i].width===undefined)||((p[i].complete!==undefined)&&(!p[i].complete))){return}}for(i=0;i<p.length;i++){r.push(new s(p[i],q));$(p[i]).data('itemIndex',i)}clearInterval(this.tt);this.showFrontText();this.autoRotate();this.updateAll()};this.tt=setInterval(function(){ctx.checkImagesLoaded()},50)};$.fn.CloudCarousel=function(a){this.each(function(){a=$.extend({},{reflHeight:0,reflOpacity:0.5,reflGap:0,minScale:0.5,xPos:0,yPos:0,xRadius:0,yRadius:0,altBox:null,titleBox:null,FPS:30,autoRotate:'no',autoRotateDelay:1500,speed:0.2,mouseWheel:false,bringToFront:false},a);$(this).data('cloudcarousel',new t(this,$('.cloudcarousel',$(this)),a))});return this}})(jQuery);/*!
 * jQuery clueTip plugin v1.2.2
 *
 * Date: Thu Sep 01 11:19:35 2011 EDT
 * Requires: jQuery v1.3+
 *
 * Copyright 2011, Karl Swedberg
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 *
 * Examples can be found at http://plugins.learningjquery.com/cluetip/demo/
 *
*/
(function(c){c.cluetip={version:"1.2.2",template:'<div><div class="cluetip-outer"><h3 class="cluetip-title ui-widget-header ui-cluetip-header"></h3><div class="cluetip-inner ui-widget-content ui-cluetip-content"></div></div><div class="cluetip-extra"></div><div class="cluetip-arrows ui-state-default"></div></div>',setup:{insertionType:"appendTo",insertionElement:"body"},defaults:{multiple:false,width:275,height:"auto",cluezIndex:97,positionBy:"auto",topOffset:15,leftOffset:15,local:false,localPrefix:null,
localIdSuffix:null,hideLocal:true,attribute:"rel",titleAttribute:"title",splitTitle:"",escapeTitle:false,showTitle:true,cluetipClass:"default",hoverClass:"",waitImage:true,cursor:"help",arrows:false,dropShadow:true,dropShadowSteps:6,sticky:false,mouseOutClose:false,activation:"hover",clickThrough:true,tracking:false,delayedClose:0,closePosition:"top",closeText:"Close",truncate:0,fx:{open:"show",openSpeed:""},hoverIntent:{sensitivity:3,interval:50,timeout:0},onActivate:function(){return true},onShow:function(){},
onHide:function(){},ajaxCache:true,ajaxProcess:function(j){return j=j.replace(/<(script|style|title)[^<]+<\/(script|style|title)>/gm,"").replace(/<(link|meta)[^>]+>/g,"")},ajaxSettings:{dataType:"html"},debug:false}};var A,ea=0,M=0;c.fn.attrProp=c.fn.prop||c.fn.attr;c.fn.cluetip=function(j,v){function N(p,r,h){h="";r=r.dropShadow&&r.dropShadowSteps?+r.dropShadowSteps:0;if(c.support.boxShadow){if(r)h="1px 1px "+r+"px rgba(0,0,0,0.5)";p.css(c.support.boxShadow,h);return false}p=p.find("cluetip-drop-shadow");
if(r==p.length)return p;p.remove();p=[];for(h=0;h<r;)p[h++]='<div style="top:'+h+"px;left:"+h+'px;"></div>';return h=c(p.join("")).css({position:"absolute",backgroundColor:"#000",zIndex:S-1,opacity:0.1}).addClass("cluetip-drop-shadow").prependTo("#cluetip")}var d,g,q,B,s,O;if(typeof j=="object"){v=j;j=null}if(j=="destroy"){var P=this.data("cluetip");if(P){c(P.selector).remove();c.removeData(this,"title");c.removeData(this,"cluetip");c(document).unbind(".cluetip");return this.unbind(".cluetip")}}v=
c.extend(true,{},c.cluetip.defaults,v||{});ea++;P=c.cluetip.backCompat||!v.multiple?"cluetip":"cluetip-"+ea;var aa="#"+P,w=c.cluetip.backCompat?"#":".",T=c.cluetip.setup.insertionType,ka=c.cluetip.setup.insertionElement||"body";T=/appendTo|prependTo|insertBefore|insertAfter/.test(T)?T:"appendTo";d=c(aa);if(!d.length){d=c(c.cluetip.template)[T](ka).attr("id",P).css({position:"absolute",display:"none"});var S=+v.cluezIndex;q=d.find(w+"cluetip-outer").css({position:"relative",zIndex:S});g=d.find(w+"cluetip-inner");
B=d.find(w+"cluetip-title")}A=c("#cluetip-waitimage");A.length||(A=c("<div></div>").attr("id","cluetip-waitimage").css({position:"absolute"}));A.insertBefore(d).hide();var la=(parseInt(d.css("paddingLeft"),10)||0)+(parseInt(d.css("paddingRight"),10)||0);this.each(function(p){function r(){return false}var h=this,e=c(this),a=c.extend(true,{},v,c.metadata?e.metadata():c.meta?e.data():e.data("cluetip")||{}),fa=false,I=false,ga=0,m=a[a.attribute]||e.attrProp(a.attribute)||e.attr(a.attribute),Q=a.cluetipClass;
S=+a.cluezIndex;e.data("cluetip",{title:h.title,zIndex:S,selector:aa});if(!m&&!a.splitTitle&&!j)return true;if(a.local&&a.localPrefix)m=a.localPrefix+m;a.local&&a.hideLocal&&m&&c(m+":first").hide();var t=parseInt(a.topOffset,10),C=parseInt(a.leftOffset,10),D,ba,U=isNaN(parseInt(a.height,10))?"auto":/\D/g.test(a.height)?a.height:a.height+"px",V,x,y,J,W,ca=parseInt(a.width,10)||275,n=ca+la+a.dropShadowSteps,F=this.offsetWidth,z,k,o,K,G,u=a.attribute!="title"?e.attrProp(a.titleAttribute):"";if(a.splitTitle){if(u==
undefined)u="";G=u.split(a.splitTitle);u=a.showTitle||G[0]===""?G.shift():""}if(a.escapeTitle)u=u.replace(/&/g,"&amp;").replace(/>/g,"&gt;").replace(/</g,"&lt;");var Z=function(b){var f;if(a.onActivate(e)===false)return false;I=true;d=c(aa).css({position:"absolute"});q=d.find(w+"cluetip-outer");g=d.find(w+"cluetip-inner");B=d.find(w+"cluetip-title");s=d.find(w+"cluetip-arrows");d.removeClass().css({width:ca});m==e.attr("href")&&e.css("cursor",a.cursor);a.hoverClass&&e.addClass(a.hoverClass);x=e.offset().top;
z=e.offset().left;F=e.innerWidth();if(b.type==focus){o=z+F/2+C;d.css({left:k});J=x+t}else{o=b.pageX;J=b.pageY}if(h.tagName.toLowerCase()!="area"){V=c(document).scrollTop();K=c(window).width()}if(a.positionBy=="fixed"){k=F+z+C;d.css({left:k})}else{k=F>z&&z>n||z+F+n+C>K?z-n-C:F+z+C;if(h.tagName.toLowerCase()=="area"||a.positionBy=="mouse"||F+n>K)if(o+20+n>K){d.addClass(" cluetip-"+Q);k=o-n-C>=0?o-n-C-parseInt(d.css("marginLeft"),10)+parseInt(g.css("marginRight"),10):o-n/2}else k=o+C;f=k<0?b.pageY+t:
b.pageY;d.css({left:k>0&&a.positionBy!="bottomTop"?k:o+n/2>K?K/2-n/2:Math.max(o-n/2,0),zIndex:e.data("cluetip").zIndex});s.css({zIndex:e.data("cluetip").zIndex+1})}ba=c(window).height();if(j){if(typeof j=="function")j=j.call(h);g.html(j);L(f)}else if(G){b=G.length;g.html(b?G[0]:"");if(b>1)for(var i=1;i<b;i++)g.append('<div class="split-body">'+G[i]+"</div>");L(f)}else if(!a.local&&m.indexOf("#")!==0)if(/\.(jpe?g|tiff?|gif|png)(?:\?.*)?$/i.test(m)){g.html('<img src="'+m+'" alt="'+u+'" />');L(f)}else{var l=
a.ajaxSettings.beforeSend,X=a.ajaxSettings.error,ha=a.ajaxSettings.success,ia=a.ajaxSettings.complete;b=c.extend(true,{},a.ajaxSettings,{cache:a.ajaxCache,url:m,beforeSend:function(E,H){l&&l.call(h,E,d,g,H);q.children().empty();a.waitImage&&A.css({top:J+20,left:o+20,zIndex:e.data("cluetip").zIndex-1}).show()},error:function(E,H){if(I)X?X.call(h,E,H,d,g):g.html("<i>sorry, the contents could not be loaded</i>")},success:function(E,H){fa=a.ajaxProcess.call(h,E);if(I){ha&&ha.call(h,E,H,d,g);g.html(fa)}},
complete:function(E,H){ia&&ia.call(h,E,H,d,g);var Y=g[0].getElementsByTagName("img");M=Y.length;for(var da=0,ma=Y.length;da<ma;da++)Y[da].complete&&M--;if(M&&!c.browser.opera)c(Y).bind("load error",function(){M--;if(M<1){A.hide();I&&L(f)}});else{A.hide();I&&L(f)}}});c.ajax(b)}else if(a.local){b=c(m+(/#\S+$/.test(m)?"":":eq("+p+")")).clone(true).show();a.localIdSuffix&&b.attr("id",b[0].id+a.localIdSuffix);g.html(b);L(f)}},L=function(b){var f,i;f=u||a.showTitle&&"&nbsp;";var l="";i="";d.addClass("cluetip-"+
Q);if(a.truncate){var X=g.text().slice(0,a.truncate)+"...";g.html(X)}f?B.show().html(f):B.hide();if(a.sticky){f=c('<div class="cluetip-close"><a href="#">'+a.closeText+"</a></div>");a.closePosition=="bottom"?f.appendTo(g):a.closePosition=="title"?f.prependTo(B):f.prependTo(g);f.bind("click.cluetip",function(){R();return false});a.mouseOutClose?d.bind("mouseleave.cluetip",function(){R()}):d.unbind("mouseleave.cluetip")}q.css({zIndex:e.data("cluetip").zIndex,overflow:U=="auto"?"visible":"auto",height:U});
D=U=="auto"?Math.max(d.outerHeight(),d.height()):parseInt(U,10);y=x;W=V+ba;if(a.positionBy=="fixed")y=x-a.dropShadowSteps+t;else if(k<o&&Math.max(k,0)+n>o||a.positionBy=="bottomTop")if(x+D+t>W&&J-V>D+t){y=J-D-t;i="top"}else{y=J+t;i="bottom"}else y=x+D+t>W?D>=ba?V:W-D-t:e.css("display")=="block"||h.tagName.toLowerCase()=="area"||a.positionBy=="mouse"?b-t:x-a.dropShadowSteps;if(i==="")i=k<z?"left":"right";f=" clue-"+i+"-"+Q+" cluetip-"+Q;if(Q=="rounded")f+=" ui-corner-all";d.css({top:y+"px"}).attrProp({className:"cluetip ui-widget ui-widget-content ui-cluetip"+
f});if(a.arrows){if(/(left|right)/.test(i)){i=d.height()-s.height();l=k>=0&&b>0?x-y-a.dropShadowSteps:0;l=i>l?l:i;l+="px"}s.css({top:l}).show()}else s.hide();(O=N(d,a))&&O.length&&O.hide().css({height:D,width:ca,zIndex:e.data("cluetip").zIndex-1}).show();d.hide()[a.fx.open](a.fx.openSpeed||0);c.fn.bgiframe&&d.bgiframe();if(a.delayedClose>0)ga=setTimeout(R,a.delayedClose);a.onShow.call(h,d,g)},$=function(){I=false;A.hide();if(!a.sticky||/click|toggle/.test(a.activation)){R();clearTimeout(ga)}a.hoverClass&&
e.removeClass(a.hoverClass)},R=function(b){b=b&&b.data("cluetip")?b:e;var f=b.data("cluetip").selector;f=c(f);var i=f.find(w+"cluetip-inner"),l=f.find(w+"cluetip-arrows");f.hide().removeClass();a.onHide.call(b[0],f,i);b.removeClass("cluetip-clicked");u&&b.attrProp(a.titleAttribute,u);b.css("cursor","");a.arrows&&l.css({top:""})};c(document).unbind("hideCluetip.cluetip").bind("hideCluetip.cluetip",function(b){R(c(b.target))});if(/click|toggle/.test(a.activation))e.bind("click.cluetip",function(b){if(d.is(":hidden")||
!e.is(".cluetip-clicked")){Z(b);c(".cluetip-clicked").removeClass("cluetip-clicked");e.addClass("cluetip-clicked")}else $(b);return false});else if(a.activation=="focus"){e.bind("focus.cluetip",function(b){e.attrProp("title","");Z(b)});e.bind("blur.cluetip",function(b){e.attrProp("title",e.data("cluetip").title);$(b)})}else{e[a.clickThrough?"unbind":"bind"]("click.cluetip",r);var ja=function(b){if(a.tracking){var f=k-b.pageX,i=y?y-b.pageY:x-b.pageY;e.bind("mousemove.cluetip",function(l){d.css({left:l.pageX+
f,top:l.pageY+i})})}};c.fn.hoverIntent&&a.hoverIntent?e.hoverIntent({sensitivity:a.hoverIntent.sensitivity,interval:a.hoverIntent.interval,over:function(b){Z(b);ja(b)},timeout:a.hoverIntent.timeout,out:function(b){$(b);e.unbind("mousemove.cluetip")}}):e.bind("mouseenter.cluetip",function(b){Z(b);ja(b)}).bind("mouseleave.cluetip",function(b){$(b);e.unbind("mousemove.cluetip")});e.bind("mouseover.cluetip",function(){e.attrProp("title","")}).bind("mouseleave.cluetip",function(){e.attrProp("title",e.data("cluetip").title)})}});
return this};(function(){c.support=c.support||{};for(var j=document.createElement("div").style,v=["boxShadow"],N=["moz","Moz","webkit","o"],d=0,g=v.length;d<g;d++){var q=v[d],B=q.charAt(0).toUpperCase()+q.slice(1);if(typeof j[q]!=="undefined")c.support[q]=q;else for(var s=0,O=N.length;s<O;s++)if(typeof j[N[s]+B]!=="undefined"){c.support[q]=N[s]+B;break}}})();c.fn.cluetip.defaults=c.cluetip.defaults})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/utils/jquery.browserInformation.js $
// Revision: 15633 $

(function ($){

  /**
   * Browser Information
   */
  $.browserInformation = {
   
    	/**
	     * Parse User Agent
	     */
		_parseUA : function (agent) {

			var numberify = function(s) {
				var c = 0;
				return parseFloat(s.replace(/\./g, function() {
					return (c++ == 1) ? '' : '.';
				}));
			},

			nav = navigator,

			o = {

			/**
			 * Internet Explorer version number or 0.  Example: 6
			 * @property ie
			 * @type float
			 * @static
			 */
			ie: 0,
      
      /**
       * Internet Explorer Trident version number or 0.  Example: 4 for IE8
       * @property trident
       * @type float
       * @static
       */
      trident: 0,

			/**
			 * Opera version number or 0.  Example: 9.2
			 * @property opera
			 * @type float
			 * @static
			 */
			opera: 0,

			/**
			 * Gecko engine revision number.  Will evaluate to 1 if Gecko
			 * is detected but the revision could not be found. Other browsers
			 * will be 0.  Example: 1.8
			 * <pre>
			 * Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
			 * Firefox 1.5.0.9: 1.8.0.9 <-- 1.8
			 * Firefox 2.0.0.3: 1.8.1.3 <-- 1.81
			 * Firefox 3.0   <-- 1.9
			 * Firefox 3.5   <-- 1.91
			 * </pre>
			 * @property gecko
			 * @type float
			 * @static
			 */
			gecko: 0,

			/**
			 * AppleWebKit version.  KHTML browsers that are not WebKit browsers
			 * will evaluate to 1, other browsers 0.  Example: 418.9
			 * <pre>
			 * Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the
			 *                                   latest available for Mac OSX 10.3.
			 * Safari 2.0.2:         416     <-- hasOwnProperty introduced
			 * Safari 2.0.4:         418     <-- preventDefault fixed
			 * Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
			 *                                   different versions of webkit
			 * Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
			 *                                   updated, but not updated
			 *                                   to the latest patch.
			 * Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native
			 * SVG and many major issues fixed).
			 * Safari 3.0.4 (523.12) 523.12  <-- First Tiger release - automatic
			 * update from 2.x via the 10.4.11 OS patch.
			 * Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
			 *                                   yahoo.com user agent hack removed.
			 * </pre>
			 * http://en.wikipedia.org/wiki/Safari_version_history
			 * @property webkit
			 * @type float
			 * @static
			 */
			webkit: 0,

			/**
			 * Chrome will be detected as webkit, but this property will also
			 * be populated with the Chrome version number
			 * @property chrome
			 * @type float
			 * @static
			 */
			chrome: 0,

			/**
			 * The mobile property will be set to a string containing any relevant
			 * user agent information when a modern mobile browser is detected.
			 * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
			 * devices with the WebKit-based browser, and Opera Mini.
			 * @property mobile
			 * @type string
			 * @static
			 */
			mobile: null,

			/**
			 * The device property will be set to a string containing 
			 * Desktop/iPhone/iPod/iPad/Android Phone/Android Tablet ...
			 * @property device
			 * @type string
			 * @static
			 */
			device: null,
			
			/**
			 * Adobe AIR version number or 0.  Only populated if webkit is detected.
			 * Example: 1.0
			 * @property air
			 * @type float
			 */
			air: 0,
			/**
			 * Detects Apple iPad's OS version
			 * @property ipad
			 * @type float
			 * @static
			 */
			ipad: 0,
			/**
			 * Detects Apple iPhone's OS version
			 * @property iphone
			 * @type float
			 * @static
			 */
			iphone: 0,
			/**
			 * Detects Apples iPod's OS version
			 * @property ipod
			 * @type float
			 * @static
			 */
			ipod: 0,
			/**
			 * General truthy check for iPad, iPhone or iPod
			 * @property ios
			 * @type float
			 * @static
			 */
			ios: null,
			/**
			 * Detects Googles Android OS version
			 * @property android
			 * @type float
			 * @static
			 */
			android: 0,
			/**
			 * Detects Palms WebOS version
			 * @property webos
			 * @type float
			 * @static
			 */
			webos: 0,

			/**
			 * Google Caja version number or 0.
			 * @property caja
			 * @type float
			 */
			caja: nav && nav.cajaVersion,

			/**
			 * Set to true if the page appears to be in SSL
			 * @property secure
			 * @type boolean
			 * @static
			 */
			secure: false,

			/**
			 * The operating system.  Currently only detecting windows or macintosh
			 * @property os
			 * @type string
			 * @static
			 */
			os: null,
			
			/**
			 * The original userAgent string
			 * @property ua
			 * @type string
			 * @static
			 */
			ua: agent || (navigator && navigator.userAgent)

		},

		ua = o.ua,

		loc = window && window.location,

		href = loc && loc.href,

		m;

		o.secure = href && (href.toLowerCase().indexOf("https") === 0);

		if (ua) {

			o.device = 'Desktop';
			if ((/windows|win32/i).test(ua)) {
				o.os = 'windows';
			} else if ((/macintosh/i).test(ua)) {
				o.os = 'macintosh';
			} else if ((/rhino/i).test(ua)) {
				o.os = 'rhino';
			}

			// Modern KHTML browsers should qualify as Safari X-Grade
			if ((/KHTML/).test(ua)) {
				o.webkit = 1;
			}
			// Modern WebKit browsers are at least X-Grade
			m = ua.match(/AppleWebKit\/([^\s]*)/);
			if (m && m[1]) {
				o.webkit = numberify(m[1]);

				// Mobile browser check
				if (/ Mobile\//.test(ua)) {
					o.mobile = 'Apple'; // iPhone or iPod Touch

					m = ua.match(/OS ([^\s]*)/);
					if (m && m[1]) {
						m = numberify(m[1].replace('_', '.'));
					}
					o.ios = m;
					o.ipad = o.ipod = o.iphone = 0;

					m = ua.match(/iPad|iPod|iPhone/);
					if (m && m[0]) {
						o[m[0].toLowerCase()] = o.ios;
						o.device = m[0];
					}
				} else {
					m = ua.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);
					if (m) {
						// Nokia N-series, Android, webOS, ex: NokiaN95
						o.mobile = m[0];
						o.device = o.mobile;
					}
					if (/webOS/.test(ua)) {
						o.mobile = 'WebOS';
						o.device = o.mobile;
						m = ua.match(/webOS\/([^\s]*);/);
						if (m && m[1]) {
							o.webos = numberify(m[1]);
						}
					}
					if (/ Android/.test(ua)) {
						o.mobile = 'Android';
						m = ua.match(/Android ([^\s]*);/);
						if (m && m[1]) {
							o.android = numberify(m[1]);
						}
						//Android Phone or Android Tablet
						m = ua.match(/ Mobile /);
						if (m && m[0]) {
							o.device = 'Android Phone';
						}
						else
						{
							o.device = 'Android Tablet';
						}

					}
				}

				m = ua.match(/Chrome\/([^\s]*)/);
				if (m && m[1]) {
					o.chrome = numberify(m[1]); // Chrome
				} else {
					m = ua.match(/AdobeAIR\/([^\s]*)/);
					if (m) {
						o.air = m[0]; // Adobe AIR 1.0 or better
					}
				}
			}

			if (!o.webkit) { // not webkit
			// @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
				m = ua.match(/Opera[\s\/]([^\s]*)/);
				if (m && m[1]) {
					o.opera = numberify(m[1]);
					m = ua.match(/Version\/([^\s]*)/);
					if (m && m[1]) {
						o.opera = numberify(m[1]); // opera 10+
					}
					m = ua.match(/Opera Mini[^;]*/);
					if (m) {
						o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
						o.device = o.mobile;
					}
				} else { // not opera or webkit
					m = ua.match(/MSIE\s([^;]*)/);
					if (m && m[1]) {
						o.ie = numberify(m[1]);
            m = ua.match(/Trident\/([^;]*)/);
            if (m && m[1]) {
              o.trident = numberify(m[1]);
            }
					} else { // not opera, webkit, or ie
						m = ua.match(/Gecko\/([^\s]*)/);
						if (m) {
							o.gecko = 1; // Gecko detected, look for revision
							m = ua.match(/rv:([^\s\)]*)/);
							if (m && m[1]) {
								o.gecko = numberify(m[1]);
							}
						}
					}
				}
			}
		}

		return o;
	},

	
	/**
     * User Agent Object
     * */
    UA : null,
	
	/**
     * Detect browser Opera
     * */
    isOpera : function (){
      return (this.UA.opera > 0);
    },
	
	/**
     * Detect browser Safari
     * */
    isSafari : function (){
      return (this.UA.webkit > 0 && this.UA.chrome == 0);
    },
	
	/**
     * Detect browser Chrome
     * */
    isChrome : function (){
      return (this.UA.webkit > 0 && this.UA.chrome > 0);
    },
	
	/**
     * Detect browser Gecko
     * */
    isGecko : function (){
      return (this.UA.gecko > 0);
    },
	
	/**
     * Detect browser Android
     * */
    isAndroid : function (){
      return (this.UA.android > 0);
    },
	
	/**
     * Detect browser Android Phone
     * */
    isAndroidPhone : function (){
      return (this.UA.android > 0 && this.UA.device == 'Android Phone');
    },
	
	/**
     * Detect browser Android Tablet
     * */
    isAndroidTablet : function (){
      return (this.UA.android > 0 && this.UA.device == 'Android Tablet');
    },
	
	/**
     * Detect browser IE older than IE 7
     * */
    isLtIE7 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie < 7)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE older than IE 8
     * */
    isLtIE8 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie < 8 && this.UA.trident < 4)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE older than IE 9
     * */
    isLtIE9 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie < 9 && this.UA.trident < 5)
          return (true);
      }
      
      return (false);
    },
	/**
     * Detect browser IE
     * */
    isIE : function (){
      return (this.UA.ie > 0);
    },
	/**
     * Detect browser IE 6
     * */
    isIE6 : function (){
      return (this.UA.ie == 6);
    },
    /**
     * Detect browser IE 7
     * */
    isIE7 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie == 7 && this.UA.trident == 0 && !document.documentMode)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE 8
     * */
    isIE8 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie <= 8 && this.UA.trident == 4 && document.documentMode == 8)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE 9
     * */
    isIE9 : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie <= 9 && this.UA.trident == 5 && document.documentMode == 9)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE 7 Simulated
     * */
    isIE7Simulated : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie > 7 && document.documentMode == 7)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE 8 Simulated
     * */
    isIE8Simulated : function (){
      if ($.browser.msie)
      {
        if (this.UA.ie > 8 && document.documentMode == 8)
          return (true);
      }
      
      return (false);
    },
    /**
     * Detect browser IE older than IE 9 & Simulated
     * */
    isLtIE9Simulated : function (){
      return (this.isIE7Simulated() || this.isIE8Simulated());
    }
  }
  
  $.browserInformation.UA = $.browserInformation._parseUA();
  
})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/utils/jquery.longPolling.js $
// Revision: 16470 $
(function ($){

  /**
   * Manage Communication between JS and Easyvista
   */
  $.longPolling = {
    _iStartingTimeOut : 0,
    _iTimeOut : 30000,
    _bStarted : false,
    _sUrl : get_main_directory() + 'utils/longPolling.php?session_id=' + get_session_id() + '&uniqid=' + get_session_uniqid(),
    _enabled : true,
    _aListeners : [],
    
    /**
     * Attach a Listener
     * 
     * @param sId Id of the event listened
     * @param fCallback Callback function called when event appears
     */
    addEventListener : function (sId, fCallback){
      if (!$.longPolling._enabled) return;
      $.post(this._sUrl, { action : "addEventListener", id: sId } );
      this._aListeners.push({ id : sId, callback : fCallback});
      
      if (!this._bStarted)
      {
        this._bStarted = true;
        if (this._iStartingTimeOut > 0)
          setTimeout("$.longPolling._start();", this._iStartingTimeOut);
        else
          $.longPolling._start();
      }
    },
    
    /**
     * Remove a Listener
     * 
     * @param sId Id of the event listened
     * @param fCallback Callback function called when event appears
     */
    removeEventListener : function (sId, fCallback){
      if (fCallback != null)
      {
        var aListeners = [];
        for (iIdx in this._aListeners)
        {
          if (this._aListeners[iIdx].id != sId || this._aListeners[iIdx].callback != fCallback)
            aListeners.push(this._aListeners[iIdx]);
        }
        this._aListeners = aListeners;
      }
      $.post(this._sUrl, { action : "removeEventListener", id: sId } );
    },
    
    /**
     * Invokes a method of Easyvista once
     * @param sId Id of the method
     * @param fCallback Callback function called if the request succeeds and returns a result
     */
    callMethod : function (sId, fCallback){
	  $(document).ready(function (){
        if (fCallback == null)
          $.post($.longPolling._sUrl, { action : "callMethod", id: sId } );
        else
          $.ajax({
            type: "POST",
            url: $.longPolling._sUrl,
            dataType: "json",
            success: function (oRes) { if (oRes == null) return; if (oRes.hasOwnProperty(sId)) fCallback(oRes[sId]); else fCallback(); },
            data: { action : "callMethod", id: sId }
            });
      });
    },
    
    /**
     * @private Asks Easyvista if an event has been sent
     */
    _start : function (){
      $(document).ready(function (){
        if ($.longPolling._enabled)
          $.ajax({
            type: "GET",
            url: $.longPolling._sUrl,
            dataType: "json",
            success: $.longPolling._complete,
            error: $.longPolling._error
            });
      });
    },
    
    /**
     * @private Get Error Response
     */
     _error : function (e, xhr, settings, exception) {
     	if ($.longPolling._iTimeOut > 0)
        setTimeout("$.longPolling._start();", $.longPolling._iTimeOut);
      else if ($.longPolling._iTimeOut == 0)
        $.longPolling._start();
      else
        $.longPolling._bStarted = false;
     },
     
    /**
     * @private Get and Treat Easyvista Response
     * @param oDatas Object sent by easyvista
     */
    _complete : function (oDatas) {
      if ($.longPolling._aListeners.length == 0)
      {
        $.longPolling._bStarted = false;
        return;
      }
      
      if (oDatas != null && oDatas != '')
      {
        var oDatasUsed = {};
        for (iIdx in $.longPolling._aListeners)
        {
          if (oDatas.hasOwnProperty($.longPolling._aListeners[iIdx].id))
            oDatasUsed[$.longPolling._aListeners[iIdx].id] = {callback : $.longPolling._aListeners[iIdx].callback, param : oDatas[$.longPolling._aListeners[iIdx].id]}; 
        }
        /* Callback in a second time because callback can change content of $.longPolling._aListeners */
        for (sIdx in oDatasUsed) oDatasUsed[sIdx].callback(oDatasUsed[sIdx].param);
        /* Remove unused listener */
        for (sIdx in oDatas)
        {
          if (!oDatasUsed.hasOwnProperty(sIdx))
            $.post($.longPolling._sUrl, { action : "removeEventListener", id: sIdx } );
        }
      }
      
      if ($.longPolling._iTimeOut > 0)
        setTimeout("$.longPolling._start();", $.longPolling._iTimeOut);
      else if ($.longPolling._iTimeOut == 0)
        $.longPolling._start();
      else
        $.longPolling._bStarted = false;
    }
  }
  
})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/slideToolbox/jquery.slideToolboxWizard.js $
// Revision: 16022 $

(function ($){

  $.slideToolboxWizard = {
    /**
     * JQuery Object
     */
    _oId : null,
    
    /**
     * Internal Id
     */
    _internalId : 'slideToolboxWizard',
    
    /**
     * @private Time Before Close Dialog
     */
    _iWaitingTime : 1000,
    
    /**
     * Content Width
     */
    _icontentWidth : 0,
    
    /**
     * Adjust height content
     *
     * @return integer as downed height of slideToolBox Content
     */
    _getDownedHeight : function (){
      var content = this._oId.find(".slideToolboxContent");
      var downedHeight = this._oId.find(".slideToolboxOpenCloseWrap").width() - (content.outerHeight() - content.height());
      
      return (downedHeight);
    },
    
    /**
     * Positionning top
     */
    _adjustTop : function (){
      var lbl = this._oId.find(".slideToolboxLabel");
      /* <= IE8 : rotate and translate origin */
      if ($.browserInformation.isLtIE9() || $.browserInformation.isLtIE9Simulated())
      {
        var labelLeft = lbl.outerHeight() - lbl.outerWidth();
        lbl.css("left", labelLeft + "px"); //origin: right top
      }
      else
      {
        var labelTop = lbl.width() + parseInt(lbl.css("padding-left")) + parseInt(lbl.css("padding-right"));
        lbl.css("top", labelTop + "px");
      }

      this._oId.css("top", parseInt($("#slideToolboxTools").css("top")) + parseInt($("#slideToolboxTools .slideToolboxContent").outerHeight())+ 10 + "px");
    },
    
    /**
     * @private Use to detect Enter and Exit of the component
     */
    _cpt : 0,
    
    /**
     * @private Mouse Enter
     */
    _mouseEnterSlideToolbox : function(e){
        $.slideToolboxWizard._cpt++;
        $.slideToolboxWizard.showSlideToolbox();
    },
    
     /**
     * @private Mouse Leave
     */
    _mouseLeaveSlideToolbox : function(e){
      $.slideToolboxWizard._cpt--;
      if ($.slideToolboxWizard._cpt == 0) 
      $.slideToolboxWizard.hideSlideToolbox();
    },
    
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    
    /**
     * init slideToolbox
     */
    _init : function (){
      if (this._oId == null)
      {
        if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
        var classCSS_Browser = this._internalId + ' ' + this._internalId + 'IE7';
        else if ($.browserInformation.isIE8() || $.browserInformation.isIE8Simulated())
        var classCSS_Browser = this._internalId + ' ' + this._internalId + 'IE8';
        else
        var classCSS_Browser = this._internalId;
        
        /* slideToolbox Creation */
        $("#mainContent").append('<div id="' + this._internalId + '" class="slideToolbox ' + classCSS_Browser + '"></div>');
        this._oId = $("#" + this._internalId);
  
        /* Others Wizards */
        var others = $("#divDown_actionsOthers");
        others.remove();
        $("#mainContent").append(others);
        others.find('.slideToolboxLessOpacity').corner("bottom");
        
        /* Content */ 
        this._oId.append('<div class="slideToolboxContent topBarColor bottomBarColor" style="display: none;"></div>');
        var content = this._oId.find(".slideToolboxContent");
        /* OpenClose */
        this._oId.append('<div class="slideToolboxOpenCloseWrap"><div class="tabSelected slideToolboxLabel"></div></div>');
        
        /* Icon */
        var lbl = this._oId.find(".slideToolboxLabel");
        lbl.append('<div class="rodWizard"></div>');
        
        /* Label */
        lbl.append('<div class="Caption" style="float:left;"></div>');
        var lblCaption = this._oId.find(".slideToolboxLabel .Caption");
        var _this = this;
        //var urlLoadCaption = get_main_directory() + "ajax_slideToolbox.php?session_id=" + get_session_id() + "slideToolbox" + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&action=get_text&text=WIZARD_CAPTION";
        /*
        this._oId.find(".slideToolboxLabel .Caption").load(urlLoadCaption, function() {
          $(this).width($(this).parent().width() - $(this).parent().find(".rodWizard").width());
          $.slideToolboxWizard._adjustTop();
          content.height($.slideToolboxWizard._oId.find(".slideToolboxOpenCloseWrap").width() - (content.outerHeight() - content.height()));
        });
        */
        var wizardCaption = $("#slideToolboxWizardCaption").text();
        lblCaption.text(wizardCaption);
        lblCaption.width( lblCaption.parent().width() - lblCaption.parent().find(".rodWizard").width() );
        $.slideToolboxWizard._adjustTop();
        content.height($.slideToolboxWizard._oId.find(".slideToolboxOpenCloseWrap").width() - (content.outerHeight() - content.height()));
        
        /* Manage Mouse event */
        this._oId.hoverIntent({
          over: $.slideToolboxWizard._mouseEnterSlideToolbox,  // function = onMouseOver callback (required)
          timeout: $.slideToolboxWizard._iWaitingTime,   // number = milliseconds delay before onMouseOut function call
          out: $.slideToolboxWizard._mouseLeaveSlideToolbox    // function = onMouseOut callback (required)
        });
        others.hoverIntent({
          over: $.slideToolboxWizard._mouseEnterSlideToolbox,  // function = onMouseOver callback (required)
          timeout: $.slideToolboxWizard._iWaitingTime,   // number = milliseconds delay before onMouseOut function call
          out: $.slideToolboxWizard._mouseLeaveSlideToolbox    // function = onMouseOut callback (required)
        });
        
        /* Apply Corner */
        lbl.corner("bottom");
        var slideToolboxLabelCorner = this._oId.find(".slideToolboxLabel .jquery-corner");
        slideToolboxLabelCorner.css("top", "0px"); //fix bug IE7 IE8
        slideToolboxLabelCorner.css("left", "-30px"); //fix bug IE7 IE8
        
        this._adjustTop();
      }
    },
    
    /**
     * Manage Others Wizards List
     * */
    _manageOthers : function (){
      var oContent = this._oId.find(".slideToolboxContent");
      var others = $("#divDown_actionsOthers");
      if (others.length > 0)
      {
        var notification = $("#notificationToolbarWrap");
        if (notification.length == 1)
        {
          var iBottom = parseInt(notification.offset().top);
        }
        else
          var iBottom = $(window).height();
		iBottom = iBottom - $(document).scrollTop() - 20;
        
        var pos = oContent.offset();
        var iTop = parseInt(pos.top) + oContent.height() - $(document).scrollTop() - 5;
        var iHeight = iBottom - iTop;
        if (others.is(':hidden'))
        {
          var othersList = others.find('.otherswzd');
          others.css('top', iTop + "px");
          others.height(0);
          others.width(oContent.width() + 40);
          othersList.width(oContent.width());
          others.show();
          var iHeightTable = othersList.find('table').height() + parseInt(othersList.css('top')) + 2;
          if (iHeightTable < iHeight)
            iHeight = iHeightTable;
          othersList.height(iHeight - parseInt(othersList.css('top')) - 2);
          others.find('.slideToolboxLessOpacity').height(iHeight);
          oContent.css('border-bottom-width', '0px');
          $("#tr_more_wiz div").removeClass("splitter_panel_uped").addClass("splitter_panel_downed");
          $("#tr_more_wiz #less_wizards").show();
          $("#tr_more_wiz #more_wizards").hide();
          others.animate({height : iHeight}, 600);
        }
        else
        {
          $("#tr_more_wiz div").removeClass("splitter_panel_downed").addClass("splitter_panel_uped");
          $("#tr_more_wiz #less_wizards").hide();
          $("#tr_more_wiz #more_wizards").show();
          others.animate({height : '-=' + iHeight}, 600, function () { 
              others.hide(); 
              oContent.css('border-bottom-width', oContent.css('border-top-width'));
            });
        }
      }
    },
    
    /**
     * Create slideToolbox
     */
    create : function (){
      var divContent = $("#divDown_actions")
      if (divContent.length != 1) return;
      this._init();
      var content = this._oId.find(".slideToolboxContent");
      content.html(divContent.html());
      content.height(this._getDownedHeight());
	  //IE7 : width = 100% => pb
	  if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
	  this._oId.find(".slideToolboxContent .dialog_arrow_down_popup").css("width", "1%");
      
	  var others = $("#divDown_actionsOthers");
      if (others.length > 0 && others.width() + 40 > content.width())
        this._icontentWidth = others.width() + 40;
      else
        this._icontentWidth = content.width();
      $("#tr_more_wiz div").click(function () { $.slideToolboxWizard._changeOthersVisibility(false); });
    },
    
    /**
     * show SlideToolbox
     */
    showSlideToolbox : function(){
      if (this._oId == null)
      return;
      
      var oContent = this._oId.find(".slideToolboxContent");
      if (oContent.is(':visible'))
        return;
        
      oContent.width(1);
      oContent.show();
      oContent.animate({width:this._icontentWidth}, 600);
    },
    
     /**
     * hide SlideToolbox
     */
    hideSlideToolbox : function(){
      if (this._oId == null)
        return;
      
      var oContent = this._oId.find(".slideToolboxContent");
      if (oContent.is(':hidden'))
        return;

      var oContent = this._oId.find(".slideToolboxContent");
      this._changeOthersVisibility(true);
      oContent.animate({width: '-=' + this._icontentWidth}, 600, function () { oContent.hide(); oContent.css('width', ''); });
    },
    
    /**
     * Change Others List Visibility
     * 
     * bForceHide If true, it forces to hide Others Wizards List 
     */
    _changeOthersVisibility : function(bForceHide){
      if (bForceHide)
      {
        var others = $("#divDown_actionsOthers");
        if (others.length > 0 && others.is(':visible'))
        {
          $("#tr_more_wiz div").toggleClass("splitter_panel_downed splitter_panel_uped");
          $("#tr_more_wiz #less_wizards").hide();
          $("#tr_more_wiz #more_wizards").show();
          others.hide();
          var oContent = this._oId.find(".slideToolboxContent");
          oContent.css('border-bottom-width', oContent.css('border-top-width'));
        }
        return;
      }
      this._manageOthers();
    }
    
  }
  
})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/slideToolbox/jquery.slideToolboxTools.js $
// Revision: 16022 $

(function ($){
  
  $.slideToolboxTools = {
    /**
     * JQuery Object
     */
    _oId : null,
    
    /**
     * Internal Id
     */
    _internalId : 'slideToolboxTools',
    
    /**
     * @private Mouse Over The Dialog
     */
    _bOverDialog : false,
    
    /**
     * @private Time Before Close Dialog
     */
    _iWaitingTime : 1000,
    
    /**
     * @private Starting Time used to try to close Dialog
     */
    _iStartingEndOfTime : 0,
    
    /**
     * True if slideToolbox is hidden
     */
    _isHidden : true,
    
    /**
     * Adjust height content
     *
     * @return integer as downed height of slideToolBox Content
     */
    _getDownedHeight : function (){
      if (this._oId == null)
        return;
      
      var downedHeight = this._oId.find(".slideToolboxOpenCloseWrap").width() - (this._oId.find(".slideToolboxContent").outerHeight() - this._oId.find(".slideToolboxContent").height());
      
      return (downedHeight);
    },
    
    /**
     * Adjust height content
     */
    _adjustHeightContent : function (){
      if (this._oId == null)
        return;
      
      this._oId.find(".slideToolboxContent").css("height", this._getDownedHeight() + "px");
      
    },
    
    /**
     * Positionning top
     */
    _adjustTop : function (){
      if (this._oId == null)
        return;

      /* <= IE8 : rotate and translate origin */
      if ($.browserInformation.isLtIE9() || $.browserInformation.isLtIE9Simulated())
      {
        this._oId.find(".slideToolboxLabel").css("left", this._oId.find(".slideToolboxLabel").outerHeight() - this._oId.find(".slideToolboxLabel").outerWidth() + "px"); //origin: right top
      }
      else
      {
        var labelTop = this._oId.find(".slideToolboxLabel").width() + parseInt(this._oId.find(".slideToolboxLabel").css("padding-left")) + parseInt(this._oId.find(".slideToolboxLabel").css("padding-right"));
        this._oId.find(".slideToolboxLabel").css("top", labelTop + "px");
      }

      /* Positionning top */
	  var iDelta = 40;
      if ($("#DIV_GRID_CAPTION").length == 1)
      {
        this._oId.css("top", $("#DIV_GRID_CAPTION").offset().top + $("#DIV_GRID_CAPTION").outerHeight(true) + iDelta + "px");
      }
      if ($("#DIV_DIALOG_CAPTION").length == 1)
      {
        this._oId.css("top", $("#DIV_DIALOG_CAPTION").offset().top + $("#DIV_DIALOG_CAPTION").outerHeight(true) + iDelta + "px");
      }
      
    },
    
    /**
     * @private Mouse Enter
     */
    _mouseEnterSlideToolbox : function(e){
        $.slideToolboxTools._bOverDialog = true;
        
        /*$(this).delay(1000,function(){
          $.slideToolboxTools.showSlideToolbox();
        });*/
        
        //setTimeout("$.slideToolboxTools.showSlideToolbox();", $.slideToolboxTools._iWaitingTime);
        
        $.slideToolboxTools.showSlideToolbox();
    },
    
     /**
     * @private Mouse Leave
     */
    _mouseLeaveSlideToolbox : function(e){
      $.slideToolboxTools._bOverDialog = false;
      
      var out = false;
      if (isIE)
      {
        if (!this.contains(e.toElement))
        out = true;
      }
      else
      {
        if (!this.contains(e.relatedTarget))
        out = true;
      }
      
      /*$(this).delay(1000,function(){
        $.slideToolboxTools.hideSlideToolbox();
      });*/
      
      //setTimeout("$.slideToolboxTools.hideSlideToolbox();", $.slideToolboxTools._iWaitingTime);
      //$.slideToolboxTools._manageAutoCloseDialog();
      
      if (out)
      $.slideToolboxTools.hideSlideToolbox();
    },
    
    /**
     * @private Management Close Dialog
     */
    _manageAutoCloseDialog : function (){
      // Start Timer ?
      if (!$.slideToolboxTools.isHidden())
      {
        $.slideToolboxTools._iStartingEndOfTime = new Date().getTime();
        setTimeout("$.slideToolboxTools._manageAutoCloseDialogTimerFunction(" + $.slideToolboxTools._iStartingEndOfTime + ");", $.slideToolboxTools._iWaitingTime);
      }
    },
    
    /**
     * @private Management Close Dialog
     */
    _manageAutoCloseDialogTimerFunction : function (iStartTime){
      if (!$.slideToolboxTools.isHidden() && !$.slideToolboxTools._bOverDialog && iStartTime == $.slideToolboxTools._iStartingEndOfTime) 
      {
        $.slideToolboxTools.hideSlideToolbox()
      }
    },
    
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    
    /**
     * Create a slideToolbox
     */
    create : function (){
      if ($("#" + this._internalId).length == 0)
      {
        if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
        var classCSS_Browser = this._internalId + ' ' + this._internalId + 'IE7';
        else if ($.browserInformation.isIE8() || $.browserInformation.isIE8Simulated())
        var classCSS_Browser = this._internalId + ' ' + this._internalId + 'IE8';
        else
        var classCSS_Browser = this._internalId; 
        
        /* slideToolbox Creation */
        $("#mainContent").append('<div id="' + this._internalId + '" class="slideToolbox ' + classCSS_Browser + '"></div>');
        this._oId = $("#" + this._internalId);
        var _oId = $("#" + this._internalId);
  
        /* Content */ 
        this._oId.append('<div class="slideToolboxContent" style="display: none;"></div>');
        
        var urlLoadContent = get_main_directory() + "ajax_slideToolbox.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&action=refresh&type=tools"; 
        this._oId.find(".slideToolboxContent").load(urlLoadContent, function() {
          var downedHeight = _oId.find(".slideToolboxOpenCloseWrap").width() - (_oId.find(".slideToolboxContent").outerHeight() - _oId.find(".slideToolboxContent").height());
          _oId.find(".slideToolboxContent").css("height", downedHeight + "px");
          _oId.find(".slideToolboxContent > table").css("width", _oId.find(".slideToolboxOpenCloseWrap").width() + "px");
          
          if (_oId.find(".slideToolboxContent > table").children().length == 0)
          _oId.hide();
        });
        
        /* OpenClose */
        this._oId.append('<div class="slideToolboxOpenCloseWrap"><div class="slideToolboxLabel"></div></div>');
        
        /* Icon */
        this._oId.find(".slideToolboxLabel").append('<div class="rodTools"></div>');
        
        /* Label */
        this._oId.find(".slideToolboxLabel").append('<div class="Caption"></div>');
        var lblCaption = this._oId.find(".slideToolboxLabel .Caption");
        var _this = this;
        //var urlLoadCaption = get_main_directory() + "ajax_slideToolbox.php?session_id=" + get_session_id() + "slideToolbox" + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&action=get_text&text=TOOLS_CAPTION";
        /*
        this._oId.find(".slideToolboxLabel .Caption").load(urlLoadCaption, function() {
          $(this).css("width", $(this).parent().width() - $(this).parent().find(".rodTools").width() + "px");
          
          _this._adjustTop();
          
          var downedHeight = _oId.find(".slideToolboxOpenCloseWrap").width() - (_oId.find(".slideToolboxContent").outerHeight() - _oId.find(".slideToolboxContent").height());
          _oId.find(".slideToolboxContent").css("height", downedHeight + "px");
        });
        */
        var toolsCaption = $("#slideToolboxToolsCaption").text();
        lblCaption.text(toolsCaption);
        lblCaption.css("width", lblCaption.parent().width() - lblCaption.parent().find(".rodTools").width() + "px");
        _this._adjustTop();
        var downedHeight = _oId.find(".slideToolboxOpenCloseWrap").width() - (_oId.find(".slideToolboxContent").outerHeight() - _oId.find(".slideToolboxContent").height());
        _oId.find(".slideToolboxContent").css("height", downedHeight + "px");
        
        /* OpenCloseImg */
        //this._oId.find(".slideToolboxLabel").append('<div class="OpenCloseImg splitter_panel_closed_from_right"></div>');
        /* OpenClose onclick */
        this._oId.find(".OpenCloseImg").click( function() {
          $(this).toggleClass("splitter_panel_opened_from_right splitter_panel_closed_from_right");
          _oId.find(".slideToolboxContent").animate({width:'toggle'},600);
        });
        
        /* Apply Corner */
        this._oId.find(".slideToolboxLabel").corner("bottom");
        this._oId.find(".slideToolboxLabel .jquery-corner").css("top", "0px"); //fix bug IE7 IE8
        this._oId.find(".slideToolboxLabel .jquery-corner").css("left", "-30px"); //fix bug IE7 IE8
        
        /* Manage Mouse event */
        this._oId.hoverIntent({
          over: $.slideToolboxTools._mouseEnterSlideToolbox,  // function = onMouseOver callback (required)
          timeout: $.slideToolboxTools._iWaitingTime,   // number = milliseconds delay before onMouseOut function call
          out: $.slideToolboxTools._mouseLeaveSlideToolbox    // function = onMouseOut callback (required)
        });
        
        
        this._adjustTop();
        
        this._adjustHeightContent();
        
      }
    },
    
    /**
     * show SlideToolbox
     */
    showSlideToolbox : function(){
        if (this._oId == null)
        return;
        
        this._oId.find(".OpenCloseImg").toggleClass("splitter_panel_opened_from_right splitter_panel_closed_from_right");
        this._oId.find(".slideToolboxContent").animate({width:'toggle'},600);
    },
    
     /**
     * hide SlideToolbox
     */
    hideSlideToolbox : function(){
      if (this._oId == null)
        return;
        
      this._oId.find(".OpenCloseImg").toggleClass("splitter_panel_opened_from_right splitter_panel_closed_from_right");
      this._oId.find(".slideToolboxContent").animate({width:'toggle'},600);
    },
    
    /**
     * Indicates if slideToolbox is hidden
     * 
     * @return true if slideToolbox is hidden else false
     */
    isHidden : function (){ 
      if (this._oId == null)
        return;
        
      if (_oId.find(".slideToolboxContent").width() <= 1)
      this._isHidden = true;
      else
      this._isHidden = false;
      
      return (this._isHidden); 
    },
    
    /**
     * Change slideToolbox Content
     * 
     * @param sContent Content to assign
     */
    content : function (sContent){
      if (this._oId == null)
        return;
      
      this._oId.find(".slideToolboxContent").html(sContent);
      this._adjustHeightContent();
      
    }
    
  }
  
})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/notification/jquery.notificationToolbar.js $
// Revision: 14679 $

/***********************************************************\
|*                                                         *|
|*      Footer Toolbar (Plugin for Jquery Library)         *|
|*                                                         *|
\***********************************************************/

(function ($){

  /**
   * Add a vertical Toolbar on the bottom of the screen
   * 
   * @param sSession PHP Session information
   * @param sStylePath Root directory of Style
   */
  $.notificationToolbar = function ()
  {
    /* Detect browser IE older than IE 7*/
    if ($.browserInformation.isLtIE7())
      return;
    
    /* Image path */
    sStylePath = get_atmosphere() + '/../';
	
    /* Toolbar Creation */
    if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
    $(document.body).append('<div id="notificationToolbarWrap" class="notificationToolbarWrapIE7"><div id="notificationToolbarContent"></div><div id="notificationToolbarContentReduce"></div></div>');
    else if ($.browserInformation.isIE8() || $.browserInformation.isIE8Simulated())
    $(document.body).append('<div id="notificationToolbarWrap" class="notificationToolbarWrapIE8"><div id="notificationToolbarContent"></div><div id="notificationToolbarContentReduce"></div></div>');
    else
    $(document.body).append('<div id="notificationToolbarWrap"><div id="notificationToolbarContent"></div><div id="notificationToolbarContentReduce"></div></div>');
    // Opacity
    //$('#notificationToolbarWrap').fadeTo("fast", 0.9);
	
    /* Content Areas */
	$('#notificationToolbarContent').append('<ul class="start"></ul><ul class="end"></ul>');
    var oStart = $('#notificationToolbarContent .start');
    var oEnd = $('#notificationToolbarContent .end');
    
    /* First Part */
    // User Information
    oStart.append('<li class="userInformation"> </li>');
    $.userInformation.init(oStart.find('.userInformation')); 
    // Separator
    oStart.append('<li class="separator"/>');
    // Get indicators
    oStart.append('<li class="dashboardNotification"> </li>');
    $.dashboard.get(oStart.find('.dashboardNotification')); 
    // Separator
    oStart.append('<li class="separator"/>');
    // Get news
    oStart.append('<li class="newsNotification"> </li>');
    $.news.get(oStart.find('.newsNotification'));
    
    // Separator
    oStart.append('<li class="separator"/>');
    
    // Separator
    //oEnd.append('<li class="separator"/>');

    /* Chat Part */
    if ($.chatDialog != undefined)
    {
      // Chat Icon
      oEnd.append('<li class="chatImg"></li>');
      /* Chat Action */
      var oChatAction = $('#notificationToolbarContent .chatImg');
      oChatAction.mouseover(function (){
        $.chatDialog.create();
        var iPadding = parseInt($('#notificationToolbarContent .reduce').css('top'));if (isNaN(iPadding)) iPadding = 0;
        iPadding += $('#notificationToolbarContent .reduce img').height();
        $.chatDialog.position({'bottom' : $('#notificationToolbarContent').height() - iPadding, 'left' : $(this).offset().left - 200});
        
        if ($('#chatMainContainer').length == 0)
        $.chatDialog.content('<div id="chatMainContainer" class="dialog_line"></div>', 'chatBox');
        
        $.connectionXMPP.initChat('chatMainContainer');
        
        $.chatDialog.show();
        $(this).mouseenter(function (e) {$.chatDialog.externalComponentUsage('chatBox', true);});
        $(this).mouseleave(function (e) {$.chatDialog.externalComponentUsage('chatBox', false);});
      });
    }
    
    // Reduce Toolbar
    oEnd.append('<li class="reduce"> <img src="' + sStylePath + 'notification/images/ico-notification-tirette-replier.png"/> </li>');
    
    /* Reduce Toolbar Action */
    var oReduceAction = $('#notificationToolbarContent .reduce img');
    oReduceAction.click(function (){ 
      var bottom = "-45px";
      if (($(window).width() + 17) < $(document).width() && $.browserInformation.isIE9())
      {
        //-- If horizontal scrollbar visible && IE9 
        bottom = "-25px";
      }
      
      $('#notificationToolbarWrap').animate({"bottom": bottom}, 1000, function(){
        $('#notificationToolbarContent').css("display", "none");
        $('#notificationToolbarContentReduce').css("display", "block"); 
      });
	  
	  $.get("./toolbar/toolbarInformation.php?session_id=" + get_session_id() + "&uniqid=" + get_session_uniqid() + "&ajax_action=set&property=state&value=0");
    });
    
    /** Closed Toolbar **/
    /* Content Area */
    $('#notificationToolbarContentReduce').append('<ul class="start"></ul><ul class="end"></ul>');
    var oReduce = $('#notificationToolbarContentReduce .end');
    
    /* Chat Part */
    if ($.chatDialog != undefined)
    {
      // Chat Icon
      oReduce.append('<li class="chatImg"></li>');
    }
    
    // Maximize Toolbar
    oReduce.append('<li class="reduce"> <img src="' + sStylePath + 'notification/images/ico-notification-tirette-deplier.png"/> </li>');
    
    /* Maximize Toolbar Action */
    var oMaximizeAction = $('#notificationToolbarContentReduce .reduce img');
    oMaximizeAction.click(function (){ 
      $('#notificationToolbarContent').css("display", "block"); 
      $('#notificationToolbarContentReduce').css("display", "none");
      
      $('#notificationToolbarWrap').animate({"bottom": "0"}, 1000);
	  
	  $.get("./toolbar/toolbarInformation.php?session_id=" + get_session_id() + "&uniqid=" + get_session_uniqid() + "&ajax_action=set&property=state&value=1");
    });
	
	
	/** Close Toolbar First **/
	var bottom = "-60px";
	$('#notificationToolbarWrap').css("bottom", bottom);
	
	/* AlphaImageLoader with full path for IE7 & IE8 */
	if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated() || $.browserInformation.isIE8() || $.browserInformation.isIE8Simulated())
	{
		$('#notificationToolbarContent').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/fond.png',sizingMethod='scale')");
		$('#notificationToolbarContentReduce').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/fond.png',sizingMethod='scale')");
		$('.notificationDashboardImgDefault').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-notif-puce-default.png',sizingMethod='scale')");
		$('.notificationDashboardImgBlue').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-notif-puce-bleue.png',sizingMethod='scale')");
		$('.notificationDashboardImgRed').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-notif-puce-rouge.png',sizingMethod='scale')");
		oReduceAction.css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-notification-tirette-replier.png',sizingMethod='scale')");
		oMaximizeAction.css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-notification-tirette-deplier.png',sizingMethod='scale')");
		$('.notificationToolbarWrapIE7 #notificationDialog .reduce').css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + sStylePath + "notification/images/ico-fnt-surgissante-fermer.png',sizingMethod='scale')");
	}
	
	/* Get Toolbar State */
	$.get("./toolbar/toolbarInformation.php?session_id=" + get_session_id() + "&uniqid=" + get_session_uniqid() + "&ajax_action=get&property=state", function(data) {
	  if (data == '0') /* State Closed */
	  {
		var bottom = "-45px";
		if (($(window).width() + 17) < $(document).width() && $.browserInformation.isIE9())
		{
			//-- If horizontal scrollbar visible && IE9 
			bottom = "-25px";
		}
		$('#notificationToolbarWrap').css("bottom", bottom);
		$('#notificationToolbarContent').css("display", "none");
        $('#notificationToolbarContentReduce').css("display", "block");
	  }
	  else /* State Opened */
	  {
		$('#notificationToolbarContent').css("display", "block"); 
		$('#notificationToolbarContentReduce').css("display", "none");
		$('#notificationToolbarWrap').css("bottom", 0);
	  }
	});
	
  }
  
})(jQuery);

// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/notification/jquery.notificationDialog.js $
// Revision: 13392 $
(function ($){

  /**
   * Manage notification Dialogs
   */
  $.notificationDialog = {
    /**
     * @private JQuery Object
     */
    _oId : null,
    
    /**
     * @private Object containing left and top position for the bottom of the info marker
     */
    _oOffset : null,
    
    /**
     * @private Boolean used to choose Window Design
     */
    _bBorderCorner : null,
    
    /**
     * @private True if Dialog is hidden
     */
    _isHidden : true,
    
    /**
     * @private Last Ajax Url
     */
    _sLastAjaxUrl : null,
    
    /**
     * Name of the event sent when the Dialog is closed
     */
    closeEvent : 'closeEvent',
    
    /**
     * Name of the event sent when the Id of the content Change.
     * The event contains the new content Id
     */
    contentIdChangeEvent : 'contentIdChangeEvent',
    
    /**
     * @private Binding Event
     */
    _bindingEvents : {},
    
    /**
     * @private Mouse Over The Dialog
     */
    _bOverDialog : false,

    /**
     * @private Mouse Over The Dialog
     */
    _bUsingByExternalComponents : false,

    /**
     * @private List of external Components using Dialog
     */
    _oExternalComponents : {},
    
    /**
     * @private Time Before Close Dialog
     */
    _iWaitingTime : 1000,
    
    /**
     * @private Starting Time used to try to close Dialog
     */
    _iStartingEndOfTime : 0,
    
    /**
     * @private Identifier associated to the content
     */
    _sContentId : '',
    
    /**
     * Create a Dialog
     * 
     * @return Dialog Object
     */
    create : function (){
      if ($("#notificationDialog").length == 0)
      {
        /* Dialog Creation */
        var sContainer = '<div id="notificationDialogParent" class="' + $("#CURRENT_STYLE").attr('class') + '"><div id="notificationDialog" class="notificationDialog" style="display:none" width="100%"></div></div>';
        if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
          sContainer = '<div class="notificationToolbarWrapIE7" width="100%">' + sContainer + '</div>';
        $(document.body).append(sContainer);
        this._oId = $("#notificationDialog");
        /* Header */
        this._oId.append('<div class="hd"><div class="right"><div class="content">' + 
          '<div class="reduce" onclick="$.notificationDialog.hide()"/>' +
          '</div></div></div>');
        /* Content */ 
        this._oId.append('<div class="bd"><div class="right"><div class="contentBg"><div class="contentDialog"></div></div></div></div>');
        /* Footer */
        this._oId.append('<div class="ft"><div class="right"><div class="content"></div></div></div>');
        // Manage Mouse event
        this._oId.mouseenter(this._mouseEnterDialog);
        this._oId.mouseleave(this._mouseLeaveDialog);
      }
    },
    
    /**
     * @private Trigger an Event
     */
    _trigger : function (eventName, oParam){
      if ($.notificationDialog._bindingEvents[eventName] != null)
      {
        var iLen = $.notificationDialog._bindingEvents[eventName].length;
        for (iI = 0; iI < iLen; iI++)
          $.notificationDialog._bindingEvents[eventName][iI](oParam);
      }
    },
    
    /**
     * Bind an Event
     */
    bind : function (eventName, callback){
      if ($.notificationDialog._bindingEvents[eventName] == null)
        $.notificationDialog._bindingEvents[eventName] = new Array();
      $.notificationDialog._bindingEvents[eventName].push(callback);
    },
    
    /**
     * Indicates if Dialog is hidden
     * 
     * @return true if Dialog is hidden else false
     */
    isHidden : function (){ return (this._isHidden); },
    
    /**
     * Change Dialog Content
     * 
     * @param sContent Content to assign
     * @param sId of the Content -> If the identifier is different from the previous, "contentIdChangeEvent" event is sent
     */
    content : function (sContent, sId){
      if (this._oId == null)
        return;
      this._oId.css('min-width', 0);
      this._oId.find(".contentDialog").html(sContent);
      this._internalPosition(null);
      this._sLastAjaxUrl = null;
      
      if ($.notificationDialog._sContentId != '' && sId != $.notificationDialog._sContentId)
        $.notificationDialog._trigger($.notificationDialog.contentIdChangeEvent, sId);
      $.notificationDialog._sContentId = sId;
    },
    
    /**
     * Change Dialog Content By Ajax Call
     * 
     * @param sUrl Url which will send Content
     */
    contentAjax : function (sUrl){
      if (this._oId == null)
        return;
      
      var oContent = this._oId.find(".contentDialog");
      if (this._sLastAjaxUrl != sUrl)
      {
        /* Draw Waiting Animation only if Url is different than the previous calling */
        this.wait();
        this._sLastAjaxUrl = sUrl;
      }
      oContent.load(sUrl, this._internalPosition);
    },
    
    /**
     * Draw waiting animation
     */
    wait : function (){ 
      if (this._oId == null)
        return;
      
      var oContent = this._oId.find(".contentDialog");
      oContent.html('<img src="' + get_main_directory() + get_atmosphere() + '/waiting.gif" />'); 
    },
    
    /**
     * Show Dialog
     * 
     * @param bWithoutAnimation (optional) if true, the dialog appears without any animation
     * @param fcallback (optional) callback function to call
     */
    show : function (bWithoutAnimation, fcallback){
      if (this._oId == null || !this._isHidden){
        if (fcallback !== undefined && fcallback != null) fcallback();
        return;
      }

      var duration = (bWithoutAnimation === undefined || bWithoutAnimation != true) ? 'fast' : 0;
      this._oId.show(duration, function () {
        if (fcallback !== undefined && fcallback != null) fcallback();
        });
      this._isHidden = false;
    },
    
    /**
     * Hide Dialog
     * 
     * @param bWithoutAnimation (optional) if true, the dialog appears without any animation
     * @param fcallback (optional) callback function to call
     */
    hide : function (bWithoutAnimation, fcallback){
      if (this._oId == null || this._isHidden){
        if (fcallback !== undefined && fcallback != null) fcallback();
        return;
      }
      
      var duration = (bWithoutAnimation === undefined || bWithoutAnimation != true) ? 'fast' : 0;
      this._oId.hide(duration, function () {
        if (fcallback !== undefined && fcallback != null) fcallback();
        });
      this._isHidden = true;
      
      // Trigger information
      $.notificationDialog._trigger($.notificationDialog.closeEvent, null);
    },
    
    /**
     * Change Dialog Position for dialog with borders
     * 
     * @param oOffset Object containing new position. Property available : left, top, right, bottom
     */
    positionWithBorders : function (oOffset){
      $.notificationDialog._internalPosition(oOffset, true);
    },
    
    /**
     * Change Dialog Position for "Hint" Dialog
     * 
     * @param oOffset Object containing new position. Property available : left, top, right, bottom
     */
    position : function (oOffset){
      $.notificationDialog._internalPosition(oOffset, false);
    },
    
    /**
     * @private Change Dialog Position
     * 
     * @param oOffset Object containing new position. Property available : left, top, right, bottom
     * @param bBorderCorner if true Borders will be solid and with corners  
     */
    _internalPosition : function (oOffset, bBorderCorner){
      if (this._oId == null)
        return;
        
      if (oOffset != null)
        this._oOffset = oOffset;
      
      if (bBorderCorner != null)
        this._bBorderCorner = bBorderCorner;
      
      if (this._oOffset != null)
      {
        _bTopPosition = false;
        
        if (this._oOffset.left != null)
          this._oId.css('left', this._oOffset.left);
        else
          this._oId.css('left', '');
        if (this._oOffset.top != null)
        {
          this._oId.css('top', this._oOffset.top);
          _bTopPosition = true;
        }
        else
          this._oId.css('top', '');
        if (this._oOffset.right != null)
          this._oId.css('right', this._oOffset.right);
        else
          this._oId.css('top', this._oOffset.top);
        if (this._oOffset.bottom != null)
          this._oId.css('bottom', this._oOffset.bottom);
        else
          this._oId.css('bottom', '');

        // Dialog Width        
        var iWindowWidth = $(window).width();
        if (this._oOffset.left != null)
          iWindowWidth -= this._oOffset.left;
        this._oId.css('max-width', iWindowWidth + 'px');
        if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated())
          this._oId.css('width', iWindowWidth + 'px');
        // Dialog Height
        var iWindowHeight = 0
        if (this._oOffset.bottom != null)
          var iWindowHeight = $(window).height() - this._oOffset.bottom - 25;
        else if (this._oOffset.top != null)
          var iWindowHeight = $(window).height() - $('#notificationToolbarWrap').height() - this._oOffset.top - 25;
        if (iWindowHeight > 0)
          this._oId.css('max-height', iWindowHeight + 'px');
        
        var bd = this._oId.find('.bd');
        var hd = this._oId.find('.hd');
        var ft = this._oId.find('.ft');
        
        if (this._bBorderCorner == true)
        {
          this._oId.removeClass('background');
          this._oId.addClass('border');
          this._oId.addClass('leftBarColor');
          this._oId.addClass('rightBarColor');
          this._oId.addClass('topBarColor');
          this._oId.addClass('bottomBarColor');

          this._oId.css('position', 'absolute');
          this._oId.corner();
          
          hd.removeClass('border')
          ft.removeClass('border')
          ft.addClass('cornerBottom');
        }
        else 
        {
          ft.removeClass('cornerBottom');
          this._oId.addClass('background');
          this._oId.removeClass('border');
          this._oId.removeClass('leftBarColor');
          this._oId.removeClass('rightBarColor');
          this._oId.removeClass('topBarColor');
          this._oId.removeClass('bottomBarColor');
          
          if (!_bTopPosition)
          {
            hd.removeClass('border')
            ft.addClass('border')
            this._oId.css('position', 'fixed');
          }
          else
          {
            hd.addClass('border')
            ft.removeClass('border')
            this._oId.css('position', 'absolute');
          }
        }
      }
    },
    
    /**
     * Get/Set Dialog Width
     */
    width : function (iVal){
      if (iVal != undefined) this._oId.css('min-width', iVal);
      return this._oId.width();
    },
    
    /**
     * @private Mouse over the Dialog
     */
    _mouseEnterDialog : function(e){
      // Store information
      $.notificationDialog._bOverDialog = true;
    },
    
     /**
     * @private Mouse out of the Dialog
     */
    _mouseLeaveDialog : function(e){
      // Store information
      $.notificationDialog._bOverDialog = false;
      $.notificationDialog._manageAutoCloseDialog();
    },
    
    /**
     * @private Management Close Dialog
     */
    _manageAutoCloseDialog : function (){
      // Start Timer ?
      if (!$.notificationDialog._isHidden)
      {
        $.notificationDialog._iStartingEndOfTime = new Date().getTime();
        setTimeout("$.notificationDialog._manageAutoCloseDialogTimerFunction(" + $.notificationDialog._iStartingEndOfTime + ");", $.notificationDialog._iWaitingTime);
      }
    },
    
    /**
     * @private Management Close Dialog
     */
    _manageAutoCloseDialogTimerFunction : function (iStartTime){
      if (!$.notificationDialog._isHidden && !$.notificationDialog._bUsingByExternalComponents && !$.notificationDialog._bOverDialog && iStartTime == $.notificationDialog._iStartingEndOfTime) 
      {
        $.notificationDialog.hide()
      }
    },
    
    /**
     * Indicate if an external component is using Dialog
     * 
     * @param sExternalComponantName Name of the external component
     * @param isUsing Boolean which indicates if external component is currently using the dialog
     */
    externalComponentUsage : function (sExternalComponantName, isUsing){
      if (isUsing)
      {
        $.notificationDialog._bUsingByExternalComponents = true;
        $.notificationDialog._oExternalComponents[sExternalComponantName] = true;
      }
      else
      {
        $.notificationDialog._oExternalComponents[sExternalComponantName] = false;
        for (sExternal in $.notificationDialog._oExternalComponents)
        {
          // Verify if an external component is currently using Dialog
          if ($.notificationDialog._oExternalComponents[sExternalComponantName])
            return;
        }
        // No external component is currently using Dialog => we try to close Dialog
        $.notificationDialog._bUsingByExternalComponents = false;
        $.notificationDialog._manageAutoCloseDialog();
      }
    }
    
  }
  
})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/notification/jquery.dashboard.js $
// Revision: 16787 $
(function ($){

  /**
   * Manage Indicators Bar Notification
   */
  $.dashboard = {
  
    /**
     * @private Urls
     */
    _sGridUrl : get_main_directory() + 'index.php?' + get_session_name() + '=' + get_session_id(),
    _sImgUrl : get_main_directory() + get_atmosphere() + '/../notification/images/',
    
    /**
     * @private Max label length
     */
    _iMaxlabelLength : 100,
    
    /**
     * @private Current Statistics
     */
    _sCurrentNotificationId : "",
    
    /**
     * @private Last starting end of time
     */
     _iStartingEndOfTime : 0,
    
    /**
     * @private Html Container
     */
    _oContainer : null,
    
    /**
     * @private Object containing statistics Information
     */
    _oDataValue : {},
    
    /**
     * @private Id of the content associated to this class
     */
    _sContentId : 'dashboard',
    
    /**
     * @private Limit value of indicator
     */
     _iLimitValueOfIndicator : 100,
    
    /**
     * Draw Indicators
     * @param oContainer Container where to add the Indicators
     */
    get : function(oContainer){
      $.dashboard._oContainer = oContainer;
      /* Get Values */
      if (typeof(currentMainTable) != "undefined" && currentMainTable.toUpperCase() == 'AM_ACTION'){
        $.longPolling.callMethod('DashboardInitRefresh', $.dashboard._init);
      }
      else
        $.longPolling.callMethod('DashboardInit', $.dashboard._init);
    },
  
   /**
     * @private Init Dashboard
     * @param oDatas Statictics Values
     */
    _init : function (oDatas)
    {
      $.dashboard._oContainer.html('<div class="dashboardContainer"></div>');
      oContainer = $.dashboard._oContainer.find("div");
      /* Create Statistics */
      for (statisticId in oDatas) {
        /* Save Detail */
        $.dashboard._oDataValue[statisticId] = { id : statisticId, value : parseInt(oDatas[statisticId].value), 
          label : oDatas[statisticId].label, data : oDatas[statisticId].data, no : oDatas[statisticId].id,
          color : oDatas[statisticId].color};
        if (isNaN($.dashboard._oDataValue[statisticId].value)) $.dashboard._oDataValue[statisticId].value = -1;
        /* Draw Statistic */
        $.dashboard._writeIndicator(oContainer, $.dashboard._oDataValue[statisticId]);
      }

      /* Create Dialog */
      $.notificationDialog.create();
      $.notificationDialog.bind($.notificationDialog.closeEvent, $.dashboard._hideNotificationDialogEvent);
      $.notificationDialog.bind($.notificationDialog.contentIdChangeEvent, $.dashboard._dialogContentIdChangeEvent);
      
      /* Auto Refresh */
      setTimeout("$.longPolling.addEventListener('DashboardUpdate', $.dashboard._update);", 10000);
      
      /* Hint Bulle Closed */
      $("#bulle").bind('isHidden', function (){$.notificationDialog.externalComponentUsage('dashboard_hint', false);});
    },
    
    /**
     * @private The id of the content stored in the dialog has changed
     * @param sContentId Id of the new content
     */
    _dialogContentIdChangeEvent : function(sContentId){
      if (sContentId != $.dashboard._sContentId)
        $.dashboard._hideNotificationDialogEvent();
    },
    
    /**
     * @private Update Dashboard
     * @param oDatas Statictics Values
     */
    _update : function(oDatas){
      for (statisticId in oDatas) {
        /* Save Detail */
        if (oDatas[statisticId].hasOwnProperty('data')) $.dashboard._oDataValue[statisticId].data = oDatas[statisticId].data;
        $.dashboard._oDataValue[statisticId].value = parseInt(oDatas[statisticId].value);
        if (isNaN($.dashboard._oDataValue[statisticId].value)) $.dashboard._oDataValue[statisticId].value = -1;
        /* Update Statistic */
        $.dashboard._updateIndicator(statisticId, $.dashboard._oDataValue[statisticId]);
        /* Update Detail View*/
        if ($.dashboard._sCurrentNotificationId == statisticId) {
          if ($.dashboard._oDataValue[statisticId].value > 0)
            $.dashboard._showPreview($.dashboard._oDataValue[statisticId]);
          else
            $.dashboard._hideNotificationDialog();
        }
      }
    },
    
    /**
     * @private Get Indicator Content
     * @param sTagId HTML Tag Id for the current Indicator
     */
    _getContent : function (sId){
      /* Draw waiting animation */
      $.notificationDialog.wait();
      /* Update Detail View*/
      if ($.dashboard._oDataValue.hasOwnProperty(sId))
        $.dashboard._showPreview($.dashboard._oDataValue[sId]);
    },
    
    /**
     * @private Show Datas a Preview Dialog
     * @param oStatististic Statistic Object
     */
    _showPreview : function(oStatististic){
      if (oStatististic.data == ''){
        $.longPolling.callMethod('DashboardContent_' + oStatististic.no, function(data){
          oStatististic.data = data;
          $.dashboard._showPreview(oStatististic);
        });
        return;
      }
      var sHtml = '<DIV class="dialogPreview">';
      
      var iLenDatas = oStatististic.data.datas.length;
      for (iDatas = 0; iDatas < iLenDatas; iDatas++)
      {
        // -- récupération du tableau
        var oData = oStatististic.data.datas[iDatas];
        
        // -- Title
        sHtml += '<span class="label_bloc">';
        if (oData.hasOwnProperty('href'))
          sHtml += '<a href="' + $.dashboard._sGridUrl + oData.href + '">' + oData.label + " (" + oData.value + ")" + '</a>';
        else
          sHtml += oData.label + " (" + oData.value + ")";
        sHtml += '</span>';
        // -- Datas
        sHtml += '<br><BR>';
        sHtml += '<table class="query" width="100%" border="0" cellpadding="0" cellspacing="0">';
        
        // Headers
        if (oData.hasOwnProperty('columns') && oData.columns.length > 0)
        {
  	      sHtml += '<tr>';
  	      sHtml += '<td width="20">&nbsp;</td>';
  	      for (columns in oData.columns)
  	      {
            if (oData.columns[columns] == '')
              oData.columns[columns] = "&nbsp;";
  	        sHtml += '<td nowrap class="headercolumn_grid topBar' + oStatististic.color + ' bottomBar' + oStatististic.color + '">' + oData.columns[columns] + '</td>';
  	        sHtml += '<td class="headercolumn_grid topBar' + oStatististic.color + '  bottomBar' + oStatististic.color + '" width="5">&nbsp;</td>';
  	      }
  	      sHtml += '<td width="20">&nbsp;</td>';
  	      sHtml += '</tr>';
        }
        
        // Values
        for (row in oData.rows)
        {
          sHtml += '<tr>';
          sHtml += '<td width="20">&nbsp;</td>';
          for (column in oData.rows[row])
          {
            sHtml += '<td nowrap class="oddline_grid line_separator_light">' + oData.rows[row][column] + '</td>';
            sHtml += '<td class="oddline_grid line_separator_light" width="5">&nbsp;</td>';
          }
          sHtml += '<td width="20">&nbsp;</td>';
          sHtml += '</tr>';
        }
        
        // Bottom
        if (oData.hasOwnProperty('columns') && oData.columns.length > 0)
        {
          sHtml += '<tr>';
          sHtml += '<td width="20"></td>';
          for (columns in oData.columns)
          {
            sHtml += '<td nowrap class="topBar2 topBar' + oStatististic.color + '"></td>';
            sHtml += '<td class="topBar2 topBar' + oStatististic.color + '" width="5"></td>';
          }
          sHtml += '<td width="20"></td>';
          sHtml += '</tr>';
        }
        sHtml += '</table>';
        
        sHtml += '<br>';
      }
      
      sHtml += '</DIV>';
      $.notificationDialog.content(sHtml, $.dashboard._sContentId);
      $.notificationDialog.show();
    },
    
    /**
     * @private Draw an Indicator
     * @param oContainer Container
     * @param oStatististic Statistic Object
     */
    _writeIndicator : function(oContainer, oStatististic){
      /* HTML Content */
      var sTagId = oStatististic.id;
      if (oStatististic.label.length > $.dashboard._iMaxlabelLength) 
        var sLabel = oStatististic.label.substr(0, $.dashboard._iMaxlabelLength - 2) + '...'; 
      else 
        var sLabel = oStatististic.label;
      
      oContainer.append(
        '<div id="' + sTagId + '" name="' + sTagId + '" class="notificationDashboard">' +
        '<div class="hd"><div class="right"><div class="left">' + 
        '</div></div></div>' + 
        '<div class="bd"><div class="right"><div class="contentBg" title="' + oStatististic.label + '">' + sLabel + '</div></div></div>' + 
        '<div class="ft"><div class="left"><div class="right"></div></div></div>' +
        '</div>'
      );
      
      oContainer.append('<span id="indicatorImgContainer' + sTagId + '"></span>');

      $.dashboard._writeIndicatorImg(oStatististic);
    },
    
    /**
     * @private Draw Indicator Picture
     * @param oContainer Container
     * @param oStatististic Statistic Object
     */
    _writeIndicatorImg : function(oStatististic){
      var sHTML = '';
      var sTagId = oStatististic.id;
      var oIndicatorImgContainer = $('#indicatorImgContainer' + sTagId);
      
      var iLeft = $("#" + sTagId).position().left;
      var iWidthOfnotificationDashboardImgLeft = 13;
      var iNbDigit = Math.floor(Math.log(oStatististic.value) / Math.log(10)) + 1;
      
      if (oStatististic.value < 10)
      {      
        sHTML +=
          '<span class="notificationDashboardImg' + oStatististic.color + '" style="left:' + iLeft + 'px;" id="' + sTagId + 'Img" name="' + sTagId + 'Img" >' + 
          '<div class="notificationDashboardValue_lt_9">' + oStatististic.value + '</div>' + 
          '</span>'
        ;
      }
      else if (oStatististic.value < 100)
      {      
        sHTML +=
          '<span class="notificationDashboardImg' + oStatististic.color + '" style="left:' + iLeft + 'px;" id="' + sTagId + 'Img" name="' + sTagId + 'Img" >' + 
          '<div class="notificationDashboardValue_gte_9">' + oStatististic.value + '</div>' + 
          '</span>'
        ;
      }
      else if ($.dashboard._iLimitValueOfIndicator == 100)  //New style limit 99+
      {
        var iWidthOfOneDigit = 7;
        iNbDigit = 3;
        sHTML +=
          '<span class="notificationDashboardImg' + oStatististic.color + 'Left" style="left:' + iLeft + 'px;" id="' + sTagId + 'Img" name="' + sTagId + 'Img" ></span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Center" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft) + 'px; padding-left: '+(iNbDigit*3)+'px;" id="' + sTagId + 'ImgCenter" name="' + sTagId + 'ImgCenter" >' + 
          '<div class="notificationDashboardValue_lt_100">99+</div>' + 
          '</span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Right" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft+(iNbDigit*3)+2) + 'px;" id="' + sTagId + 'ImgRight" name="' + sTagId + 'ImgRight" ></span>'
        ;
      }
      else if (oStatististic.value < 1000) //New style limit 999+
      {
        var iWidthOfOneDigit = 8;
        sHTML +=
          '<span class="notificationDashboardImg' + oStatististic.color + 'Left" style="left:' + iLeft + 'px;" id="' + sTagId + 'Img" name="' + sTagId + 'Img" ></span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Center" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft) + 'px; padding-left: '+(iNbDigit*iWidthOfOneDigit)+'px;" id="' + sTagId + 'ImgCenter" name="' + sTagId + 'ImgCenter" >' + 
          '<div class="notificationDashboardValue_lt_10">' + oStatististic.value + '</div>' + 
          '</span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Right" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft+(iNbDigit*iWidthOfOneDigit)) + 'px;" id="' + sTagId + 'ImgRight" name="' + sTagId + 'ImgRight" ></span>'
        ;
      }
      else //New style limit 999+
      {
        var iWidthOfOneDigit = 8;
        iNbDigit = 4;
        sHTML +=
          '<span class="notificationDashboardImg' + oStatististic.color + 'Left" style="left:' + iLeft + 'px;" id="' + sTagId + 'Img" name="' + sTagId + 'Img" ></span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Center" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft) + 'px; padding-left: '+(iNbDigit*iWidthOfOneDigit)+'px;" id="' + sTagId + 'ImgCenter" name="' + sTagId + 'ImgCenter" >' + 
          '<div class="notificationDashboardValue_lt_10">999+</div>' + 
          '</span>'
          +
          '<span class="notificationDashboardImg' + oStatististic.color + 'Right" style="left:' + (iLeft+iWidthOfnotificationDashboardImgLeft+(iNbDigit*iWidthOfOneDigit)) + 'px;" id="' + sTagId + 'ImgRight" name="' + sTagId + 'ImgRight" ></span>'
        ;
      }
      
      oIndicatorImgContainer.html(sHTML);
      
      /* View Detail Event */
      $("#" + sTagId + "Img").mouseenter(function (e) {$.dashboard._mouseEnterStatistic(sTagId)});
      $("#" + sTagId + "ImgCenter").mouseenter(function (e) {$.dashboard._mouseEnterStatistic(sTagId)});
      $("#" + sTagId + "Img").mouseleave(function (e) {$.dashboard._mouseLeaveStatistic()});
      $("#" + sTagId + "ImgCenter").mouseleave(function (e) {$.dashboard._mouseLeaveStatistic()});
    },
    
    /**
     * @private Indicates if Mouse is over a statistic
     */
    _bInStatistic : false,
    
    /**
     * @private Elapsed time before opening preview dialog
     */
    _iWaitingTimeBeforeOpeningPreview : 500,

    /**
     * @private Mouse over a statistic
     */
    _mouseEnterStatistic : function(sTagId){
      // Mouse enter in a Statistic
      $.dashboard._bInStatistic = true;
      // Wait before opening preview dialog
      setTimeout('$.dashboard._tryToOpenPreview("' + sTagId + '");', $.dashboard._iWaitingTimeBeforeOpeningPreview);
    },
    
    /**
     * @private Mouse over a statistic
     */
    _tryToOpenPreview : function(sTagId){
      if (!$.dashboard._bInStatistic) return;
      // Mouse over a Statistic
      var oId = $("#" + sTagId)[0];
      $.notificationDialog.externalComponentUsage($.dashboard._sContentId, true);
      // Manage Content if necessary
      if ($.dashboard._sCurrentNotificationId != oId.id)
        $.dashboard._showNotificationDialog(oId);
    },
    
     /**
     * @private Mouse out of a statistic
     */
    _mouseLeaveStatistic : function(){
      // Mouse out of a Statistic
      $.dashboard._bInStatistic = false;
      $.notificationDialog.externalComponentUsage($.dashboard._sContentId, false);
    },
    
    /**
     * @private Show Dialog
     * */
    _showNotificationDialog : function(oId){
      if ($.dashboard._oDataValue[oId.id].value <= 0) {
        $.dashboard._hideNotificationDialog();
        return;
      }
      /* Show Dialog or change content */
      $.dashboard._sCurrentNotificationId = oId.id;
      var iPadding = parseInt($('#notificationToolbarContent .reduce').css('top'));if (isNaN(iPadding)) iPadding = 0;
      iPadding += $('#notificationToolbarContent .reduce img').height();
      $.notificationDialog.position({"bottom" : $("#notificationToolbarContent").height() - iPadding, "left" : $(oId).offset().left});
      $.dashboard._getContent(oId.id);
    },

    /**
     * @private Hide Dialog
     * */
    _hideNotificationDialog : function(){
      if ($.dashboard._isNotificationDialogHidden()) return;
      $.dashboard._hideNotificationDialogEvent();
      $.notificationDialog.hide();
    },
    
    /**
     * @private Hide Dialog Event
     * */
    _hideNotificationDialogEvent : function(){
      $.dashboard._sCurrentNotificationId = '';
    },
    
    /**
     * @private Indicates if the preview Dialog shows a statistic
     */
    _isNotificationDialogHidden : function(){
      return ($.dashboard._sCurrentNotificationId == '');
    },
    
    /**
     * @private Update an Indicator
     * @param sTagId HTML Tag Id
     * @param oStatististic Statistic Object
     */
    _updateIndicator : function(sTagId, oStatististic){
      var oIndicatorImgContainer = $('#indicatorImgContainer' + sTagId);
      
      $.dashboard._writeIndicatorImg(oStatististic); 
      
      if ($.browserInformation.isLtIE9())
      {
        var iHeight = oIndicatorImgContainer.height();
        oIndicatorImgContainer.animate({height : 0}, 400);
        oIndicatorImgContainer.animate({height : iHeight}, 400);
        oIndicatorImgContainer.animate({height : 0}, 400);
        oIndicatorImgContainer.animate({height : iHeight}, 400);
      }
      else
        oIndicatorImgContainer.fadeTo("slow", "0.1").fadeTo("slow", "1").fadeTo("slow", "0.1").fadeTo("slow", "1");
    }
          
  }
})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/notification/jquery.news.js $
// Revision: 15046 $
(function ($){

  /**
   * Manage News in the Bar Notification
   */
  $.news = {
  
    /**
     * @private Max label length
     */
    _iMaxlabelLength : 45,
    
    /**
     * @private Html Container
     */
    _oContainer : null,
    
    /**
     * @private Object containing News Information
     */
    _oDataValue : {},
    
    /**
     * @private Current Top News
     */
    _iCurrentTopNews : -1,
    
    /**
     * @private Time to Change News (ms)
     */
    _iTimeWaitingToChange : 5000,
    
    /**
     * @private Animation Time to Change News (ms)
     */
    _iAnimationTimeToChange : 1000,
    
    /**
     * @private Indicates animation is in progress
     */
    _bAnimationInProgress : false,
    
    /**
     * @private Html Code used to go to the previous news
     */
    _sUpNewsHtmlCode : '<div class="newsUp" onclick="$.news._contentUp()"></div>',
    
    /**
     * @private Html Code used to go to the next news
     */
    _sDownNewsHtmlCode : '<div class="newsDown" onclick="$.news._contentDown()"></div>',
    
    /**
     * @private Last Time when content was updated
     */
    _iLastUpdatedTime : 0,
    
    /**
     * @private Id of the content associated to this class
     */
    _sContentId : 'news',
    
    /**
     * @private Current News in the dialog
     */
    _iCurrentNewsIdPreview : -1,
    
    /**
     * Draw News
     * 
     * @param oContainer Container where to add the News
     */
    get : function(oContainer){
      oContainer.html('<div id="notificationNewsContainer"></div>');
      $.news._oContainer = oContainer.find("#notificationNewsContainer");
      /* Html Code */
      var sHtml = '<span class="notificationNewsImg" ><div class="notificationNewsValue_lt_100"></div></span>';
      if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated() || $.browserInformation.isIE8() || $.browserInformation.isIE8Simulated()){
        sHtml += '<div class="newsTop"><div id="notificationNewsContainerTop" class="contentDisable"></div>' + $.news._sUpNewsHtmlCode + '</div>';
        sHtml += '<div class="newsBottom"><div id="notificationNewsContainerBottom" class="contentDisable"></div>' + $.news._sDownNewsHtmlCode + '</div>';
      } else {
        sHtml += '<div id="notificationNewsMove"><div class="top"></div><div></div><div class="bottom"></div></div>';
        sHtml += '<div class="newsTop"><div id="notificationNewsContainerTop" class="contentDisable"></div>' + $.news._sUpNewsHtmlCode + '</div>';
        sHtml += '<div class="newsBottom"><div id="notificationNewsContainerBottom" class="contentDisable"></div>' + $.news._sDownNewsHtmlCode + '</div>';
      }
      $.news._oContainer.html(sHtml);
      /* Events */
      $.news._oContainer.find('.notificationNewsImg').mouseenter(function (e) {$.news._mouseEnterNews()});
      $.news._oContainer.find('.notificationNewsImg').mouseleave(function (e) {$.news._mouseLeaveNews()});
      /* Get Values */
      var sDlg = $.getUrlVar('q2_dialogId');
      if (sDlg != null && sDlg.toUpperCase() == '%7BA6A9D8F9-8DB5-487F-B328-B7D1310585EE%7D')
        $.longPolling.callMethod('NewsInitForceRefresh', $.news._init);
      else
        $.longPolling.callMethod('NewsInit', $.news._init);
    },
  
   /**
     * @private Init News
     */
    _init : function (oDatas){
      /* Save News */
      $.news._initDatas(oDatas, -1);
      /* Create Dialog */
      $.notificationDialog.create();
      $.notificationDialog.bind($.notificationDialog.closeEvent, $.news._hideNotificationDialogEvent);
      $.notificationDialog.bind($.notificationDialog.contentIdChangeEvent, $.news._dialogContentIdChangeEvent);
      /* Auto Refresh */
      setTimeout("$.longPolling.addEventListener('NewsUpdate', $.news._update);", 30000);
    },
    
    /**
     * @private Init Data News
     */
    _initDatas : function (oDatas, sCurrentNewsId){
      /* Save News */
      $.news._oDataValue['Content'] = oDatas;
      $.news._oDataValue['Ids'] = [];
      $.news._iCurrentTopNews = 0;
      for (sId in oDatas)
      {
        if (sId == sCurrentNewsId) $.news._iCurrentTopNews = $.news._oDataValue['Ids'].length;
        $.news._oDataValue['Ids'].push(sId);
      }
      /* Manage Content Style */
      var iLen = $.news._oDataValue['Ids'].length;
      var cTop = $.news._oContainer.find('#notificationNewsContainerTop');
      var cBottom = $.news._oContainer.find('#notificationNewsContainerBottom');
      if (iLen > 1)
      {
        if (cTop.hasClass('contentDisable')) cTop.removeClass('contentDisable');
        if (!cTop.hasClass('content')) cTop.addClass('content');
        if (cBottom.hasClass('contentDisable')) cBottom.removeClass('contentDisable');
        if (!cBottom.hasClass('content')) cBottom.addClass('content');
      }
      else if (iLen == 1)
      {
        if (cTop.hasClass('contentDisable')) cTop.removeClass('contentDisable');
        if (!cTop.hasClass('content')) cTop.addClass('content');
        if (cBottom.hasClass('content')) cBottom.removeClass('content');
        if (!cBottom.hasClass('contentDisable')) cBottom.addClass('contentDisable');
      }
      else
      {
        $.news._iCurrentTopNews = -1;
        if (cTop.hasClass('content')) cTop.removeClass('content');
        if (!cTop.hasClass('contentDisable')) cTop.addClass('contentDisable');
        if (cBottom.hasClass('content')) cBottom.removeClass('content');
        if (!cBottom.hasClass('contentDisable')) cBottom.addClass('contentDisable');
      }
      /* Draw Content */
      $.news._content();  
    },
    
    /**
     * @private Manage Content
     */
    _content : function(){
      $.news._iLastUpdatedTime = new Date().getTime();
      var iLen = $.news._oDataValue['Ids'].length;
      if (iLen > 1)
      {
        $.news._oContainer.find("#notificationNewsContainerTop").html($.news._getTitle($.news._iCurrentTopNews));
          
        if (iLen > $.news._iCurrentTopNews + 1)
          $.news._oContainer.find("#notificationNewsContainerBottom").html($.news._getTitle($.news._iCurrentTopNews + 1));
        else
          $.news._oContainer.find("#notificationNewsContainerBottom").html($.news._getTitle(0));
        
        var oImg = $.news._oContainer.find('.notificationNewsImg').find('div');
        var sValue = $.news._iCurrentTopNews + 1;
        if (iLen > 99)
        {
          if (oImg.hasClass('notificationNewsValue_lt_100')) oImg.removeClass('notificationNewsValue_lt_100');
          if ($.news._tmp == 1)
          {
            if (oImg.hasClass('notificationNewsValue_gte_100_gte_100'))
              oImg.removeClass('notificationNewsValue_gte_100_gte_100').addClass('notificationNewsValue_lt_100_gte_100');
            else
              oImg.addClass('notificationNewsValue_lt_100_gte_100');
          }
          else if ($.news._tmp == 100)
          {
            if (oImg.hasClass('notificationNewsValue_lt_100_gte_100'))
              oImg.removeClass('notificationNewsValue_lt_100_gte_100').addClass('notificationNewsValue_gte_100_gte_100');
            else
              oImg.addClass('notificationNewsValue_gte_100_gte_100');
          }
        }
        oImg.html(sValue + '/' + iLen);
        setTimeout('$.news._contentTimeout(' + $.news._iLastUpdatedTime + ');', $.news._iTimeWaitingToChange);
      }
      else if (iLen == 1)
      {
        $.news._iCurrentTopNews = 0;
        $.news._oContainer.find("#notificationNewsContainerTop").html($.news._getTitle($.news._iCurrentTopNews));
        $.news._oContainer.find("#notificationNewsContainerTop").css
        $.news._oContainer.find("#notificationNewsContainerBottom").html('');
        $.news._oContainer.find('.notificationNewsImg').find('div').html('1/1');
      }
      else
      {
        $.news._oContainer.find("#notificationNewsContainerTop").html('');
        $.news._oContainer.find("#notificationNewsContainerBottom").html('');
        $.news._oContainer.find('.notificationNewsImg').find('div').html('0/0');
      }
    },
    
    /**
     * @private Get title to draw of a news
     * @param iNewsPos News position in $.news._oDataValue['Ids']
     */
    _getTitle : function (iNewsPos){
      var sTitle = $.news._oDataValue['Content'][$.news._oDataValue['Ids'][iNewsPos]].title;
      if (typeof(sTitle) != "undefined" && sTitle.length > $.news._iMaxlabelLength)
        sTitle = sTitle.substr(0, $.news._iMaxlabelLength) + '...';
      return sTitle;
    },
    
    /**
     * @private Manage Content Change by Timing
     * @param iLastUpdatedTime Value of $.news._iLastUpdatedTime when the timer was created
     */
    _contentTimeout : function(iLastUpdatedTime){
      if (!$.news._bAnimationInProgress && $.news._iLastUpdatedTime == iLastUpdatedTime)
      {
        if ($.news._isNotificationDialogHidden())
          $.news._animate(true);
        else
          setTimeout('$.news._contentTimeout(' + $.news._iLastUpdatedTime + ');', $.news._iTimeWaitingToChange);
      }
    },
    
    /**
     * @private Animation
     * @param bMoveUp Indicates if news moves up
     */
    _animate : function (bMoveUp){
      $.news._bAnimationInProgress = true; 
      var iLen = $.news._oDataValue['Ids'].length;
      
      if (bMoveUp)
        var i1st = $.news._iCurrentTopNews;
      else if ($.news._iCurrentTopNews == 0)
        var i1st = iLen - 1;
      else
        var i1st = $.news._iCurrentTopNews - 1;
      if (iLen > i1st + 1)
        var i2nd = i1st + 1;
      else
        var i2nd = 0;
      if (iLen > i2nd + 1)
        var i3rd = i2nd + 1;
      else
        var i3rd = 0;
      if (bMoveUp) 
        $.news._iCurrentTopNews = i2nd;
      else
        $.news._iCurrentTopNews = i1st;
      
      if ($.browserInformation.isIE7() || $.browserInformation.isIE7Simulated() || $.browserInformation.isIE8() || $.browserInformation.isIE8Simulated())
      {
        $.news._content();
        $.news._bAnimationInProgress = false;
        return;
      }
      
      var oTop = $.news._oContainer.find("#notificationNewsContainerTop");
      var aTopColor = $.str2color(oTop.css('color'));
      var iTopColor = aTopColor[0]*aTopColor[1]*aTopColor[2];
      var oBottom = $.news._oContainer.find("#notificationNewsContainerBottom");
      var aBottomColor = $.str2color(oBottom.css('color'));
      var iBottomColor = aBottomColor[0]*aBottomColor[1]*aBottomColor[2];
      var oMove = $.news._oContainer.find("#notificationNewsMove");
      var oPosition = $.news._oContainer.position();
      oMove.css('left', oPosition.left);
      oMove.css('top', oPosition.top);
      oMove.height($.news._oContainer.height());
      var o1st = oMove.find(":eq(0)");
      var o2nd = oMove.find(":eq(1)");
      var o3rd = oMove.find(":eq(2)");
      o1st.html($.news._getTitle(i1st));
      o2nd.html($.news._getTitle(i2nd));
      o3rd.html($.news._getTitle(i3rd));
      oTop.html('');
      oBottom.html('');
      if (bMoveUp){
        o2nd.removeClass('top');
        o2nd.addClass('bottom');
      }else{
        o2nd.removeClass('bottom');
        o2nd.addClass('top');
      }
      oMove.show();
      var aStepColor = [];
      aStepColor[0] = Math.floor((aTopColor[0] - aBottomColor[0]) / 3);
      aStepColor[1] = Math.floor((aTopColor[1] - aBottomColor[1]) / 3);
      aStepColor[2] = Math.floor((aTopColor[2] - aBottomColor[2]) / 3);
      var aStepColorTop = [aBottomColor[0] + aStepColor[0], aBottomColor[1] + aStepColor[1], aBottomColor[2] + aStepColor[2]];
      var aStepColorBottom = [aStepColorTop[0] + aStepColor[0], aStepColorTop[1] + aStepColor[1], aStepColorTop[2] + aStepColor[2]];
      if (bMoveUp){
        var iScrollStart = "=0";
        var iScrollEnd = oBottom.position().top - oTop.position().top;
        var iScrollStep1 = Math.floor(iScrollEnd / 3);
        var iScrollStep2 = iScrollStep1 * 2;
      }else{
        var iScrollStart = oBottom.position().top - oTop.position().top;
        var iScrollStep1 = Math.floor(iScrollStart / 3);
        var iScrollStep2 = iScrollStep1;
        var iScrollEnd = iScrollStart - iScrollStep1 - iScrollStep2;
        iScrollStep1 = '-=' + iScrollStep1;
        iScrollStep2 = '-=' + iScrollStep2;
        iScrollEnd = '-=' + iScrollEnd;
      }
      oMove.animate({scrollTop : iScrollStart}, 0,
        function () {
          oMove.animate({scrollTop : iScrollStep1}, $.news._iAnimationTimeToChange / 4, 'linear', 
            function () {
              if (bMoveUp)
                o2nd.css('color', '#' + $.decToHex(aStepColorTop[0]) + $.decToHex(aStepColorTop[1]) + $.decToHex(aStepColorTop[2]));
              else  
                o2nd.css('color', '#' + $.decToHex(aStepColorBottom[0]) + $.decToHex(aStepColorBottom[1]) + $.decToHex(aStepColorBottom[2]));
              oMove.animate({scrollTop : iScrollStep2}, $.news._iAnimationTimeToChange / 4, 'linear', 
                function () {
                  if (bMoveUp){
                    o2nd.removeClass('bottom');
                    o2nd.addClass('top');
                    o2nd.css('color', '#' + $.decToHex(aStepColorBottom[0]) + $.decToHex(aStepColorBottom[1]) + $.decToHex(aStepColorBottom[2]));
                  }else{  
                    o2nd.removeClass('top');
                    o2nd.addClass('bottom');
                    o2nd.css('color', '#' + $.decToHex(aStepColorTop[0]) + $.decToHex(aStepColorTop[1]) + $.decToHex(aStepColorTop[2]));
                  }
                  oMove.animate({scrollTop : iScrollEnd}, $.news._iAnimationTimeToChange / 4, 'linear',
                    function () {
                      o2nd.css('color', '');
                      oMove.animate({scrollTop : iScrollEnd}, $.news._iAnimationTimeToChange / 4, 'linear',
                        function () {
                          oMove.hide();
                          $.news._content();
                          $.news._bAnimationInProgress = false;
                        });
                    });
                });
            });
        });
    },
    
    /**
     * @private Go to the previous news
     */
    _contentUp : function(){
      if ($.news._bAnimationInProgress || !$.news._oDataValue.hasOwnProperty('Ids')) return;
      $.news._hideNotificationDialog();
      var iLen = $.news._oDataValue['Ids'].length;
      if (iLen > 1)
        $.news._animate(true);
    },
    
    /**
     * @private Go to the next news
     */
    _contentDown : function(){
      if ($.news._bAnimationInProgress || !$.news._oDataValue.hasOwnProperty('Ids')) return;
      $.news._hideNotificationDialog();
      var iLen = $.news._oDataValue['Ids'].length;
      if (iLen > 1)
        $.news._animate(false);
    },
    
    /**
     * @private Show Top News in a dialog 
     */
    _showPreview : function(){
      if ($.news._iCurrentTopNews == -1) return;
      /* Init Datas */
      $.news._iCurrentNewsIdPreview = $.news._iCurrentTopNews;
      var iPadding = parseInt($('#notificationToolbarContent .reduce').css('top'));if (isNaN(iPadding)) iPadding = 0;
      iPadding += $('#notificationToolbarContent .reduce img').height();
      $.notificationDialog.position({'bottom' : $('#notificationToolbarContent').height() - iPadding, 'left' : $('#notificationNewsContainer').offset().left});
      /* Draw waiting animation */
      $.notificationDialog.wait();
      if ($.news._oDataValue['Content'][$.news._oDataValue['Ids'][$.news._iCurrentNewsIdPreview]].content == '')
        $.longPolling.callMethod('NewsContent_' + $.news._oDataValue['Ids'][$.news._iCurrentNewsIdPreview], function(data){
          $.news._oDataValue['Content'][$.news._oDataValue['Ids'][$.news._iCurrentNewsIdPreview]].content = data;
          $.news._drawPreview();
          });
      else
        $.news._drawPreview();
    },
    
    /**
     * @private Show Top News Content in a dialog 
     */
    _drawPreview : function(){
      /* get News Content */
      var sHtml = '<DIV class="dialogPreview">' + $.news._oDataValue['Content'][$.news._oDataValue['Ids'][$.news._iCurrentNewsIdPreview]].content + '</DIV>';
      /* show dialog */
      $.notificationDialog.content(sHtml, $.news._sContentId);
      $.notificationDialog.show();
    },
    
    /**
     * @private Hide Dialog
     * */
    _hideNotificationDialog : function(){
      if ($.news._isNotificationDialogHidden()) return;
      $.news._mouseLeaveNews();
      $.news._hideNotificationDialogEvent();
      $.notificationDialog.hide();
    },
    
    /**
     * @private Hide Dialog Event
     * */
    _hideNotificationDialogEvent : function(){
      $.news._iCurrentNewsIdPreview = -1;
    },
    
    /**
     * @private Indicates if the preview Dialog shows a news
     */
    _isNotificationDialogHidden : function(){
      return ($.news._iCurrentNewsIdPreview == -1);
    },
    
    /**
     * @private The id of the content stored in the dialog has changed
     * @param sContentId Id of the new content
     */
    _dialogContentIdChangeEvent : function(sContentId){
      if (sContentId != $.news._sContentId)
        $.news._hideNotificationDialogEvent();
    },
    
     /**
     * @private Indicates if Mouse is over a news
     */
    _bInNews : false,
    
    /**
     * @private Elapsed time before opening preview dialog
     */
    _iWaitingTimeBeforeOpeningPreview : 500,

    /**
     * @private Mouse over a news
     */
    _mouseEnterNews : function(){
      // Mouse enter in a Statistic
      $.news._bInNews = true;
      // Wait before opening preview dialog
      setTimeout('$.news._tryToOpenPreview();', $.news._iWaitingTimeBeforeOpeningPreview);
    },
    
    /**
     * @private Mouse over a news
     */
    _tryToOpenPreview : function(){
      if (!$.news._bInNews) return;
      if ($.news._bAnimationInProgress){
        setTimeout('$.news._tryToOpenPreview();', $.news._iWaitingTimeBeforeOpeningPreview);
        return;
      }
      // Mouse over a News
      $.notificationDialog.externalComponentUsage($.news._sContentId, true);
      // Manage Content if necessary
      if ($.news._iCurrentNewsIdPreview != $.news._iCurrentTopNews)
        $.news._showPreview();
    },
    
     /**
     * @private Mouse out of a statistic
     */
    _mouseLeaveNews : function(){
      // Mouse out of a Statistic
      $.news._bInNews = false;
      $.notificationDialog.externalComponentUsage($.news._sContentId, false);
    },
    
    /**
     * @private Update News
     */
    _update : function(oDatas){
      var bEmpty = true;
      for (idx in oDatas)
      {
        bEmpty = false;
        break;
      }
      if (!bEmpty)
      {
        var sCurrentId = $.news._oDataValue['Ids'][$.news._iCurrentTopNews];
        var bExistCurrentId = oDatas.hasOwnProperty(sCurrentId);
        if (!bExistCurrentId && $.news._iCurrentNewsIdPreview != -1)
          $.news._hideNotificationDialog();
        $.news._initDatas(oDatas, sCurrentId);
      }
    }
    
  }
})(jQuery);// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/notification/jquery.userInformation.js $
// Revision: 14247 $
(function ($){

  /**
   * Manage User Information details
   */
  $.userInformation = {

    /**
     * @private Init user information
     * @param oDatas Statictics Values
     */
    init : function (oJqueryContainer)
    {
      oJqueryContainer.load("./toolbar/userInformation.php?session_id=" + get_session_id() + "&uniqid=" + get_session_uniqid(), function() {
        var oPanelUser = $("#infosPanelUser");
		var iPanelUserLeft = (oPanelUser.offset() == null) ? 0 : oPanelUser.offset().left;
        var iLeftUser = iPanelUserLeft + 5;
        var oImg = $("#infosPanelUser .notificationUserImg");
        oImg.offset({left: iLeftUser});
        var iWidth = oImg.width();
        var iHeight = oImg.height();
        oImg.mouseenter(function (e) {$.userInformation._mouseEnterDetails();});
        oImg.mouseleave(function (e) {$.userInformation._mouseLeaveDetails();});
        oImg = oImg.find('img');
        if (oImg.width() > oImg.height())
        {
          oImg.height(oImg.height() * iWidth / oImg.width());
          oImg.width(iWidth);
        }
        else
        {
          oImg.width(oImg.width() * iHeight / oImg.height());
          oImg.height(iHeight);
        }
        
        var iLeft = iLeftUser + (oImg.width() / 2);
        var oUser = oPanelUser.find('#infosPanelUserName');
        oUser.offset({left: iLeft});
        var iDomainWidth = $("#select_domain").width();
        var iUserWidth = oUser.find("span").width();
        if (iUserWidth + oImg.width() + iLeft > iDomainWidth)
          oPanelUser.width(iUserWidth + oImg.width() + iLeft);
      });
    },
    
    /**
     * @private Indicates if Mouse is over the details zone
     */
    _bInDetails : false,
    
    /**
     * @private Elapsed time before opening preview dialog
     */
    _iWaitingTimeBeforeOpeningPreview : 500,

    /**
     * @private Mouse over the details zone
     */
    _mouseEnterDetails : function(){
      // Mouse enter over the details zone
      $.userInformation._bInDetails = true;
      // Wait before opening preview dialog
      setTimeout('$.userInformation._tryToOpenPreview();', $.userInformation._iWaitingTimeBeforeOpeningPreview);
    },
    
    /**
     * @private Mouse over the details zone
     */
    _tryToOpenPreview : function(){
      if (!$.userInformation._bInDetails) return;
      // Mouse over the details zone
      $.notificationDialog.externalComponentUsage('userInformation', true);
      $.userInformation._showDetails();
    },
    
     /**
     * @private Mouse out of the details zone
     */
    _mouseLeaveDetails : function(){
      // Mouse out of the details zone
      $.userInformation._bInDetails = false;
      $.notificationDialog.externalComponentUsage('userInformation', false);
    },
    
    /**
     * @private Show Details
     * */
    _showDetails : function (){
      var html = $('#current_infosPanel').html();
      if (html == ''){ $('#current_infosPanel').load("./toolbar/userInformation.php?action=show&session_id=" + get_session_id() + "&uniqid=" + get_session_uniqid(), function() { $.userInformation._showDetails(); }); return;}
      $.notificationDialog.create();
      var iPadding = parseInt($('#notificationToolbarContent .reduce').css('top'));if (isNaN(iPadding)) iPadding = 0;
      iPadding += $('#notificationToolbarContent .reduce img').height();
      $.notificationDialog.position({'bottom' : $('#notificationToolbarContent').height() - iPadding, 'left' : $('#infosPanelUser').offset().left});
      $.notificationDialog.content(html, 'userInformation');
      $.notificationDialog.show();
    }
    
  }
})(jQuery);/**
 * @preserve
 * FullCalendar v1.5.2
 * http://arshaw.com/fullcalendar/
 *
 * Use fullcalendar.css for basic styling.
 * For event drag & drop, requires jQuery UI draggable.
 * For event resizing, requires jQuery UI resizable.
 *
 * Copyright (c) 2011 Adam Shaw
 * Dual licensed under the MIT and GPL licenses, located in
 * MIT-LICENSE.txt and GPL-LICENSE.txt respectively.
 *
 * Date: Sun Aug 21 22:06:09 2011 -0700
 *
 */
 
(function($, undefined) {


var defaults = {

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	
	// editing
	//editable: false,
	//disableDragging: false,
	//disableResizing: false,
	
	allDayDefault: true,
	ignoreTimezone: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	
	// time formats
	titleFormat: {
		month: 'MMMM yyyy',
		week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}",
		day: 'dddd, MMM d, yyyy'
	},
	columnFormat: {
		month: 'ddd',
		week: 'ddd M/d',
		day: 'dddd M/d'
	},
	timeFormat: { // for event elements
		'': 'h(:mm)t' // default
	},
	
	// locale
	isRTL: false,
	firstDay: 0,
	monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
	monthNamesShort: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
	dayNames: ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	dayNamesShort: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
	buttonText: {
		prev: '&nbsp;&#9668;&nbsp;',
		next: '&nbsp;&#9658;&nbsp;',
		prevYear: '&nbsp;&lt;&lt;&nbsp;',
		nextYear: '&nbsp;&gt;&gt;&nbsp;',
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},
	
	// jquery-ui theming
	theme: false,
	buttonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e'
	},
	
	//selectable: false,
	unselectAuto: true,
	
	dropAccept: '*'
	
};

// right-to-left defaults
var rtlDefaults = {
	header: {
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonText: {
		prev: '&nbsp;&#9658;&nbsp;',
		next: '&nbsp;&#9668;&nbsp;',
		prevYear: '&nbsp;&gt;&gt;&nbsp;',
		nextYear: '&nbsp;&lt;&lt;&nbsp;'
	},
	buttonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w'
	}
};



var fc = $.fullCalendar = { version: "1.5.2" };
var fcViews = fc.views = {};


$.fn.fullCalendar = function(options) {


	// method calling
	if (typeof options == 'string') {
		var args = Array.prototype.slice.call(arguments, 1);
		var res;
		this.each(function() {
			var calendar = $.data(this, 'fullCalendar');
			if (calendar && $.isFunction(calendar[options])) {
				var r = calendar[options].apply(calendar, args);
				if (res === undefined) {
					res = r;
				}
				if (options == 'destroy') {
					$.removeData(this, 'fullCalendar');
				}
			}
		});
		if (res !== undefined) {
			return res;
		}
		return this;
	}
	
	
	// would like to have this logic in EventManager, but needs to happen before options are recursively extended
	var eventSources = options.eventSources || [];
	delete options.eventSources;
	if (options.events) {
		eventSources.push(options.events);
		delete options.events;
	}
	

	options = $.extend(true, {},
		defaults,
		(options.isRTL || options.isRTL===undefined && defaults.isRTL) ? rtlDefaults : {},
		options
	);
	
	
	this.each(function(i, _element) {
		var element = $(_element);
		var calendar = new Calendar(element, options, eventSources);
		element.data('fullCalendar', calendar); // TODO: look into memory leak implications
		calendar.render();
	});
	
	
	return this;
	
};


// function for adding/overriding defaults
function setDefaults(d) {
	$.extend(true, defaults, d);
}



 
function Calendar(element, options, eventSources) {
	var t = this;
	
	
	// exports
	t.options = options;
	t.render = render;
	t.destroy = destroy;
	t.refetchEvents = refetchEvents;
	t.reportEvents = reportEvents;
	t.reportEventChange = reportEventChange;
	t.rerenderEvents = rerenderEvents;
	t.changeView = changeView;
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.formatDate = function(format, date) { return formatDate(format, date, options) };
	t.formatDates = function(format, date1, date2) { return formatDates(format, date1, date2, options) };
	t.getDate = getDate;
	t.getView = getView;
	t.option = option;
	t.trigger = trigger;
	
	
	// imports
	EventManager.call(t, options, eventSources);
	var isFetchNeeded = t.isFetchNeeded;
	var fetchEvents = t.fetchEvents;
	
	
	// locals
	var _element = element[0];
	var header;
	var headerElement;
	var content;
	var tm; // for making theme classes
	var currentView;
	var viewInstances = {};
	var elementOuterWidth;
	var suggestedViewHeight;
	var absoluteViewElement;
	var resizeUID = 0;
	var ignoreWindowResize = 0;
	var date = new Date();
	var events = [];
	var _dragElement;
	
	
	
	/* Main Rendering
	-----------------------------------------------------------------------------*/
	
	
	setYMD(date, options.year, options.month, options.date);
	
	
	function render(inc) {
		if (!content) {
			initialRender();
		}else{
			calcSize();
			markSizesDirty();
			markEventsDirty();
			renderView(inc);
		}
	}
	
	
	function initialRender() {
		tm = options.theme ? 'ui' : 'fc';
		element.addClass('fc');
		if (options.isRTL) {
			element.addClass('fc-rtl');
		}
		if (options.theme) {
			element.addClass('ui-widget');
		}
		content = $("<div class='fc-content' style='position:relative'/>")
			.prependTo(element);
		header = new Header(t, options);
		headerElement = header.render();
		if (headerElement) {
			element.prepend(headerElement);
		}
		changeView(options.defaultView);
		$(window).resize(windowResize);
		// needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
		if (!bodyVisible()) {
			lateRender();
		}
	}
	
	
	// called when we know the calendar couldn't be rendered when it was initialized,
	// but we think it's ready now
	function lateRender() {
		setTimeout(function() { // IE7 needs this so dimensions are calculated correctly
			if (!currentView.start && bodyVisible()) { // !currentView.start makes sure this never happens more than once
				renderView();
			}
		},0);
	}
	
	
	function destroy() {
		$(window).unbind('resize', windowResize);
		header.destroy();
		content.remove();
		element.removeClass('fc fc-rtl ui-widget');
	}
	
	
	
	function elementVisible() {
		return _element.offsetWidth !== 0;
	}
	
	
	function bodyVisible() {
		return $('body')[0].offsetWidth !== 0;
	}
	
	
	
	/* View Rendering
	-----------------------------------------------------------------------------*/
	
	// TODO: improve view switching (still weird transition in IE, and FF has whiteout problem)
	
	function changeView(newViewName) {
		if (!currentView || newViewName != currentView.name) {
			ignoreWindowResize++; // because setMinHeight might change the height before render (and subsequently setSize) is reached

			unselect();
			
			var oldView = currentView;
			var newViewElement;
				
			if (oldView) {
				(oldView.beforeHide || noop)(); // called before changing min-height. if called after, scroll state is reset (in Opera)
				setMinHeight(content, content.height());
				oldView.element.hide();
			}else{
				setMinHeight(content, 1); // needs to be 1 (not 0) for IE7, or else view dimensions miscalculated
			}
			content.css('overflow', 'hidden');
			
			currentView = viewInstances[newViewName];
			if (currentView) {
				currentView.element.show();
			}else{
				currentView = viewInstances[newViewName] = new fcViews[newViewName](
					newViewElement = absoluteViewElement =
						$("<div class='fc-view fc-view-" + newViewName + "' style='position:absolute'/>")
							.appendTo(content),
					t // the calendar object
				);
			}
			
			if (oldView) {
				header.deactivateButton(oldView.name);
			}
			header.activateButton(newViewName);
			
			renderView(); // after height has been set, will make absoluteViewElement's position=relative, then set to null
			
			content.css('overflow', '');
			if (oldView) {
				setMinHeight(content, 1);
			}
			
			if (!newViewElement) {
				(currentView.afterShow || noop)(); // called after setting min-height/overflow, so in final scroll state (for Opera)
			}
			
			ignoreWindowResize--;
		}
	}
	
	
	
	function renderView(inc) {
		if (elementVisible()) {
			ignoreWindowResize++; // because renderEvents might temporarily change the height before setSize is reached

			unselect();
			
			if (suggestedViewHeight === undefined) {
				calcSize();
			}
			
			var forceEventRender = false;
			if (!currentView.start || inc || date < currentView.start || date >= currentView.end) {
				// view must render an entire new date range (and refetch/render events)
				currentView.render(date, inc || 0); // responsible for clearing events
				setSize(true);
				forceEventRender = true;
			}
			else if (currentView.sizeDirty) {
				// view must resize (and rerender events)
				currentView.clearEvents();
				setSize();
				forceEventRender = true;
			}
			else if (currentView.eventsDirty) {
				currentView.clearEvents();
				forceEventRender = true;
			}
			currentView.sizeDirty = false;
			currentView.eventsDirty = false;
			updateEvents(forceEventRender);
			
			elementOuterWidth = element.outerWidth();
			
			header.updateTitle(currentView.title);
			var today = new Date();
			if (today >= currentView.start && today < currentView.end) {
				header.disableButton('today');
			}else{
				header.enableButton('today');
			}
			
			ignoreWindowResize--;
			currentView.trigger('viewDisplay', _element);
		}
	}
	
	
	
	/* Resizing
	-----------------------------------------------------------------------------*/
	
	
	function updateSize() {
		markSizesDirty();
		if (elementVisible()) {
			calcSize();
			setSize();
			unselect();
			currentView.clearEvents();
			currentView.renderEvents(events);
			currentView.sizeDirty = false;
		}
	}
	
	
	function markSizesDirty() {
		$.each(viewInstances, function(i, inst) {
			inst.sizeDirty = true;
		});
	}
	
	
	function calcSize() {
		if (options.contentHeight) {
			suggestedViewHeight = options.contentHeight;
		}
		else if (options.height) {
			suggestedViewHeight = options.height - (headerElement ? headerElement.height() : 0) - vsides(content);
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
		}
	}
	
	
	function setSize(dateChanged) { // todo: dateChanged?
		ignoreWindowResize++;
		currentView.setHeight(suggestedViewHeight, dateChanged);
		if (absoluteViewElement) {
			absoluteViewElement.css('position', 'relative');
			absoluteViewElement = null;
		}
		currentView.setWidth(content.width(), dateChanged);
		ignoreWindowResize--;
	}
	
	
	function windowResize() {
		if (!ignoreWindowResize) {
			if (currentView.start) { // view has already been rendered
				var uid = ++resizeUID;
				setTimeout(function() { // add a delay
					if (uid == resizeUID && !ignoreWindowResize && elementVisible()) {
						if (elementOuterWidth != (elementOuterWidth = element.outerWidth())) {
							ignoreWindowResize++; // in case the windowResize callback changes the height
							updateSize();
							currentView.trigger('windowResize', _element);
							ignoreWindowResize--;
						}
					}
				}, 200);
			}else{
				// calendar must have been initialized in a 0x0 iframe that has just been resized
				lateRender();
			}
		}
	}
	
	
	
	/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
	
	
	// fetches events if necessary, rerenders events if necessary (or if forced)
	function updateEvents(forceRender) {
		if (!options.lazyFetching || isFetchNeeded(currentView.visStart, currentView.visEnd)) {
			refetchEvents();
		}
		else if (forceRender) {
			rerenderEvents();
		}
	}
	
	
	function refetchEvents() {
		fetchEvents(currentView.visStart, currentView.visEnd); // will call reportEvents
	}
	
	
	// called when event data arrives
	function reportEvents(_events) {
		events = _events;
		rerenderEvents();
	}
	
	
	// called when a single event's data has been changed
	function reportEventChange(eventID) {
		rerenderEvents(eventID);
	}
	
	
	// attempts to rerenderEvents
	function rerenderEvents(modifiedEventID) {
		markEventsDirty();
		if (elementVisible()) {
			currentView.clearEvents();
			currentView.renderEvents(events, modifiedEventID);
			currentView.eventsDirty = false;
		}
	}
	
	
	function markEventsDirty() {
		$.each(viewInstances, function(i, inst) {
			inst.eventsDirty = true;
		});
	}
	


	/* Selection
	-----------------------------------------------------------------------------*/
	

	function select(start, end, allDay) {
		currentView.select(start, end, allDay===undefined ? true : allDay);
	}
	

	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}
	
	
	
	/* Date
	-----------------------------------------------------------------------------*/
	
	
	function prev() {
		renderView(-1);
	}
	
	
	function next() {
		renderView(1);
	}
	
	
	function prevYear() {
		addYears(date, -1);
		renderView();
	}
	
	
	function nextYear() {
		addYears(date, 1);
		renderView();
	}
	
	
	function today() {
		date = new Date();
		renderView();
	}
	
	
	function gotoDate(year, month, dateOfMonth) {
		if (year instanceof Date) {
			date = cloneDate(year); // provided 1 argument, a Date
		}else{
			setYMD(date, year, month, dateOfMonth);
		}
		renderView();
	}
	
	
	function incrementDate(years, months, days) {
		if (years !== undefined) {
			addYears(date, years);
		}
		if (months !== undefined) {
			addMonths(date, months);
		}
		if (days !== undefined) {
			addDays(date, days);
		}
		renderView();
	}
	
	
	function getDate() {
		return cloneDate(date);
	}
	
	
	
	/* Misc
	-----------------------------------------------------------------------------*/
	
	
	function getView() {
		return currentView;
	}
	
	
	function option(name, value) {
		if (value === undefined) {
			return options[name];
		}
		if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
			options[name] = value;
			updateSize();
		}
	}
	
	
	function trigger(name, thisObj) {
		if (options[name]) {
			return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
		}
	}
	
	
	
	/* External Dragging
	------------------------------------------------------------------------*/
	
	if (options.droppable) {
		$(document)
			.bind('dragstart', function(ev, ui) {
				var _e = ev.target;
				var e = $(_e);
				if (!e.parents('.fc').length) { // not already inside a calendar
					var accept = options.dropAccept;
					if ($.isFunction(accept) ? accept.call(_e, e) : e.is(accept)) {
						_dragElement = _e;
						currentView.dragStart(_dragElement, ev, ui);
					}
				}
			})
			.bind('dragstop', function(ev, ui) {
				if (_dragElement) {
					currentView.dragStop(_dragElement, ev, ui);
					_dragElement = null;
				}
			});
	}
	

}

function Header(calendar, options) {
	var t = this;
	
	
	// exports
	t.render = render;
	t.destroy = destroy;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	
	
	// locals
	var element = $([]);
	var tm;
	


	function render() {
		tm = options.theme ? 'ui' : 'fc';
		var sections = options.header;
		if (sections) {
			element = $("<table class='fc-header' style='width:100%'/>")
				.append(
					$("<tr/>")
						.append(renderSection('left'))
						.append(renderSection('center'))
						.append(renderSection('right'))
				);
			return element;
		}
	}
	
	
	function destroy() {
		element.remove();
	}
	
	
	function renderSection(position) {
		var e = $("<td class='fc-header-" + position + "'/>");
		var buttonStr = options.header[position];
		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				if (i > 0) {
					e.append("<span class='fc-header-space'/>");
				}
				var prevButton;
				$.each(this.split(','), function(j, buttonName) {
					if (buttonName == 'title') {
						e.append("<span class='fc-header-title'><h2>&nbsp;</h2></span>");
						if (prevButton) {
							prevButton.addClass(tm + '-corner-right');
						}
						prevButton = null;
					}else{
						var buttonClick;
						if (calendar[buttonName]) {
							buttonClick = calendar[buttonName]; // calendar method
						}
						else if (fcViews[buttonName]) {
							buttonClick = function() {
								button.removeClass(tm + '-state-hover'); // forget why
								calendar.changeView(buttonName);
							};
						}
						if (buttonClick) {
							var icon = options.theme ? smartProperty(options.buttonIcons, buttonName) : null; // why are we using smartProperty here?
							var text = smartProperty(options.buttonText, buttonName); // why are we using smartProperty here?
							var button = $(
								"<span class='fc-button fc-button-" + buttonName + " " + tm + "-state-default'>" +
									"<span class='fc-button-inner'>" +
										"<span class='fc-button-content'>" +
											(icon ?
												"<span class='fc-icon-wrap'>" +
													"<span class='ui-icon ui-icon-" + icon + "'/>" +
												"</span>" :
												text
												) +
										"</span>" +
										"<span class='fc-button-effect'><span></span></span>" +
									"</span>" +
								"</span>"
							);
							if (button) {
								button
									.click(function() {
										if (!button.hasClass(tm + '-state-disabled')) {
											buttonClick();
										}
									})
									.mousedown(function() {
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-down');
									})
									.mouseup(function() {
										button.removeClass(tm + '-state-down');
									})
									.hover(
										function() {
											button
												.not('.' + tm + '-state-active')
												.not('.' + tm + '-state-disabled')
												.addClass(tm + '-state-hover');
										},
										function() {
											button
												.removeClass(tm + '-state-hover')
												.removeClass(tm + '-state-down');
										}
									)
									.appendTo(e);
								if (!prevButton) {
									button.addClass(tm + '-corner-left');
								}
								prevButton = button;
							}
						}
					}
				});
				if (prevButton) {
					prevButton.addClass(tm + '-corner-right');
				}
			});
		}
		return e;
	}
	
	
	function updateTitle(html) {
		element.find('h2')
			.html(html);
	}
	
	
	function activateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-active');
	}
	
	
	function deactivateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-active');
	}
	
	
	function disableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-disabled');
	}
	
	
	function enableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-disabled');
	}


}

fc.sourceNormalizers = [];
fc.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager(options, _sources) {
	var t = this;
	
	
	// exports
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.updateEvent = updateEvent;
	t.renderEvent = renderEvent;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.normalizeEvent = normalizeEvent;
	
	
	// imports
	var trigger = t.trigger;
	var getView = t.getView;
	var reportEvents = t.reportEvents;
	
	
	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var currentFetchID = 0;
	var pendingSourceCnt = 0;
	var loadingLevel = 0;
	var cache = [];
	
	
	for (var i=0; i<_sources.length; i++) {
		_addEventSource(_sources[i]);
	}
	
	
	
	/* Fetching
	-----------------------------------------------------------------------------*/
	
	
	function isFetchNeeded(start, end) {
		return !rangeStart || start < rangeStart || end > rangeEnd;
	}
	
	
	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		cache = [];
		var fetchID = ++currentFetchID;
		var len = sources.length;
		pendingSourceCnt = len;
		for (var i=0; i<len; i++) {
			fetchEventSource(sources[i], fetchID);
		}
	}
	
	
	function fetchEventSource(source, fetchID) {
		_fetchEventSource(source, function(events) {
			if (fetchID == currentFetchID) {
				if (events) {
					for (var i=0; i<events.length; i++) {
						events[i].source = source;
						normalizeEvent(events[i]);
					}
					cache = cache.concat(events);
				}
				pendingSourceCnt--;
				if (!pendingSourceCnt) {
					reportEvents(cache);
				}
			}
		});
	}
	
	
	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = fc.sourceFetchers;
		var res;
		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i](source, rangeStart, rangeEnd, callback);
			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}
		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				pushLoading();
				events(cloneDate(rangeStart), cloneDate(rangeEnd), function(events) {
					callback(events);
					popLoading();
				});
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;
				var data = $.extend({}, source.data || {});
				var startParam = firstDefined(source.startParam, options.startParam);
				var endParam = firstDefined(source.endParam, options.endParam);
				if (startParam) {
					data[startParam] = Math.round(+rangeStart / 1000);
				}
				if (endParam) {
					data[endParam] = Math.round(+rangeEnd / 1000);
				}
				pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}
	
	
	
	/* Sources
	-----------------------------------------------------------------------------*/
	

	function addEventSource(source) {
		source = _addEventSource(source);
		if (source) {
			pendingSourceCnt++;
			fetchEventSource(source, currentFetchID); // will eventually call reportEvents
		}
	}
	
	
	function _addEventSource(source) {
		if ($.isFunction(source) || $.isArray(source)) {
			source = { events: source };
		}
		else if (typeof source == 'string') {
			source = { url: source };
		}
		if (typeof source == 'object') {
			normalizeSource(source);
			sources.push(source);
			return source;
		}
	}
	

	function removeEventSource(source) {
		sources = $.grep(sources, function(src) {
			return !isSourcesEqual(src, source);
		});
		// remove all client events from that source
		cache = $.grep(cache, function(e) {
			return !isSourcesEqual(e.source, source);
		});
		reportEvents(cache);
	}
	
	
	
	/* Manipulation
	-----------------------------------------------------------------------------*/
	
	
	function updateEvent(event) { // update an existing event
		var i, len = cache.length, e,
			defaultEventEnd = getView().defaultEventEnd, // getView???
			startDelta = event.start - event._start,
			endDelta = event.end ?
				(event.end - (event._end || defaultEventEnd(event))) // event._end would be null if event.end
				: 0;                                                      // was null and event was just resized
		for (i=0; i<len; i++) {
			e = cache[i];
			if (e._id == event._id && e != event) {
				e.start = new Date(+e.start + startDelta);
				if (event.end) {
					if (e.end) {
						e.end = new Date(+e.end + endDelta);
					}else{
						e.end = new Date(+defaultEventEnd(e) + endDelta);
					}
				}else{
					e.end = null;
				}
				e.title = event.title;
				e.url = event.url;
				e.allDay = event.allDay;
				e.className = event.className;
				e.editable = event.editable;
				e.color = event.color;
				e.backgroudColor = event.backgroudColor;
				e.borderColor = event.borderColor;
				e.textColor = event.textColor;
				normalizeEvent(e);
			}
		}
		normalizeEvent(event);
		reportEvents(cache);
	}
	
	
	function renderEvent(event, stick) {
		normalizeEvent(event);
		if (!event.source) {
			if (stick) {
				stickySource.events.push(event);
				event.source = stickySource;
			}
			cache.push(event);
		}
		reportEvents(cache);
	}
	
	
	function removeEvents(filter) {
		if (!filter) { // remove all
			cache = [];
			// clear all array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = [];
				}
			}
		}else{
			if (!$.isFunction(filter)) { // an event ID
				var id = filter + '';
				filter = function(e) {
					return e._id == id;
				};
			}
			cache = $.grep(cache, filter, true);
			// remove events from array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = $.grep(sources[i].events, filter, true);
				}
			}
		}
		reportEvents(cache);
	}
	
	
	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter) { // an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}
	
	
	
	/* Loading State
	-----------------------------------------------------------------------------*/
	
	
	function pushLoading() {
		if (!loadingLevel++) {
			trigger('loading', null, true);
		}
	}
	
	
	function popLoading() {
		if (!--loadingLevel) {
			trigger('loading', null, false);
		}
	}
	
	
	
	/* Event Normalization
	-----------------------------------------------------------------------------*/
	
	
	function normalizeEvent(event) {
		var source = event.source || {};
		var ignoreTimezone = firstDefined(source.ignoreTimezone, options.ignoreTimezone);
		event._id = event._id || (event.id === undefined ? '_fc' + eventGUID++ : event.id + '');
		if (event.date) {
			if (!event.start) {
				event.start = event.date;
			}
			delete event.date;
		}
		event._start = cloneDate(event.start = parseDate(event.start, ignoreTimezone));
		event.end = parseDate(event.end, ignoreTimezone);
		if (event.end && event.end <= event.start) {
			event.end = null;
		}
		event._end = event.end ? cloneDate(event.end) : null;
		if (event.allDay === undefined) {
			event.allDay = firstDefined(source.allDayDefault, options.allDayDefault);
		}
		if (event.className) {
			if (typeof event.className == 'string') {
				event.className = event.className.split(/\s+/);
			}
		}else{
			event.className = [];
		}
		// TODO: if there is no start date, return false to indicate an invalid event
	}
	
	
	
	/* Utils
	------------------------------------------------------------------------------*/
	
	
	function normalizeSource(source) {
		if (source.className) {
			// TODO: repeat code, same code for event classNames
			if (typeof source.className == 'string') {
				source.className = source.className.split(/\s+/);
			}
		}else{
			source.className = [];
		}
		var normalizers = fc.sourceNormalizers;
		for (var i=0; i<normalizers.length; i++) {
			normalizers[i](source);
		}
	}
	
	
	function isSourcesEqual(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}
	
	
	function getSourcePrimitive(source) {
		return ((typeof source == 'object') ? (source.events || source.url) : '') || source;
	}


}


fc.addDays = addDays;
fc.cloneDate = cloneDate;
fc.parseDate = parseDate;
fc.parseISO8601 = parseISO8601;
fc.parseTime = parseTime;
fc.formatDate = formatDate;
fc.formatDates = formatDates;



/* Date Math
-----------------------------------------------------------------------------*/

var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
	DAY_MS = 86400000,
	HOUR_MS = 3600000,
	MINUTE_MS = 60000;
	

function addYears(d, n, keepTime) {
	d.setFullYear(d.getFullYear() + n);
	if (!keepTime) {
		clearTime(d);
	}
	return d;
}


function addMonths(d, n, keepTime) { // prevents day overflow/underflow
	if (+d) { // prevent infinite looping on invalid dates
		var m = d.getMonth() + n,
			check = cloneDate(d);
		check.setDate(1);
		check.setMonth(m);
		d.setMonth(m);
		if (!keepTime) {
			clearTime(d);
		}
		while (d.getMonth() != check.getMonth()) {
			d.setDate(d.getDate() + (d < check ? 1 : -1));
		}
	}
	return d;
}


function addDays(d, n, keepTime) { // deals with daylight savings
	if (+d) {
		var dd = d.getDate() + n,
			check = cloneDate(d);
		check.setHours(9); // set to middle of day
		check.setDate(dd);
		d.setDate(dd);
		if (!keepTime) {
			clearTime(d);
		}
		fixDate(d, check);
	}
	return d;
}


function fixDate(d, check) { // force d to be on check's YMD, for daylight savings purposes
	if (+d) { // prevent infinite looping on invalid dates
		while (d.getDate() != check.getDate()) {
			d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
		}
	}
}


function addMinutes(d, n) {
	d.setMinutes(d.getMinutes() + n);
	return d;
}


function clearTime(d) {
	d.setHours(0);
	d.setMinutes(0);
	d.setSeconds(0); 
	d.setMilliseconds(0);
	return d;
}


function cloneDate(d, dontKeepTime) {
	if (dontKeepTime) {
		return clearTime(new Date(+d));
	}
	return new Date(+d);
}


function zeroDate() { // returns a Date with time 00:00:00 and dateOfMonth=1
	var i=0, d;
	do {
		d = new Date(1970, i++, 1);
	} while (d.getHours()); // != 0
	return d;
}


function skipWeekend(date, inc, excl) {
	inc = inc || 1;
	while (!date.getDay() || (excl && date.getDay()==1 || !excl && date.getDay()==6)) {
		addDays(date, inc);
	}
	return date;
}


function dayDiff(d1, d2) { // d1 - d2
	return Math.round((cloneDate(d1, true) - cloneDate(d2, true)) / DAY_MS);
}


function setYMD(date, y, m, d) {
	if (y !== undefined && y != date.getFullYear()) {
		date.setDate(1);
		date.setMonth(0);
		date.setFullYear(y);
	}
	if (m !== undefined && m != date.getMonth()) {
		date.setDate(1);
		date.setMonth(m);
	}
	if (d !== undefined) {
		date.setDate(d);
	}
}



/* Date Parsing
-----------------------------------------------------------------------------*/


function parseDate(s, ignoreTimezone) { // ignoreTimezone defaults to true
	if (typeof s == 'object') { // already a Date object
		return s;
	}
	if (typeof s == 'number') { // a UNIX timestamp
		return new Date(s * 1000);
	}
	if (typeof s == 'string') {
		if (s.match(/^\d+(\.\d+)?$/)) { // a UNIX timestamp
			return new Date(parseFloat(s) * 1000);
		}
		if (ignoreTimezone === undefined) {
			ignoreTimezone = true;
		}
		return parseISO8601(s, ignoreTimezone) || (s ? new Date(s) : null);
	}
	// TODO: never return invalid dates (like from new Date(<string>)), return null instead
	return null;
}


function parseISO8601(s, ignoreTimezone) { // ignoreTimezone defaults to false
	// derived from http://delete.me.uk/2005/03/iso8601.html
	// TODO: for a know glitch/feature, read tests/issue_206_parseDate_dst.html
	var m = s.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
	if (!m) {
		return null;
	}
	var date = new Date(m[1], 0, 1);
	if (ignoreTimezone || !m[13]) {
		var check = new Date(m[1], 0, 1, 9, 0);
		if (m[3]) {
			date.setMonth(m[3] - 1);
			check.setMonth(m[3] - 1);
		}
		if (m[5]) {
			date.setDate(m[5]);
			check.setDate(m[5]);
		}
		fixDate(date, check);
		if (m[7]) {
			date.setHours(m[7]);
		}
		if (m[8]) {
			date.setMinutes(m[8]);
		}
		if (m[10]) {
			date.setSeconds(m[10]);
		}
		if (m[12]) {
			date.setMilliseconds(Number("0." + m[12]) * 1000);
		}
		fixDate(date, check);
	}else{
		date.setUTCFullYear(
			m[1],
			m[3] ? m[3] - 1 : 0,
			m[5] || 1
		);
		date.setUTCHours(
			m[7] || 0,
			m[8] || 0,
			m[10] || 0,
			m[12] ? Number("0." + m[12]) * 1000 : 0
		);
		if (m[14]) {
			var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
			offset *= m[15] == '-' ? 1 : -1;
			date = new Date(+date + (offset * 60 * 1000));
		}
	}
	return date;
}


function parseTime(s) { // returns minutes since start of day
	if (typeof s == 'number') { // an hour
		return s * 60;
	}
	if (typeof s == 'object') { // a Date object
		return s.getHours() * 60 + s.getMinutes();
	}
	var m = s.match(/(\d+)(?::(\d+))?\s*(\w+)?/);
	if (m) {
		var h = parseInt(m[1], 10);
		if (m[3]) {
			h %= 12;
			if (m[3].toLowerCase().charAt(0) == 'p') {
				h += 12;
			}
		}
		return h * 60 + (m[2] ? parseInt(m[2], 10) : 0);
	}
}



/* Date Formatting
-----------------------------------------------------------------------------*/
// TODO: use same function formatDate(date, [date2], format, [options])


function formatDate(date, format, options) {
	return formatDates(date, null, format, options);
}


function formatDates(date1, date2, format, options) {
	options = options || defaults;
	var date = date1,
		otherDate = date2,
		i, len = format.length, c,
		i2, formatter,
		res = '';
	for (i=0; i<len; i++) {
		c = format.charAt(i);
		if (c == "'") {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == "'") {
					if (date) {
						if (i2 == i+1) {
							res += "'";
						}else{
							res += format.substring(i+1, i2);
						}
						i = i2;
					}
					break;
				}
			}
		}
		else if (c == '(') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ')') {
					var subres = formatDate(date, format.substring(i+1, i2), options);
					if (parseInt(subres.replace(/\D/, ''), 10)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '[') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ']') {
					var subformat = format.substring(i+1, i2);
					var subres = formatDate(date, subformat, options);
					if (subres != formatDate(otherDate, subformat, options)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '{') {
			date = date2;
			otherDate = date1;
		}
		else if (c == '}') {
			date = date1;
			otherDate = date2;
		}
		else {
			for (i2=len; i2>i; i2--) {
				if (formatter = dateFormatters[format.substring(i, i2)]) {
					if (date) {
						res += formatter(date, options);
					}
					i = i2 - 1;
					break;
				}
			}
			if (i2 == i) {
				if (date) {
					res += c;
				}
			}
		}
	}
	return res;
};


var dateFormatters = {
	s	: function(d)	{ return d.getSeconds() },
	ss	: function(d)	{ return zeroPad(d.getSeconds()) },
	m	: function(d)	{ return d.getMinutes() },
	mm	: function(d)	{ return zeroPad(d.getMinutes()) },
	h	: function(d)	{ return d.getHours() % 12 || 12 },
	hh	: function(d)	{ return zeroPad(d.getHours() % 12 || 12) },
	H	: function(d)	{ return d.getHours() },
	HH	: function(d)	{ return zeroPad(d.getHours()) },
	d	: function(d)	{ return d.getDate() },
	dd	: function(d)	{ return zeroPad(d.getDate()) },
	ddd	: function(d,o)	{ return o.dayNamesShort[d.getDay()] },
	dddd: function(d,o)	{ return o.dayNames[d.getDay()] },
	M	: function(d)	{ return d.getMonth() + 1 },
	MM	: function(d)	{ return zeroPad(d.getMonth() + 1) },
	MMM	: function(d,o)	{ return o.monthNamesShort[d.getMonth()] },
	MMMM: function(d,o)	{ return o.monthNames[d.getMonth()] },
	yy	: function(d)	{ return (d.getFullYear()+'').substring(2) },
	yyyy: function(d)	{ return d.getFullYear() },
	t	: function(d)	{ return d.getHours() < 12 ? 'a' : 'p' },
	tt	: function(d)	{ return d.getHours() < 12 ? 'am' : 'pm' },
	T	: function(d)	{ return d.getHours() < 12 ? 'A' : 'P' },
	TT	: function(d)	{ return d.getHours() < 12 ? 'AM' : 'PM' },
	u	: function(d)	{ return formatDate(d, "yyyy-MM-dd'T'HH:mm:ss'Z'") },
	S	: function(d)	{
		var date = d.getDate();
		if (date > 10 && date < 20) {
			return 'th';
		}
		return ['st', 'nd', 'rd'][date%10-1] || 'th';
	}
};



fc.applyAll = applyAll;


/* Event Date Math
-----------------------------------------------------------------------------*/


function exclEndDay(event) {
	if (event.end) {
		return _exclEndDay(event.end, event.allDay);
	}else{
		return addDays(cloneDate(event.start), 1);
	}
}


function _exclEndDay(end, allDay) {
	end = cloneDate(end);
	return allDay || end.getHours() || end.getMinutes() ? addDays(end, 1) : clearTime(end);
}


function segCmp(a, b) {
	return (b.msLength - a.msLength) * 100 + (a.event.start - b.event.start);
}


function segsCollide(seg1, seg2) {
	return seg1.end > seg2.start && seg1.start < seg2.end;
}



/* Event Sorting
-----------------------------------------------------------------------------*/


// event rendering utilities
function sliceSegs(events, visEventEnds, start, end) {
	var segs = [],
		i, len=events.length, event,
		eventStart, eventEnd,
		segStart, segEnd,
		isStart, isEnd;
	for (i=0; i<len; i++) {
		event = events[i];
		eventStart = event.start;
		eventEnd = visEventEnds[i];
		if (eventEnd > start && eventStart < end) {
			if (eventStart < start) {
				segStart = cloneDate(start);
				isStart = false;
			}else{
				segStart = eventStart;
				isStart = true;
			}
			if (eventEnd > end) {
				segEnd = cloneDate(end);
				isEnd = false;
			}else{
				segEnd = eventEnd;
				isEnd = true;
			}
			segs.push({
				event: event,
				start: segStart,
				end: segEnd,
				isStart: isStart,
				isEnd: isEnd,
				msLength: segEnd - segStart
			});
		}
	} 
	return segs.sort(segCmp);
}


// event rendering calculation utilities
function stackSegs(segs) {
	var levels = [],
		i, len = segs.length, seg,
		j, collide, k;
	for (i=0; i<len; i++) {
		seg = segs[i];
		j = 0; // the level index where seg should belong
		while (true) {
			collide = false;
			if (levels[j]) {
				for (k=0; k<levels[j].length; k++) {
					if (segsCollide(levels[j][k], seg)) {
						collide = true;
						break;
					}
				}
			}
			if (collide) {
				j++;
			}else{
				break;
			}
		}
		if (levels[j]) {
			levels[j].push(seg);
		}else{
			levels[j] = [seg];
		}
	}
	return levels;
}



/* Event Element Binding
-----------------------------------------------------------------------------*/


function lazySegBind(container, segs, bindHandlers) {
	container.unbind('mouseover').mouseover(function(ev) {
		var parent=ev.target, e,
			i, seg;
		while (parent != this) {
			e = parent;
			parent = parent.parentNode;
		}
		if ((i = e._fci) !== undefined) {
			e._fci = undefined;
			seg = segs[i];
			bindHandlers(seg.event, seg.element, seg);
			$(ev.target).trigger(ev);
		}
		ev.stopPropagation();
	});
}



/* Element Dimensions
-----------------------------------------------------------------------------*/


function setOuterWidth(element, width, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.width(Math.max(0, width - hsides(e, includeMargins)));
	}
}


function setOuterHeight(element, height, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.height(Math.max(0, height - vsides(e, includeMargins)));
	}
}


// TODO: curCSS has been deprecated (jQuery 1.4.3 - 10/16/2010)


function hsides(element, includeMargins) {
	return hpadding(element) + hborders(element) + (includeMargins ? hmargins(element) : 0);
}


function hpadding(element) {
	return (parseFloat($.curCSS(element[0], 'paddingLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingRight', true)) || 0);
}


function hmargins(element) {
	return (parseFloat($.curCSS(element[0], 'marginLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginRight', true)) || 0);
}


function hborders(element) {
	return (parseFloat($.curCSS(element[0], 'borderLeftWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderRightWidth', true)) || 0);
}


function vsides(element, includeMargins) {
	return vpadding(element) +  vborders(element) + (includeMargins ? vmargins(element) : 0);
}


function vpadding(element) {
	return (parseFloat($.curCSS(element[0], 'paddingTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingBottom', true)) || 0);
}


function vmargins(element) {
	return (parseFloat($.curCSS(element[0], 'marginTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginBottom', true)) || 0);
}


function vborders(element) {
	return (parseFloat($.curCSS(element[0], 'borderTopWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderBottomWidth', true)) || 0);
}


function setMinHeight(element, height) {
	height = (typeof height == 'number' ? height + 'px' : height);
	element.each(function(i, _element) {
		_element.style.cssText += ';min-height:' + height + ';_height:' + height;
		// why can't we just use .css() ? i forget
	});
}



/* Misc Utils
-----------------------------------------------------------------------------*/


//TODO: arraySlice
//TODO: isFunction, grep ?


function noop() { }


function cmp(a, b) {
	return a - b;
}


function arrayMax(a) {
	return Math.max.apply(Math, a);
}


function zeroPad(n) {
	return (n < 10 ? '0' : '') + n;
}


function smartProperty(obj, name) { // get a camel-cased/namespaced property of an object
	if (obj[name] !== undefined) {
		return obj[name];
	}
	var parts = name.split(/(?=[A-Z])/),
		i=parts.length-1, res;
	for (; i>=0; i--) {
		res = obj[parts[i].toLowerCase()];
		if (res !== undefined) {
			return res;
		}
	}
	return obj[''];
}


function htmlEscape(s) {
	return s.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function cssKey(_element) {
	return _element.id + '/' + _element.className + '/' + _element.style.cssText.replace(/(^|;)\s*(top|left|width|height)\s*:[^;]*/ig, '');
}


function disableTextSelection(element) {
	element
		.attr('unselectable', 'on')
		.css('MozUserSelect', 'none')
		.bind('selectstart.ui', function() { return false; });
}


/*
function enableTextSelection(element) {
	element
		.attr('unselectable', 'off')
		.css('MozUserSelect', '')
		.unbind('selectstart.ui');
}
*/


function markFirstLast(e) {
	e.children()
		.removeClass('fc-first fc-last')
		.filter(':first-child')
			.addClass('fc-first')
		.end()
		.filter(':last-child')
			.addClass('fc-last');
}


function setDayID(cell, date) {
	cell.each(function(i, _cell) {
		_cell.className = _cell.className.replace(/^fc-\w*/, 'fc-' + dayIDs[date.getDay()]);
		// TODO: make a way that doesn't rely on order of classes
	});
}


function getSkinCss(event, opt) {
	var source = event.source || {};
	var eventColor = event.color;
	var sourceColor = source.color;
	var optionColor = opt('eventColor');
	var backgroundColor =
		event.backgroundColor ||
		eventColor ||
		source.backgroundColor ||
		sourceColor ||
		opt('eventBackgroundColor') ||
		optionColor;
	var borderColor =
		event.borderColor ||
		eventColor ||
		source.borderColor ||
		sourceColor ||
		opt('eventBorderColor') ||
		optionColor;
	var textColor =
		event.textColor ||
		source.textColor ||
		opt('eventTextColor');
	var statements = [];
	if (backgroundColor) {
		statements.push('background-color:' + backgroundColor);
	}
	if (borderColor) {
		statements.push('border-color:' + borderColor);
	}
	if (textColor) {
		statements.push('color:' + textColor);
	}
	return statements.join(';');
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}



fcViews.month = MonthView;

function MonthView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'month');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addMonths(date, delta);
			date.setDate(1);
		}
		var start = cloneDate(date, true);
		start.setDate(1);
		var end = addMonths(cloneDate(start), 1);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var firstDay = opt('firstDay');
		var nwe = opt('weekends') ? 0 : 1;
		if (nwe) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		addDays(visStart, -((visStart.getDay() - Math.max(firstDay, nwe) + 7) % 7));
		addDays(visEnd, (7 - visEnd.getDay() + Math.max(firstDay, nwe)) % 7);
		var rowCnt = Math.round((visEnd - visStart) / (DAY_MS * 7));
		if (opt('weekMode') == 'fixed') {
			addDays(visEnd, (6 - rowCnt) * 7);
			rowCnt = 6;
		}
		t.title = formatDate(start, opt('titleFormat'));
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderBasic(6, rowCnt, nwe ? 5 : 7, true);
	}
	
	
}

fcViews.basicWeek = BasicWeekView;

function BasicWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicWeek');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDates = calendar.formatDates;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta * 7);
		}
		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var weekends = opt('weekends');
		if (!weekends) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderBasic(1, 1, weekends ? 7 : 5, false);
	}
	
	
}

fcViews.basicDay = BasicDayView;

//TODO: when calendar's date starts out on a weekend, shouldn't happen


function BasicDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicDay');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta);
			if (!opt('weekends')) {
				skipWeekend(date, delta < 0 ? -1 : 1);
			}
		}
		t.title = formatDate(date, opt('titleFormat'));
		t.start = t.visStart = cloneDate(date, true);
		t.end = t.visEnd = addDays(cloneDate(t.start), 1);
		renderBasic(1, 1, 1, false);
	}
	
	
}

setDefaults({
	weekMode: 'fixed'
});


function BasicView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderBasic = renderBasic;
	t.setHeight = setHeight;
	t.setWidth = setWidth;
	t.renderDayOverlay = renderDayOverlay;
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // for selection (kinda hacky)
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	t.defaultEventEnd = defaultEventEnd;
	t.getHoverListener = function() { return hoverListener };
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.dayOfWeekCol = dayOfWeekCol;
	t.dateCell = dateCell;
	t.cellDate = cellDate;
	t.cellIsAllDay = function() { return true };
	t.allDayRow = allDayRow;
	t.allDayBounds = allDayBounds;
	t.getRowCnt = function() { return rowCnt };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	BasicEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var clearEvents = t.clearEvents;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var daySelectionMousedown = t.daySelectionMousedown;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var head;
	var headCells;
	var body;
	var bodyRows;
	var bodyCells;
	var bodyFirstCells;
	var bodyCellTopInners;
	var daySegmentContainer;
	
	var viewWidth;
	var viewHeight;
	var colWidth;
	
	var rowCnt, colCnt;
	var coordinateGrid;
	var hoverListener;
	var colContentPositions;
	
	var rtl, dis, dit;
	var firstDay;
	var nwe;
	var tm;
	var colFormat;
	
	
	
	/* Rendering
	------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-grid'));
	
	
	function renderBasic(maxr, r, c, showNumbers) {
		rowCnt = r;
		colCnt = c;
		updateOptions();
		var firstTime = !body;
		if (firstTime) {
			buildSkeleton(maxr, showNumbers);
		}else{
			clearEvents();
		}
		updateCells(firstTime);
	}
	
	
	
	function updateOptions() {
		rtl = opt('isRTL');
		if (rtl) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
		firstDay = opt('firstDay');
		nwe = opt('weekends') ? 0 : 1;
		tm = opt('theme') ? 'ui' : 'fc';
		colFormat = opt('columnFormat');
	}
	
	
	
	function buildSkeleton(maxRowCnt, showNumbers) {
		var s;
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var i, j;
		var table;
		
		s =
			"<table class='fc-border-separate' style='width:100%' cellspacing='0'>" +
			"<thead>" +
			"<tr>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<th class='fc- " + headerClass + "'/>"; // need fc- for setDayID
		}
		s +=
			"</tr>" +
			"</thead>" +
			"<tbody>";
		for (i=0; i<maxRowCnt; i++) {
			s +=
				"<tr class='fc-week" + i + "'>";
			for (j=0; j<colCnt; j++) {
				s +=
					"<td class='fc- " + contentClass + " fc-day" + (i*colCnt+j) + "'>" + // need fc- for setDayID
					"<div>" +
					(showNumbers ?
						"<div class='fc-day-number'/>" :
						''
						) +
					"<div class='fc-day-content'>" +
					"<div style='position:relative'>&nbsp;</div>" +
					"</div>" +
					"</div>" +
					"</td>";
			}
			s +=
				"</tr>";
		}
		s +=
			"</tbody>" +
			"</table>";
		table = $(s).appendTo(element);
		
		head = table.find('thead');
		headCells = head.find('th');
		body = table.find('tbody');
		bodyRows = body.find('tr');
		bodyCells = body.find('td');
		bodyFirstCells = bodyCells.filter(':first-child');
		bodyCellTopInners = bodyRows.eq(0).find('div.fc-day-content div');
		
		markFirstLast(head.add(head.find('tr'))); // marks first+last tr/th's
		markFirstLast(bodyRows); // marks first+last td's
		bodyRows.eq(0).addClass('fc-first'); // fc-last is done in updateCells
		
		dayBind(bodyCells);
		
		daySegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(element);
	}
	
	
	
	function updateCells(firstTime) {
		var dowDirty = firstTime || rowCnt == 1; // could the cells' day-of-weeks need updating?
		var month = t.start.getMonth();
		var today = clearTime(new Date());
		var cell;
		var date;
		var row;
	
		if (dowDirty) {
			headCells.each(function(i, _cell) {
				cell = $(_cell);
				date = indexDate(i);
				cell.html(formatDate(date, colFormat));
				setDayID(cell, date);
			});
		}
		
		bodyCells.each(function(i, _cell) {
			cell = $(_cell);
			date = indexDate(i);
			if (date.getMonth() == month) {
				cell.removeClass('fc-other-month');
			}else{
				cell.addClass('fc-other-month');
			}
			if (+date == +today) {
				cell.addClass(tm + '-state-highlight fc-today');
			}else{
				cell.removeClass(tm + '-state-highlight fc-today');
			}
			cell.find('div.fc-day-number').text(date.getDate());
			if (dowDirty) {
				setDayID(cell, date);
			}
		});
		
		bodyRows.each(function(i, _row) {
			row = $(_row);
			if (i < rowCnt) {
				row.show();
				if (i == rowCnt-1) {
					row.addClass('fc-last');
				}else{
					row.removeClass('fc-last');
				}
			}else{
				row.hide();
			}
		});
	}
	
	
	
	function setHeight(height) {
		viewHeight = height;
		
		var bodyHeight = viewHeight - head.height();
		var rowHeight;
		var rowHeightLast;
		var cell;
			
		if (opt('weekMode') == 'variable') {
			rowHeight = rowHeightLast = Math.floor(bodyHeight / (rowCnt==1 ? 2 : 6));
		}else{
			rowHeight = Math.floor(bodyHeight / rowCnt);
			rowHeightLast = bodyHeight - rowHeight * (rowCnt-1);
		}
		
		bodyFirstCells.each(function(i, _cell) {
			if (i < rowCnt) {
				cell = $(_cell);
				setMinHeight(
					cell.find('> div'),
					(i==rowCnt-1 ? rowHeightLast : rowHeight) - vsides(cell)
				);
			}
		});
		
	}
	
	
	function setWidth(width) {
		viewWidth = width;
		colContentPositions.clear();
		colWidth = Math.floor(viewWidth / colCnt);
		setOuterWidth(headCells.slice(0, -1), colWidth);
	}
	
	
	
	/* Day clicking and binding
	-----------------------------------------------------------*/
	
	
	function dayBind(days) {
		days.click(dayClick)
			.mousedown(daySelectionMousedown);
	}
	
	
	function dayClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var index = parseInt(this.className.match(/fc\-day(\d+)/)[1]); // TODO: maybe use .data
			var date = indexDate(index);
			trigger('dayClick', this, date, true, ev);
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	------------------------------------------------------*/
	
	
	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive
		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}
		var rowStart = cloneDate(t.visStart);
		var rowEnd = addDays(cloneDate(rowStart), colCnt);
		for (var i=0; i<rowCnt; i++) {
			var stretchStart = new Date(Math.max(rowStart, overlayStart));
			var stretchEnd = new Date(Math.min(rowEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var colStart, colEnd;
				if (rtl) {
					colStart = dayDiff(stretchEnd, rowStart)*dis+dit+1;
					colEnd = dayDiff(stretchStart, rowStart)*dis+dit+1;
				}else{
					colStart = dayDiff(stretchStart, rowStart);
					colEnd = dayDiff(stretchEnd, rowStart);
				}
				dayBind(
					renderCellOverlay(i, colStart, i, colEnd-1)
				);
			}
			addDays(rowStart, 7);
			addDays(rowEnd, 7);
		}
	}
	
	
	function renderCellOverlay(row0, col0, row1, col1) { // row1,col1 is inclusive
		var rect = coordinateGrid.rect(row0, col0, row1, col1, element);
		return renderOverlay(rect, element);
	}
	
	
	
	/* Selection
	-----------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		return cloneDate(startDate);
	}
	
	
	function renderSelection(startDate, endDate, allDay) {
		renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true); // rebuild every time???
	}
	
	
	function clearSelection() {
		clearOverlays();
	}
	
	
	function reportDayClick(date, allDay, ev) {
		var cell = dateCell(date);
		var _element = bodyCells[cell.row*colCnt + cell.col];
		trigger('dayClick', _element, date, allDay, ev);
	}
	
	
	
	/* External Dragging
	-----------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			var d = cellDate(cell);
			trigger('drop', _dragElement, d, true, ev, ui);
		}
	}
	
	
	
	/* Utilities
	--------------------------------------------------------*/
	
	
	function defaultEventEnd(event) {
		return cloneDate(event.start);
	}
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		headCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		bodyRows.each(function(i, _e) {
			if (i < rowCnt) {
				e = $(_e);
				n = e.offset().top;
				if (i) {
					p[1] = n;
				}
				p = [n];
				rows[i] = p;
			}
		});
		p[1] = n + e.outerHeight();
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	
	colContentPositions = new HorizontalPositionCache(function(col) {
		return bodyCellTopInners.eq(col);
	});
	
	
	function colContentLeft(col) {
		return colContentPositions.left(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}
	
	
	
	
	function dateCell(date) {
		return {
			row: Math.floor(dayDiff(date, t.visStart) / 7),
			col: dayOfWeekCol(date.getDay())
		};
	}
	
	
	function cellDate(cell) {
		return _cellDate(cell.row, cell.col);
	}
	
	
	function _cellDate(row, col) {
		return addDays(cloneDate(t.visStart), row*7 + col*dis+dit);
		// what about weekends in middle of week?
	}
	
	
	function indexDate(index) {
		return _cellDate(Math.floor(index/colCnt), index%colCnt);
	}
	
	
	function dayOfWeekCol(dayOfWeek) {
		return ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt) * dis + dit;
	}
	
	
	
	
	function allDayRow(i) {
		return bodyRows.eq(i);
	}
	
	
	function allDayBounds(i) {
		return {
			left: 0,
			right: viewWidth
		};
	}
	
	
}

function BasicEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.compileDaySegs = compileSegs; // for DayEventRenderer
	t.clearEvents = clearEvents;
	t.bindDaySeg = bindDaySeg;
	
	
	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	//var setOverflowHidden = t.setOverflowHidden;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var reportEvents = t.reportEvents;
	var reportEventClear = t.reportEventClear;
	var eventElementHandlers = t.eventElementHandlers;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getHoverListener = t.getHoverListener;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var renderDaySegs = t.renderDaySegs;
	var resizableDayEvent = t.resizableDayEvent;
	
	
	
	/* Rendering
	--------------------------------------------------------------------*/
	
	
	function renderEvents(events, modifiedEventId) {
		reportEvents(events);
		renderDaySegs(compileSegs(events), modifiedEventId);
	}
	
	
	function clearEvents() {
		reportEventClear();
		getDaySegmentContainer().empty();
	}
	
	
	function compileSegs(events) {
		var rowCnt = getRowCnt(),
			colCnt = getColCnt(),
			d1 = cloneDate(t.visStart),
			d2 = addDays(cloneDate(d1), colCnt),
			visEventsEnds = $.map(events, exclEndDay),
			i, row,
			j, level,
			k, seg,
			segs=[];
		for (i=0; i<rowCnt; i++) {
			row = stackSegs(sliceSegs(events, visEventsEnds, d1, d2));
			for (j=0; j<row.length; j++) {
				level = row[j];
				for (k=0; k<level.length; k++) {
					seg = level[k];
					seg.row = i;
					seg.level = j; // not needed anymore
					segs.push(seg);
				}
			}
			addDays(d1, 7);
			addDays(d2, 7);
		}
		return segs;
	}
	
	
	function bindDaySeg(event, eventElement, seg) {
		if (isEventDraggable(event)) {
			draggableDayEvent(event, eventElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableDayEvent(event, eventElement, seg);
		}
		eventElementHandlers(event, eventElement);
			// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
	}
	
	
	
	/* Dragging
	----------------------------------------------------------------------------*/
	
	
	function draggableDayEvent(event, eventElement) {
		var hoverListener = getHoverListener();
		var dayDelta;
		eventElement.draggable({
			zIndex: 9,
			delay: 50,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
					clearOverlays();
					if (cell) {
						//setOverflowHidden(true);
						dayDelta = rowDelta*7 + colDelta * (opt('isRTL') ? -1 : 1);
						renderDayOverlay(
							addDays(cloneDate(event.start), dayDelta),
							addDays(exclEndDay(event), dayDelta)
						);
					}else{
						//setOverflowHidden(false);
						dayDelta = 0;
					}
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (dayDelta) {
					eventDrop(this, event, dayDelta, 0, event.allDay, ev, ui);
				}else{
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}
				//setOverflowHidden(false);
			}
		});
	}


}

fcViews.agendaWeek = AgendaWeekView;

function AgendaWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaWeek');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var formatDates = calendar.formatDates;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta * 7);
		}
		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);
		var visStart = cloneDate(start);
		var visEnd = cloneDate(end);
		var weekends = opt('weekends');
		if (!weekends) {
			skipWeekend(visStart);
			skipWeekend(visEnd, -1, true);
		}
		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;
		renderAgenda(weekends ? 7 : 5);
	}
	

}

fcViews.agendaDay = AgendaDayView;

function AgendaDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaDay');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var formatDate = calendar.formatDate;
	
	
	
	function render(date, delta) {
		if (delta) {
			addDays(date, delta);
			if (!opt('weekends')) {
				skipWeekend(date, delta < 0 ? -1 : 1);
			}
		}
		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);
		t.title = formatDate(date, opt('titleFormat'));
		t.start = t.visStart = start;
		t.end = t.visEnd = end;
		renderAgenda(1);
	}
	

}

setDefaults({
	allDaySlot: true,
	allDayText: 'all-day',
	firstHour: 6,
	slotMinutes: 30,
	defaultEventMinutes: 120,
	axisFormat: 'h(:mm)tt',
	timeFormat: {
		agenda: 'h:mm{ - h:mm}'
	},
	dragOpacity: {
		agenda: .5
	},
	minTime: 0,
	maxTime: 24
});


// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6


function AgendaView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderAgenda = renderAgenda;
	t.setWidth = setWidth;
	t.setHeight = setHeight;
	t.beforeHide = beforeHide;
	t.afterShow = afterShow;
	t.defaultEventEnd = defaultEventEnd;
	t.timePosition = timePosition;
	t.dayOfWeekCol = dayOfWeekCol;
	t.dateCell = dateCell;
	t.cellDate = cellDate;
	t.cellIsAllDay = cellIsAllDay;
	t.allDayRow = getAllDayRow;
	t.allDayBounds = allDayBounds;
	t.getHoverListener = function() { return hoverListener };
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	t.getSlotSegmentContainer = function() { return slotSegmentContainer };
	t.getMinMinute = function() { return minMinute };
	t.getMaxMinute = function() { return maxMinute };
	t.getBodyContent = function() { return slotContent }; // !!??
	t.getRowCnt = function() { return 1 };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getSlotHeight = function() { return slotHeight };
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderDayOverlay = renderDayOverlay;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // selection mousedown hack
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	AgendaEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var clearEvents = t.clearEvents;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var reportSelection = t.reportSelection;
	var unselect = t.unselect;
	var daySelectionMousedown = t.daySelectionMousedown;
	var slotSegHtml = t.slotSegHtml;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var dayTable;
	var dayHead;
	var dayHeadCells;
	var dayBody;
	var dayBodyCells;
	var dayBodyCellInners;
	var dayBodyFirstCell;
	var dayBodyFirstCellStretcher;
	var slotLayer;
	var daySegmentContainer;
	var allDayTable;
	var allDayRow;
	var slotScroller;
	var slotContent;
	var slotSegmentContainer;
	var slotTable;
	var slotTableFirstInner;
	var axisFirstCells;
	var gutterCells;
	var selectionHelper;
	
	var viewWidth;
	var viewHeight;
	var axisWidth;
	var colWidth;
	var gutterWidth;
	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
	var savedScrollTop;
	
	var colCnt;
	var slotCnt;
	var coordinateGrid;
	var hoverListener;
	var colContentPositions;
	var slotTopCache = {};
	
	var tm;
	var firstDay;
	var nwe;            // no weekends (int)
	var rtl, dis, dit;  // day index sign / translate
	var minMinute, maxMinute;
	var colFormat;
	

	
	/* Rendering
	-----------------------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-agenda'));
	
	
	function renderAgenda(c) {
		colCnt = c;
		updateOptions();
		if (!dayTable) {
			buildSkeleton();
		}else{
			clearEvents();
		}
		updateCells();
	}
	
	
	
	function updateOptions() {
		tm = opt('theme') ? 'ui' : 'fc';
		nwe = opt('weekends') ? 0 : 1;
		firstDay = opt('firstDay');
		if (rtl = opt('isRTL')) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
		minMinute = parseTime(opt('minTime'));
		maxMinute = parseTime(opt('maxTime'));
		colFormat = opt('columnFormat');
	}
	
	
	
	function buildSkeleton() {
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var s;
		var i;
		var d;
		var maxd;
		var minutes;
		var slotNormal = opt('slotMinutes') % 15 == 0;
		
		s =
			"<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>" +
			"<thead>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<th class='fc- fc-col" + i + ' ' + headerClass + "'/>"; // fc- needed for setDayID
		}
		s +=
			"<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
			"</tr>" +
			"</thead>" +
			"<tbody>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		for (i=0; i<colCnt; i++) {
			s +=
				"<td class='fc- fc-col" + i + ' ' + contentClass + "'>" + // fc- needed for setDayID
				"<div>" +
				"<div class='fc-day-content'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</div>" +
				"</div>" +
				"</td>";
		}
		s +=
			"<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
			"</tr>" +
			"</tbody>" +
			"</table>";
		dayTable = $(s).appendTo(element);
		dayHead = dayTable.find('thead');
		dayHeadCells = dayHead.find('th').slice(1, -1);
		dayBody = dayTable.find('tbody');
		dayBodyCells = dayBody.find('td').slice(0, -1);
		dayBodyCellInners = dayBodyCells.find('div.fc-day-content div');
		dayBodyFirstCell = dayBodyCells.eq(0);
		dayBodyFirstCellStretcher = dayBodyFirstCell.find('> div');
		
		markFirstLast(dayHead.add(dayHead.find('tr')));
		markFirstLast(dayBody.add(dayBody.find('tr')));
		
		axisFirstCells = dayHead.find('th:first');
		gutterCells = dayTable.find('.fc-agenda-gutter');
		
		slotLayer =
			$("<div style='position:absolute;z-index:2;left:0;width:100%'/>")
				.appendTo(element);
				
		if (opt('allDaySlot')) {
		
			daySegmentContainer =
				$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
					.appendTo(slotLayer);
		
			s =
				"<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
				"<tr>" +
				"<th class='" + headerClass + " fc-agenda-axis'>" + opt('allDayText') + "</th>" +
				"<td>" +
				"<div class='fc-day-content'><div style='position:relative'/></div>" +
				"</td>" +
				"<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
				"</tr>" +
				"</table>";
			allDayTable = $(s).appendTo(slotLayer);
			allDayRow = allDayTable.find('tr');
			
			dayBind(allDayRow.find('td'));
			
			axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
			gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));
			
			slotLayer.append(
				"<div class='fc-agenda-divider " + headerClass + "'>" +
				"<div class='fc-agenda-divider-inner'/>" +
				"</div>"
			);
			
		}else{
		
			daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()
		
		}
		
		slotScroller =
			$("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>")
				.appendTo(slotLayer);
				
		slotContent =
			$("<div style='position:relative;width:100%;overflow:hidden'/>")
				.appendTo(slotScroller);
				
		slotSegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(slotContent);
		
		s =
			"<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
			"<tbody>";
		d = zeroDate();
		maxd = addMinutes(cloneDate(d), maxMinute);
		addMinutes(d, minMinute);
		slotCnt = 0;
		for (i=0; d < maxd; i++) {
			minutes = d.getMinutes();
			s +=
				"<tr class='fc-slot" + i + ' ' + (!minutes ? '' : 'fc-minor') + "'>" +
				"<th class='fc-agenda-axis " + headerClass + "'>" +
				((!slotNormal || !minutes) ? formatDate(d, opt('axisFormat')) : '&nbsp;') +
				"</th>" +
				"<td class='" + contentClass + "'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</td>" +
				"</tr>";
			addMinutes(d, opt('slotMinutes'));
			slotCnt++;
		}
		s +=
			"</tbody>" +
			"</table>";
		slotTable = $(s).appendTo(slotContent);
		slotTableFirstInner = slotTable.find('div:first');
		
		slotBind(slotTable.find('td'));
		
		axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));
	}
	
	
	
	function updateCells() {
		var i;
		var headCell;
		var bodyCell;
		var date;
		var today = clearTime(new Date());
		for (i=0; i<colCnt; i++) {
			date = colDate(i);
			headCell = dayHeadCells.eq(i);
			headCell.html(formatDate(date, colFormat));
			bodyCell = dayBodyCells.eq(i);
			if (+date == +today) {
				bodyCell.addClass(tm + '-state-highlight fc-today');
			}else{
				bodyCell.removeClass(tm + '-state-highlight fc-today');
			}
			setDayID(headCell.add(bodyCell), date);
		}
	}
	
	
	
	function setHeight(height, dateChanged) {
		if (height === undefined) {
			height = viewHeight;
		}
		viewHeight = height;
		slotTopCache = {};
	
		var headHeight = dayBody.position().top;
		var allDayHeight = slotScroller.position().top; // including divider
		var bodyHeight = Math.min( // total body height, including borders
			height - headHeight,   // when scrollbars
			slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
		);
		
		dayBodyFirstCellStretcher
			.height(bodyHeight - vsides(dayBodyFirstCell));
		
		slotLayer.css('top', headHeight);
		
		slotScroller.height(bodyHeight - allDayHeight - 1);
		
		slotHeight = slotTableFirstInner.height() + 1; // +1 for border
		
		if (dateChanged) {
			resetScroll();
		}
	}
	
	
	
	function setWidth(width) {
		viewWidth = width;
		colContentPositions.clear();
		
		axisWidth = 0;
		setOuterWidth(
			axisFirstCells
				.width('')
				.each(function(i, _cell) {
					axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
				}),
			axisWidth
		);
		
		var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)
		//slotTable.width(slotTableWidth);
		
		gutterWidth = slotScroller.width() - slotTableWidth;
		if (gutterWidth) {
			setOuterWidth(gutterCells, gutterWidth);
			gutterCells
				.show()
				.prev()
				.removeClass('fc-last');
		}else{
			gutterCells
				.hide()
				.prev()
				.addClass('fc-last');
		}
		
		colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
		setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
	}
	


	function resetScroll() {
		var d0 = zeroDate();
		var scrollDate = cloneDate(d0);
		scrollDate.setHours(opt('firstHour'));
		var top = timePosition(d0, scrollDate) + 1; // +1 for the border
		function scroll() {
			slotScroller.scrollTop(top);
		}
		scroll();
		setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
	}
	
	
	function beforeHide() {
		savedScrollTop = slotScroller.scrollTop();
	}
	
	
	function afterShow() {
		slotScroller.scrollTop(savedScrollTop);
	}
	
	
	
	/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/
	

	function dayBind(cells) {
		cells.click(slotClick)
			.mousedown(daySelectionMousedown);
	}


	function slotBind(cells) {
		cells.click(slotClick)
			.mousedown(slotSelectionMousedown);
	}
	
	
	function slotClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var col = Math.min(colCnt-1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
			var date = colDate(col);
			var rowMatch = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
			if (rowMatch) {
				var mins = parseInt(rowMatch[1]) * opt('slotMinutes');
				var hours = Math.floor(mins/60);
				date.setHours(hours);
				date.setMinutes(mins%60 + minMinute);
				trigger('dayClick', dayBodyCells[col], date, false, ev);
			}else{
				trigger('dayClick', dayBodyCells[col], date, true, ev);
			}
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
	

	function renderDayOverlay(startDate, endDate, refreshCoordinateGrid) { // endDate is exclusive
		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}
		var visStart = cloneDate(t.visStart);
		var startCol, endCol;
		if (rtl) {
			startCol = dayDiff(endDate, visStart)*dis+dit+1;
			endCol = dayDiff(startDate, visStart)*dis+dit+1;
		}else{
			startCol = dayDiff(startDate, visStart);
			endCol = dayDiff(endDate, visStart);
		}
		startCol = Math.max(0, startCol);
		endCol = Math.min(colCnt, endCol);
		if (startCol < endCol) {
			dayBind(
				renderCellOverlay(0, startCol, 0, endCol-1)
			);
		}
	}
	
	
	function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
		var rect = coordinateGrid.rect(row0, col0, row1, col1, slotLayer);
		return renderOverlay(rect, slotLayer);
	}
	

	function renderSlotOverlay(overlayStart, overlayEnd) {
		var dayStart = cloneDate(t.visStart);
		var dayEnd = addDays(cloneDate(dayStart), 1);
		for (var i=0; i<colCnt; i++) {
			var stretchStart = new Date(Math.max(dayStart, overlayStart));
			var stretchEnd = new Date(Math.min(dayEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var col = i*dis+dit;
				var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only use it for horizontal coords
				var top = timePosition(dayStart, stretchStart);
				var bottom = timePosition(dayStart, stretchEnd);
				rect.top = top;
				rect.height = bottom - top;
				slotBind(
					renderOverlay(rect, slotContent)
				);
			}
			addDays(dayStart, 1);
			addDays(dayEnd, 1);
		}
	}
	
	
	
	/* Coordinate Utilities
	-----------------------------------------------------------------------------*/
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		dayHeadCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		if (opt('allDaySlot')) {
			e = allDayRow;
			n = e.offset().top;
			rows[0] = [n, n+e.outerHeight()];
		}
		var slotTableTop = slotContent.offset().top;
		var slotScrollerTop = slotScroller.offset().top;
		var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
		function constrain(n) {
			return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
		}
		for (var i=0; i<slotCnt; i++) {
			rows.push([
				constrain(slotTableTop + slotHeight*i),
				constrain(slotTableTop + slotHeight*(i+1))
			]);
		}
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	
	colContentPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellInners.eq(col);
	});
	
	
	function colContentLeft(col) {
		return colContentPositions.left(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}
	
	
	
	
	function dateCell(date) { // "cell" terminology is now confusing
		return {
			row: Math.floor(dayDiff(date, t.visStart) / 7),
			col: dayOfWeekCol(date.getDay())
		};
	}
	
	
	function cellDate(cell) {
		var d = colDate(cell.col);
		var slotIndex = cell.row;
		if (opt('allDaySlot')) {
			slotIndex--;
		}
		if (slotIndex >= 0) {
			addMinutes(d, minMinute + slotIndex * opt('slotMinutes'));
		}
		return d;
	}
	
	
	function colDate(col) { // returns dates with 00:00:00
		return addDays(cloneDate(t.visStart), col*dis+dit);
	}
	
	
	function cellIsAllDay(cell) {
		return opt('allDaySlot') && !cell.row;
	}
	
	
	function dayOfWeekCol(dayOfWeek) {
		return ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt)*dis+dit;
	}
	
	
	
	
	// get the Y coordinate of the given time on the given day (both Date objects)
	function timePosition(day, time) { // both date objects. day holds 00:00 of current day
		day = cloneDate(day, true);
		if (time < addMinutes(cloneDate(day), minMinute)) {
			return 0;
		}
		if (time >= addMinutes(cloneDate(day), maxMinute)) {
			return slotTable.height();
		}
		var slotMinutes = opt('slotMinutes'),
			minutes = time.getHours()*60 + time.getMinutes() - minMinute,
			slotI = Math.floor(minutes / slotMinutes),
			slotTop = slotTopCache[slotI];
		if (slotTop === undefined) {
			slotTop = slotTopCache[slotI] = slotTable.find('tr:eq(' + slotI + ') td div')[0].offsetTop; //.position().top; // need this optimization???
		}
		return Math.max(0, Math.round(
			slotTop - 1 + slotHeight * ((minutes % slotMinutes) / slotMinutes)
		));
	}
	
	
	function allDayBounds() {
		return {
			left: axisWidth,
			right: viewWidth - gutterWidth
		}
	}
	
	
	function getAllDayRow(index) {
		return allDayRow;
	}
	
	
	function defaultEventEnd(event) {
		var start = cloneDate(event.start);
		if (event.allDay) {
			return start;
		}
		return addMinutes(start, opt('defaultEventMinutes'));
	}
	
	
	
	/* Selection
	---------------------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		if (allDay) {
			return cloneDate(startDate);
		}
		return addMinutes(cloneDate(startDate), opt('slotMinutes'));
	}
	
	
	function renderSelection(startDate, endDate, allDay) { // only for all-day
		if (allDay) {
			if (opt('allDaySlot')) {
				renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true);
			}
		}else{
			renderSlotSelection(startDate, endDate);
		}
	}
	
	
	function renderSlotSelection(startDate, endDate) {
		var helperOption = opt('selectHelper');
		coordinateGrid.build();
		if (helperOption) {
			var col = dayDiff(startDate, t.visStart) * dis + dit;
			if (col >= 0 && col < colCnt) { // only works when times are on same day
				var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only for horizontal coords
				var top = timePosition(startDate, startDate);
				var bottom = timePosition(startDate, endDate);
				if (bottom > top) { // protect against selections that are entirely before or after visible range
					rect.top = top;
					rect.height = bottom - top;
					rect.left += 2;
					rect.width -= 5;
					if ($.isFunction(helperOption)) {
						var helperRes = helperOption(startDate, endDate);
						if (helperRes) {
							rect.position = 'absolute';
							rect.zIndex = 8;
							selectionHelper = $(helperRes)
								.css(rect)
								.appendTo(slotContent);
						}
					}else{
						rect.isStart = true; // conside rect a "seg" now
						rect.isEnd = true;   //
						selectionHelper = $(slotSegHtml(
							{
								title: '',
								start: startDate,
								end: endDate,
								className: ['fc-select-helper'],
								editable: false
							},
							rect
						));
						selectionHelper.css('opacity', opt('dragOpacity'));
					}
					if (selectionHelper) {
						slotBind(selectionHelper);
						slotContent.append(selectionHelper);
						setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
						setOuterHeight(selectionHelper, rect.height, true);
					}
				}
			}
		}else{
			renderSlotOverlay(startDate, endDate);
		}
	}
	
	
	function clearSelection() {
		clearOverlays();
		if (selectionHelper) {
			selectionHelper.remove();
			selectionHelper = null;
		}
	}
	
	
	function slotSelectionMousedown(ev) {
		if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
			unselect(ev);
			var dates;
			hoverListener.start(function(cell, origCell) {
				clearSelection();
				if (cell && cell.col == origCell.col && !cellIsAllDay(cell)) {
					var d1 = cellDate(origCell);
					var d2 = cellDate(cell);
					dates = [
						d1,
						addMinutes(cloneDate(d1), opt('slotMinutes')),
						d2,
						addMinutes(cloneDate(d2), opt('slotMinutes'))
					].sort(cmp);
					renderSlotSelection(dates[0], dates[3]);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], false, ev);
					}
					reportSelection(dates[0], dates[3], false, ev);
				}
			});
		}
	}
	
	
	function reportDayClick(date, allDay, ev) {
		trigger('dayClick', dayBodyCells[dayOfWeekCol(date.getDay())], date, allDay, ev);
	}
	
	
	
	/* External Dragging
	--------------------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				if (cellIsAllDay(cell)) {
					renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
				}else{
					var d1 = cellDate(cell);
					var d2 = addMinutes(cloneDate(d1), opt('defaultEventMinutes'));
					renderSlotOverlay(d1, d2);
				}
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			trigger('drop', _dragElement, cellDate(cell), cellIsAllDay(cell), ev, ui);
		}
	}


}

function AgendaEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.compileDaySegs = compileDaySegs; // for DayEventRenderer
	t.clearEvents = clearEvents;
	t.slotSegHtml = slotSegHtml;
	t.bindDaySeg = bindDaySeg;
	
	
	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	//var setOverflowHidden = t.setOverflowHidden;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEvents = t.reportEvents;
	var reportEventClear = t.reportEventClear;
	var eventElementHandlers = t.eventElementHandlers;
	var setHeight = t.setHeight;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getSlotSegmentContainer = t.getSlotSegmentContainer;
	var getHoverListener = t.getHoverListener;
	var getMaxMinute = t.getMaxMinute;
	var getMinMinute = t.getMinMinute;
	var timePosition = t.timePosition;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var renderDaySegs = t.renderDaySegs;
	var resizableDayEvent = t.resizableDayEvent; // TODO: streamline binding architecture
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var getSlotHeight = t.getSlotHeight;
	var getBodyContent = t.getBodyContent;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var calendar = t.calendar;
	var formatDate = calendar.formatDate;
	var formatDates = calendar.formatDates;
	
	
	
	/* Rendering
	----------------------------------------------------------------------------*/
	

	function renderEvents(events, modifiedEventId) {
		reportEvents(events);
		var i, len=events.length,
			dayEvents=[],
			slotEvents=[];
		for (i=0; i<len; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}else{
				slotEvents.push(events[i]);
			}
		}
		if (opt('allDaySlot')) {
			renderDaySegs(compileDaySegs(dayEvents), modifiedEventId);
			setHeight(); // no params means set to viewHeight
		}
		renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId);
	}
	
	
	function clearEvents() {
		reportEventClear();
		getDaySegmentContainer().empty();
		getSlotSegmentContainer().empty();
	}
	
	
	function compileDaySegs(events) {
		var levels = stackSegs(sliceSegs(events, $.map(events, exclEndDay), t.visStart, t.visEnd)),
			i, levelCnt=levels.length, level,
			j, seg,
			segs=[];
		for (i=0; i<levelCnt; i++) {
			level = levels[i];
			for (j=0; j<level.length; j++) {
				seg = level[j];
				seg.row = 0;
				seg.level = i; // not needed anymore
				segs.push(seg);
			}
		}
		return segs;
	}
	
	
	function compileSlotSegs(events) {
		var colCnt = getColCnt(),
			minMinute = getMinMinute(),
			maxMinute = getMaxMinute(),
			d = addMinutes(cloneDate(t.visStart), minMinute),
			visEventEnds = $.map(events, slotEventEnd),
			i, col,
			j, level,
			k, seg,
			segs=[];
		for (i=0; i<colCnt; i++) {
			col = stackSegs(sliceSegs(events, visEventEnds, d, addMinutes(cloneDate(d), maxMinute-minMinute)));
			countForwardSegs(col);
			for (j=0; j<col.length; j++) {
				level = col[j];
				for (k=0; k<level.length; k++) {
					seg = level[k];
					seg.col = i;
					seg.level = j;
					segs.push(seg);
				}
			}
			addDays(d, 1, true);
		}
		return segs;
	}
	
	
	function slotEventEnd(event) {
		if (event.end) {
			return cloneDate(event.end);
		}else{
			return addMinutes(cloneDate(event.start), opt('defaultEventMinutes'));
		}
	}
	
	
	// renders events in the 'time slots' at the bottom
	
	function renderSlotSegs(segs, modifiedEventId) {
	
		var i, segCnt=segs.length, seg,
			event,
			classes,
			top, bottom,
			colI, levelI, forward,
			leftmost,
			availWidth,
			outerWidth,
			left,
			html='',
			eventElements,
			eventElement,
			triggerRes,
			vsideCache={},
			hsideCache={},
			key, val,
			contentElement,
			height,
			slotSegmentContainer = getSlotSegmentContainer(),
			rtl, dis, dit,
			colCnt = getColCnt();
			
		if (rtl = opt('isRTL')) {
			dis = -1;
			dit = colCnt - 1;
		}else{
			dis = 1;
			dit = 0;
		}
			
		// calculate position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			top = timePosition(seg.start, seg.start);
			bottom = timePosition(seg.start, seg.end);
			colI = seg.col;
			levelI = seg.level;
			forward = seg.forward || 0;
			leftmost = colContentLeft(colI*dis + dit);
			availWidth = colContentRight(colI*dis + dit) - leftmost;
			availWidth = Math.min(availWidth-6, availWidth*.95); // TODO: move this to CSS
			if (levelI) {
				// indented and thin
				outerWidth = availWidth / (levelI + forward + 1);
			}else{
				if (forward) {
					// moderately wide, aligned left still
					outerWidth = ((availWidth / (forward + 1)) - (12/2)) * 2; // 12 is the predicted width of resizer =
				}else{
					// can be entire width, aligned left
					outerWidth = availWidth;
				}
			}
			left = leftmost +                                  // leftmost possible
				(availWidth / (levelI + forward + 1) * levelI) // indentation
				* dis + (rtl ? availWidth - outerWidth : 0);   // rtl
			seg.top = top;
			seg.left = left;
			seg.outerWidth = outerWidth;
			seg.outerHeight = bottom - top;
			html += slotSegHtml(event, seg);
		}
		slotSegmentContainer[0].innerHTML = html; // faster than html()
		eventElements = slotSegmentContainer.children();
		
		// retrieve elements, run through eventRender callback, bind event handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			eventElement = $(eventElements[i]); // faster than eq()
			triggerRes = trigger('eventRender', event, event, eventElement);
			if (triggerRes === false) {
				eventElement.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					eventElement.remove();
					eventElement = $(triggerRes)
						.css({
							position: 'absolute',
							top: seg.top,
							left: seg.left
						})
						.appendTo(slotSegmentContainer);
				}
				seg.element = eventElement;
				if (event._id === modifiedEventId) {
					bindSlotSeg(event, eventElement, seg);
				}else{
					eventElement[0]._fci = i; // for lazySegBind
				}
				reportEventElement(event, eventElement);
			}
		}
		
		lazySegBind(slotSegmentContainer, segs, bindSlotSeg);
		
		// record event sides and title positions
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				val = vsideCache[key = seg.key = cssKey(eventElement[0])];
				seg.vsides = val === undefined ? (vsideCache[key] = vsides(eventElement, true)) : val;
				val = hsideCache[key];
				seg.hsides = val === undefined ? (hsideCache[key] = hsides(eventElement, true)) : val;
				contentElement = eventElement.find('div.fc-event-content');
				if (contentElement.length) {
					seg.contentTop = contentElement[0].offsetTop;
				}
			}
		}
		
		// set all positions/dimensions at once
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
				height = Math.max(0, seg.outerHeight - seg.vsides);
				eventElement[0].style.height = height + 'px';
				event = seg.event;
				if (seg.contentTop !== undefined && height - seg.contentTop < 10) {
					// not enough room for title, put it in the time header
					eventElement.find('div.fc-event-time')
						.text(formatDate(event.start, opt('timeFormat')) + ' - ' + event.title);
					eventElement.find('div.fc-event-title')
						.remove();
				}
				trigger('eventAfterRender', event, event, eventElement);
			}
		}
					
	}
	
	
	function slotSegHtml(event, seg) {
		var html = "<";
		var url = event.url;
		var skinCss = getSkinCss(event, opt);
		var skinCssAttr = (skinCss ? " style='" + skinCss + "'" : '');
		var classes = ['fc-event', 'fc-event-skin', 'fc-event-vert'];
		if (isEventDraggable(event)) {
			classes.push('fc-event-draggable');
		}
		if (seg.isStart) {
			classes.push('fc-corner-top');
		}
		if (seg.isEnd) {
			classes.push('fc-corner-bottom');
		}
		classes = classes.concat(event.className);
		if (event.source) {
			classes = classes.concat(event.source.className || []);
		}
		if (url) {
			html += "a href='" + htmlEscape(event.url) + "'";
		}else{
			html += "div";
		}
		html +=
			" class='" + classes.join(' ') + "'" +
			" style='position:absolute;z-index:8;top:" + seg.top + "px;left:" + seg.left + "px;" + skinCss + "'" +
			">" +
			"<div class='fc-event-inner fc-event-skin'" + skinCssAttr + ">" +
			"<div class='fc-event-head fc-event-skin'" + skinCssAttr + ">" +
			"<div class='fc-event-time'>" +
			htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
			"</div>" +
			"</div>" +
			"<div class='fc-event-content'>" +
			"<div class='fc-event-title'>" +
			htmlEscape(event.title) +
			"</div>" +
			"</div>" +
			"<div class='fc-event-bg'></div>" +
			"</div>"; // close inner
		if (seg.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-s'>=</div>";
		}
		html +=
			"</" + (url ? "a" : "div") + ">";
		return html;
	}
	
	
	function bindDaySeg(event, eventElement, seg) {
		if (isEventDraggable(event)) {
			draggableDayEvent(event, eventElement, seg.isStart);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableDayEvent(event, eventElement, seg);
		}
		eventElementHandlers(event, eventElement);
			// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
	}
	
	
	function bindSlotSeg(event, eventElement, seg) {
		var timeElement = eventElement.find('div.fc-event-time');
		if (isEventDraggable(event)) {
			draggableSlotEvent(event, eventElement, timeElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableSlotEvent(event, eventElement, timeElement);
		}
		eventElementHandlers(event, eventElement);
	}
	
	
	
	/* Dragging
	-----------------------------------------------------------------------------------*/
	
	
	// when event starts out FULL-DAY
	
	function draggableDayEvent(event, eventElement, isStart) {
		var origWidth;
		var revert;
		var allDay=true;
		var dayDelta;
		var dis = opt('isRTL') ? -1 : 1;
		var hoverListener = getHoverListener();
		var colWidth = getColWidth();
		var slotHeight = getSlotHeight();
		var minMinute = getMinMinute();
		eventElement.draggable({
			zIndex: 9,
			opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origWidth = eventElement.width();
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					clearOverlays();
					if (cell) {
						//setOverflowHidden(true);
						revert = false;
						dayDelta = colDelta * dis;
						if (!cell.row) {
							// on full-days
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
							resetElement();
						}else{
							// mouse is over bottom slots
							if (isStart) {
								if (allDay) {
									// convert event to temporary slot-event
									eventElement.width(colWidth - 10); // don't use entire width
									setOuterHeight(
										eventElement,
										slotHeight * Math.round(
											(event.end ? ((event.end - event.start) / MINUTE_MS) : opt('defaultEventMinutes'))
											/ opt('slotMinutes')
										)
									);
									eventElement.draggable('option', 'grid', [colWidth, 1]);
									allDay = false;
								}
							}else{
								revert = true;
							}
						}
						revert = revert || (allDay && !dayDelta);
					}else{
						resetElement();
						//setOverflowHidden(false);
						revert = true;
					}
					eventElement.draggable('option', 'revert', revert);
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (revert) {
					// hasn't moved or is out of bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}else{
					// changed!
					var minuteDelta = 0;
					if (!allDay) {
						minuteDelta = Math.round((eventElement.offset().top - getBodyContent().offset().top) / slotHeight)
							* opt('slotMinutes')
							+ minMinute
							- (event.start.getHours() * 60 + event.start.getMinutes());
					}
					eventDrop(this, event, dayDelta, minuteDelta, allDay, ev, ui);
				}
				//setOverflowHidden(false);
			}
		});
		function resetElement() {
			if (!allDay) {
				eventElement
					.width(origWidth)
					.height('')
					.draggable('option', 'grid', null);
				allDay = true;
			}
		}
	}
	
	
	// when event starts out IN TIMESLOTS
	
	function draggableSlotEvent(event, eventElement, timeElement) {
		var origPosition;
		var allDay=false;
		var dayDelta;
		var minuteDelta;
		var prevMinuteDelta;
		var dis = opt('isRTL') ? -1 : 1;
		var hoverListener = getHoverListener();
		var colCnt = getColCnt();
		var colWidth = getColWidth();
		var slotHeight = getSlotHeight();
		eventElement.draggable({
			zIndex: 9,
			scroll: false,
			grid: [colWidth, slotHeight],
			axis: colCnt==1 ? 'y' : false,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origPosition = eventElement.position();
				minuteDelta = prevMinuteDelta = 0;
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell);
					clearOverlays();
					if (cell) {
						dayDelta = colDelta * dis;
						if (opt('allDaySlot') && !cell.row) {
							// over full days
							if (!allDay) {
								// convert to temporary all-day event
								allDay = true;
								timeElement.hide();
								eventElement.draggable('option', 'grid', null);
							}
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
						}else{
							// on slots
							resetElement();
						}
					}
				}, ev, 'drag');
			},
			drag: function(ev, ui) {
				minuteDelta = Math.round((ui.position.top - origPosition.top) / slotHeight) * opt('slotMinutes');
				if (minuteDelta != prevMinuteDelta) {
					if (!allDay) {
						updateTimeText(minuteDelta);
					}
					prevMinuteDelta = minuteDelta;
				}
			},
			stop: function(ev, ui) {
				var cell = hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (cell && (dayDelta || minuteDelta || allDay)) {
					// changed!
					eventDrop(this, event, dayDelta, allDay ? 0 : minuteDelta, allDay, ev, ui);
				}else{
					// either no change or out-of-bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					eventElement.css(origPosition); // sometimes fast drags make event revert to wrong position
					updateTimeText(0);
					showEvents(event, eventElement);
				}
			}
		});
		function updateTimeText(minuteDelta) {
			var newStart = addMinutes(cloneDate(event.start), minuteDelta);
			var newEnd;
			if (event.end) {
				newEnd = addMinutes(cloneDate(event.end), minuteDelta);
			}
			timeElement.text(formatDates(newStart, newEnd, opt('timeFormat')));
		}
		function resetElement() {
			// convert back to original slot-event
			if (allDay) {
				timeElement.css('display', ''); // show() was causing display=inline
				eventElement.draggable('option', 'grid', [colWidth, slotHeight]);
				allDay = false;
			}
		}
	}
	
	
	
	/* Resizing
	--------------------------------------------------------------------------------------*/
	
	
	function resizableSlotEvent(event, eventElement, timeElement) {
		var slotDelta, prevSlotDelta;
		var slotHeight = getSlotHeight();
		eventElement.resizable({
			handles: {
				s: 'div.ui-resizable-s'
			},
			grid: slotHeight,
			start: function(ev, ui) {
				slotDelta = prevSlotDelta = 0;
				hideEvents(event, eventElement);
				eventElement.css('z-index', 9);
				trigger('eventResizeStart', this, event, ev, ui);
			},
			resize: function(ev, ui) {
				// don't rely on ui.size.height, doesn't take grid into account
				slotDelta = Math.round((Math.max(slotHeight, eventElement.height()) - ui.originalSize.height) / slotHeight);
				if (slotDelta != prevSlotDelta) {
					timeElement.text(
						formatDates(
							event.start,
							(!slotDelta && !event.end) ? null : // no change, so don't display time range
								addMinutes(eventEnd(event), opt('slotMinutes')*slotDelta),
							opt('timeFormat')
						)
					);
					prevSlotDelta = slotDelta;
				}
			},
			stop: function(ev, ui) {
				trigger('eventResizeStop', this, event, ev, ui);
				if (slotDelta) {
					eventResize(this, event, 0, opt('slotMinutes')*slotDelta, ev, ui);
				}else{
					eventElement.css('z-index', 8);
					showEvents(event, eventElement);
					// BUG: if event was really short, need to put title back in span
				}
			}
		});
	}
	

}


function countForwardSegs(levels) {
	var i, j, k, level, segForward, segBack;
	for (i=levels.length-1; i>0; i--) {
		level = levels[i];
		for (j=0; j<level.length; j++) {
			segForward = level[j];
			for (k=0; k<levels[i-1].length; k++) {
				segBack = levels[i-1][k];
				if (segsCollide(segForward, segBack)) {
					segBack.forward = Math.max(segBack.forward||0, (segForward.forward||0)+1);
				}
			}
		}
	}
}




function View(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.element = element;
	t.calendar = calendar;
	t.name = viewName;
	t.opt = opt;
	t.trigger = trigger;
	//t.setOverflowHidden = setOverflowHidden;
	t.isEventDraggable = isEventDraggable;
	t.isEventResizable = isEventResizable;
	t.reportEvents = reportEvents;
	t.eventEnd = eventEnd;
	t.reportEventElement = reportEventElement;
	t.reportEventClear = reportEventClear;
	t.eventElementHandlers = eventElementHandlers;
	t.showEvents = showEvents;
	t.hideEvents = hideEvents;
	t.eventDrop = eventDrop;
	t.eventResize = eventResize;
	// t.title
	// t.start, t.end
	// t.visStart, t.visEnd
	
	
	// imports
	var defaultEventEnd = t.defaultEventEnd;
	var normalizeEvent = calendar.normalizeEvent; // in EventManager
	var reportEventChange = calendar.reportEventChange;
	
	
	// locals
	var eventsByID = {};
	var eventElements = [];
	var eventElementsByID = {};
	var options = calendar.options;
	
	
	
	function opt(name, viewNameOverride) {
		var v = options[name];
		if (typeof v == 'object') {
			return smartProperty(v, viewNameOverride || viewName);
		}
		return v;
	}

	
	function trigger(name, thisObj) {
		return calendar.trigger.apply(
			calendar,
			[name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
		);
	}
	
	
	/*
	function setOverflowHidden(bool) {
		element.css('overflow', bool ? 'hidden' : '');
	}
	*/
	
	
	function isEventDraggable(event) {
		return isEventEditable(event) && !opt('disableDragging');
	}
	
	
	function isEventResizable(event) { // but also need to make sure the seg.isEnd == true
		return isEventEditable(event) && !opt('disableResizing');
	}
	
	
	function isEventEditable(event) {
		return firstDefined(event.editable, (event.source || {}).editable, opt('editable'));
	}
	
	
	
	/* Event Data
	------------------------------------------------------------------------------*/
	
	
	// report when view receives new events
	function reportEvents(events) { // events are already normalized at this point
		eventsByID = {};
		var i, len=events.length, event;
		for (i=0; i<len; i++) {
			event = events[i];
			if (eventsByID[event._id]) {
				eventsByID[event._id].push(event);
			}else{
				eventsByID[event._id] = [event];
			}
		}
	}
	
	
	// returns a Date object for an event's end
	function eventEnd(event) {
		return event.end ? cloneDate(event.end) : defaultEventEnd(event);
	}
	
	
	
	/* Event Elements
	------------------------------------------------------------------------------*/
	
	
	// report when view creates an element for an event
	function reportEventElement(event, element) {
		eventElements.push(element);
		if (eventElementsByID[event._id]) {
			eventElementsByID[event._id].push(element);
		}else{
			eventElementsByID[event._id] = [element];
		}
	}
	
	
	function reportEventClear() {
		eventElements = [];
		eventElementsByID = {};
	}
	
	
	// attaches eventClick, eventMouseover, eventMouseout
	function eventElementHandlers(event, eventElement) {
		eventElement
			.click(function(ev) {
				if (!eventElement.hasClass('ui-draggable-dragging') &&
					!eventElement.hasClass('ui-resizable-resizing')) {
						return trigger('eventClick', this, event, ev);
					}
			})
			.hover(
				function(ev) {
					trigger('eventMouseover', this, event, ev);
				},
				function(ev) {
					trigger('eventMouseout', this, event, ev);
				}
			);
		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
		// TODO: same for resizing
	}
	
	
	function showEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'show');
	}
	
	
	function hideEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'hide');
	}
	
	
	function eachEventElement(event, exceptElement, funcName) {
		var elements = eventElementsByID[event._id],
			i, len = elements.length;
		for (i=0; i<len; i++) {
			if (!exceptElement || elements[i][0] != exceptElement[0]) {
				elements[i][funcName]();
			}
		}
	}
	
	
	
	/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
	
	
	function eventDrop(e, event, dayDelta, minuteDelta, allDay, ev, ui) {
		var oldAllDay = event.allDay;
		var eventId = event._id;
		moveEvents(eventsByID[eventId], dayDelta, minuteDelta, allDay);
		trigger(
			'eventDrop',
			e,
			event,
			dayDelta,
			minuteDelta,
			allDay,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				moveEvents(eventsByID[eventId], -dayDelta, -minuteDelta, oldAllDay);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	function eventResize(e, event, dayDelta, minuteDelta, ev, ui) {
		var eventId = event._id;
		elongateEvents(eventsByID[eventId], dayDelta, minuteDelta);
		trigger(
			'eventResize',
			e,
			event,
			dayDelta,
			minuteDelta,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				elongateEvents(eventsByID[eventId], -dayDelta, -minuteDelta);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	
	/* Event Modification Math
	---------------------------------------------------------------------------------*/
	
	
	function moveEvents(events, dayDelta, minuteDelta, allDay) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			if (allDay !== undefined) {
				e.allDay = allDay;
			}
			addMinutes(addDays(e.start, dayDelta, true), minuteDelta);
			if (e.end) {
				e.end = addMinutes(addDays(e.end, dayDelta, true), minuteDelta);
			}
			normalizeEvent(e, options);
		}
	}
	
	
	function elongateEvents(events, dayDelta, minuteDelta) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			e.end = addMinutes(addDays(eventEnd(e), dayDelta, true), minuteDelta);
			normalizeEvent(e, options);
		}
	}
	

}

function DayEventRenderer() {
	var t = this;

	
	// exports
	t.renderDaySegs = renderDaySegs;
	t.resizableDayEvent = resizableDayEvent;
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventResize = t.eventResize;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var allDayRow = t.allDayRow;
	var allDayBounds = t.allDayBounds;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var dayOfWeekCol = t.dayOfWeekCol;
	var dateCell = t.dateCell;
	var compileDaySegs = t.compileDaySegs;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var bindDaySeg = t.bindDaySeg; //TODO: streamline this
	var formatDates = t.calendar.formatDates;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var clearSelection = t.clearSelection;
	
	
	
	/* Rendering
	-----------------------------------------------------------------------------*/
	
	
	function renderDaySegs(segs, modifiedEventId) {
		var segmentContainer = getDaySegmentContainer();
		var rowDivs;
		var rowCnt = getRowCnt();
		var colCnt = getColCnt();
		var i = 0;
		var rowI;
		var levelI;
		var colHeights;
		var j;
		var segCnt = segs.length;
		var seg;
		var top;
		var k;
		segmentContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
		daySegElementResolve(segs, segmentContainer.children());
		daySegElementReport(segs);
		daySegHandlers(segs, segmentContainer, modifiedEventId);
		daySegCalcHSides(segs);
		daySegSetWidths(segs);
		daySegCalcHeights(segs);
		rowDivs = getRowDivs();
		// set row heights, calculate event tops (in relation to row top)
		for (rowI=0; rowI<rowCnt; rowI++) {
			levelI = 0;
			colHeights = [];
			for (j=0; j<colCnt; j++) {
				colHeights[j] = 0;
			}
			while (i<segCnt && (seg = segs[i]).row == rowI) {
				// loop through segs in a row
				top = arrayMax(colHeights.slice(seg.startCol, seg.endCol));
				seg.top = top;
				top += seg.outerHeight;
				for (k=seg.startCol; k<seg.endCol; k++) {
					colHeights[k] = top;
				}
				i++;
			}
			rowDivs[rowI].height(arrayMax(colHeights));
		}
		daySegSetTops(segs, getRowTops(rowDivs));
	}
	
	
	function renderTempDaySegs(segs, adjustRow, adjustTop) {
		var tempContainer = $("<div/>");
		var elements;
		var segmentContainer = getDaySegmentContainer();
		var i;
		var segCnt = segs.length;
		var element;
		tempContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
		elements = tempContainer.children();
		segmentContainer.append(elements);
		daySegElementResolve(segs, elements);
		daySegCalcHSides(segs);
		daySegSetWidths(segs);
		daySegCalcHeights(segs);
		daySegSetTops(segs, getRowTops(getRowDivs()));
		elements = [];
		for (i=0; i<segCnt; i++) {
			element = segs[i].element;
			if (element) {
				if (segs[i].row === adjustRow) {
					element.css('top', adjustTop);
				}
				elements.push(element[0]);
			}
		}
		return $(elements);
	}
	
	
	function daySegHTML(segs) { // also sets seg.left and seg.outerWidth
		var rtl = opt('isRTL');
		var i;
		var segCnt=segs.length;
		var seg;
		var event;
		var url;
		var classes;
		var bounds = allDayBounds();
		var minLeft = bounds.left;
		var maxLeft = bounds.right;
		var leftCol;
		var rightCol;
		var left;
		var right;
		var skinCss;
		var html = '';
		// calculate desired position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			classes = ['fc-event', 'fc-event-skin', 'fc-event-hori'];
			if (isEventDraggable(event)) {
				classes.push('fc-event-draggable');
			}
			if (rtl) {
				if (seg.isStart) {
					classes.push('fc-corner-right');
				}
				if (seg.isEnd) {
					classes.push('fc-corner-left');
				}
				leftCol = dayOfWeekCol(seg.end.getDay()-1);
				rightCol = dayOfWeekCol(seg.start.getDay());
				left = seg.isEnd ? colContentLeft(leftCol) : minLeft;
				right = seg.isStart ? colContentRight(rightCol) : maxLeft;
			}else{
				if (seg.isStart) {
					classes.push('fc-corner-left');
				}
				if (seg.isEnd) {
					classes.push('fc-corner-right');
				}
				leftCol = dayOfWeekCol(seg.start.getDay());
				rightCol = dayOfWeekCol(seg.end.getDay()-1);
				left = seg.isStart ? colContentLeft(leftCol) : minLeft;
				right = seg.isEnd ? colContentRight(rightCol) : maxLeft;
			}
			classes = classes.concat(event.className);
			if (event.source) {
				classes = classes.concat(event.source.className || []);
			}
			url = event.url;
			skinCss = getSkinCss(event, opt);
			if (url) {
				html += "<a href='" + htmlEscape(url) + "'";
			}else{
				html += "<div";
			}
			html +=
				" class='" + classes.join(' ') + "'" +
				" style='position:absolute;z-index:8;left:"+left+"px;" + skinCss + "'" +
				">" +
				"<div" +
				" class='fc-event-inner fc-event-skin'" +
				(skinCss ? " style='" + skinCss + "'" : '') +
				">";
			if (!event.allDay && seg.isStart) {
				html +=
					"<span class='fc-event-time'>" +
					htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
					"</span>";
			}
			html +=
				"<span class='fc-event-title'>" + htmlEscape(event.title) + "</span>" +
				"</div>";
			if (seg.isEnd && isEventResizable(event)) {
				html +=
					"<div class='ui-resizable-handle ui-resizable-" + (rtl ? 'w' : 'e') + "'>" +
					"&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
					"</div>";
			}
			html +=
				"</" + (url ? "a" : "div" ) + ">";
			seg.left = left;
			seg.outerWidth = right - left;
			seg.startCol = leftCol;
			seg.endCol = rightCol + 1; // needs to be exclusive
		}
		return html;
	}
	
	
	function daySegElementResolve(segs, elements) { // sets seg.element
		var i;
		var segCnt = segs.length;
		var seg;
		var event;
		var element;
		var triggerRes;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			element = $(elements[i]); // faster than .eq()
			triggerRes = trigger('eventRender', event, event, element);
			if (triggerRes === false) {
				element.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					triggerRes = $(triggerRes)
						.css({
							position: 'absolute',
							left: seg.left
						});
					element.replaceWith(triggerRes);
					element = triggerRes;
				}
				seg.element = element;
			}
		}
	}
	
	
	function daySegElementReport(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				reportEventElement(seg.event, element);
			}
		}
	}
	
	
	function daySegHandlers(segs, segmentContainer, modifiedEventId) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var event;
		// retrieve elements, run through eventRender callback, bind handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				event = seg.event;
				if (event._id === modifiedEventId) {
					bindDaySeg(event, element, seg);
				}else{
					element[0]._fci = i; // for lazySegBind
				}
			}
		}
		lazySegBind(segmentContainer, segs, bindDaySeg);
	}
	
	
	function daySegCalcHSides(segs) { // also sets seg.key
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var key, val;
		var hsideCache = {};
		// record event horizontal sides
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				key = seg.key = cssKey(element[0]);
				val = hsideCache[key];
				if (val === undefined) {
					val = hsideCache[key] = hsides(element, true);
				}
				seg.hsides = val;
			}
		}
	}
	
	
	function daySegSetWidths(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				element[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
			}
		}
	}
	
	
	function daySegCalcHeights(segs) {
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var key, val;
		var vmarginCache = {};
		// record event heights
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				key = seg.key; // created in daySegCalcHSides
				val = vmarginCache[key];
				if (val === undefined) {
					val = vmarginCache[key] = vmargins(element);
				}
				seg.outerHeight = element[0].offsetHeight + val;
			}
		}
	}
	
	
	function getRowDivs() {
		var i;
		var rowCnt = getRowCnt();
		var rowDivs = [];
		for (i=0; i<rowCnt; i++) {
			rowDivs[i] = allDayRow(i)
				.find('td:first div.fc-day-content > div'); // optimal selector?
		}
		return rowDivs;
	}
	
	
	function getRowTops(rowDivs) {
		var i;
		var rowCnt = rowDivs.length;
		var tops = [];
		for (i=0; i<rowCnt; i++) {
			tops[i] = rowDivs[i][0].offsetTop; // !!?? but this means the element needs position:relative if in a table cell!!!!
		}
		return tops;
	}
	
	
	function daySegSetTops(segs, rowTops) { // also triggers eventAfterRender
		var i;
		var segCnt = segs.length;
		var seg;
		var element;
		var event;
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			element = seg.element;
			if (element) {
				element[0].style.top = rowTops[seg.row] + (seg.top||0) + 'px';
				event = seg.event;
				trigger('eventAfterRender', event, event, element);
			}
		}
	}
	
	
	
	/* Resizing
	-----------------------------------------------------------------------------------*/
	
	
	function resizableDayEvent(event, element, seg) {
		var rtl = opt('isRTL');
		var direction = rtl ? 'w' : 'e';
		var handle = element.find('div.ui-resizable-' + direction);
		var isResizing = false;
		
		// TODO: look into using jquery-ui mouse widget for this stuff
		disableTextSelection(element); // prevent native <a> selection for IE
		element
			.mousedown(function(ev) { // prevent native <a> selection for others
				ev.preventDefault();
			})
			.click(function(ev) {
				if (isResizing) {
					ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
					ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
					                               // (eventElementHandlers needs to be bound after resizableDayEvent)
				}
			});
		
		handle.mousedown(function(ev) {
			if (ev.which != 1) {
				return; // needs to be left mouse button
			}
			isResizing = true;
			var hoverListener = t.getHoverListener();
			var rowCnt = getRowCnt();
			var colCnt = getColCnt();
			var dis = rtl ? -1 : 1;
			var dit = rtl ? colCnt-1 : 0;
			var elementTop = element.css('top');
			var dayDelta;
			var helpers;
			var eventCopy = $.extend({}, event);
			var minCell = dateCell(event.start);
			clearSelection();
			$('body')
				.css('cursor', direction + '-resize')
				.one('mouseup', mouseup);
			trigger('eventResizeStart', this, event, ev);
			hoverListener.start(function(cell, origCell) {
				if (cell) {
					var r = Math.max(minCell.row, cell.row);
					var c = cell.col;
					if (rowCnt == 1) {
						r = 0; // hack for all-day area in agenda views
					}
					if (r == minCell.row) {
						if (rtl) {
							c = Math.min(minCell.col, c);
						}else{
							c = Math.max(minCell.col, c);
						}
					}
					dayDelta = (r*7 + c*dis+dit) - (origCell.row*7 + origCell.col*dis+dit);
					var newEnd = addDays(eventEnd(event), dayDelta, true);
					if (dayDelta) {
						eventCopy.end = newEnd;
						var oldHelpers = helpers;
						helpers = renderTempDaySegs(compileDaySegs([eventCopy]), seg.row, elementTop);
						helpers.find('*').css('cursor', direction + '-resize');
						if (oldHelpers) {
							oldHelpers.remove();
						}
						hideEvents(event);
					}else{
						if (helpers) {
							showEvents(event);
							helpers.remove();
							helpers = null;
						}
					}
					clearOverlays();
					renderDayOverlay(event.start, addDays(cloneDate(newEnd), 1)); // coordinate grid already rebuild at hoverListener.start
				}
			}, ev);
			
			function mouseup(ev) {
				trigger('eventResizeStop', this, event, ev);
				$('body').css('cursor', '');
				hoverListener.stop();
				clearOverlays();
				if (dayDelta) {
					eventResize(this, event, dayDelta, 0, ev);
					// event redraw will clear helpers
				}
				// otherwise, the drag handler already restored the old events
				
				setTimeout(function() { // make this happen after the element's click event
					isResizing = false;
				},0);
			}
			
		});
	}
	

}

//BUG: unselect needs to be triggered when events are dragged+dropped

function SelectionManager() {
	var t = this;
	
	
	// exports
	t.select = select;
	t.unselect = unselect;
	t.reportSelection = reportSelection;
	t.daySelectionMousedown = daySelectionMousedown;
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var defaultSelectionEnd = t.defaultSelectionEnd;
	var renderSelection = t.renderSelection;
	var clearSelection = t.clearSelection;
	
	
	// locals
	var selected = false;



	// unselectAuto
	if (opt('selectable') && opt('unselectAuto')) {
		$(document).mousedown(function(ev) {
			var ignore = opt('unselectCancel');
			if (ignore) {
				if ($(ev.target).parents(ignore).length) { // could be optimized to stop after first match
					return;
				}
			}
			unselect(ev);
		});
	}
	

	function select(startDate, endDate, allDay) {
		unselect();
		if (!endDate) {
			endDate = defaultSelectionEnd(startDate, allDay);
		}
		renderSelection(startDate, endDate, allDay);
		reportSelection(startDate, endDate, allDay);
	}
	
	
	function unselect(ev) {
		if (selected) {
			selected = false;
			clearSelection();
			trigger('unselect', null, ev);
		}
	}
	
	
	function reportSelection(startDate, endDate, allDay, ev) {
		selected = true;
		trigger('select', null, startDate, endDate, allDay, ev);
	}
	
	
	function daySelectionMousedown(ev) { // not really a generic manager method, oh well
		var cellDate = t.cellDate;
		var cellIsAllDay = t.cellIsAllDay;
		var hoverListener = t.getHoverListener();
		var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
		if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
			unselect(ev);
			var _mousedownElement = this;
			var dates;
			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellDate/cellIsAllDay info in cell
				clearSelection();
				if (cell && cellIsAllDay(cell)) {
					dates = [ cellDate(origCell), cellDate(cell) ].sort(cmp);
					renderSelection(dates[0], dates[1], true);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], true, ev);
					}
					reportSelection(dates[0], dates[1], true, ev);
				}
			});
		}
	}


}
 
function OverlayManager() {
	var t = this;
	
	
	// exports
	t.renderOverlay = renderOverlay;
	t.clearOverlays = clearOverlays;
	
	
	// locals
	var usedOverlays = [];
	var unusedOverlays = [];
	
	
	function renderOverlay(rect, parent) {
		var e = unusedOverlays.shift();
		if (!e) {
			e = $("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>");
		}
		if (e[0].parentNode != parent[0]) {
			e.appendTo(parent);
		}
		usedOverlays.push(e.css(rect).show());
		return e;
	}
	

	function clearOverlays() {
		var e;
		while (e = usedOverlays.shift()) {
			unusedOverlays.push(e.hide().unbind());
		}
	}


}

function CoordinateGrid(buildFunc) {

	var t = this;
	var rows;
	var cols;
	
	
	t.build = function() {
		rows = [];
		cols = [];
		buildFunc(rows, cols);
	};
	
	
	t.cell = function(x, y) {
		var rowCnt = rows.length;
		var colCnt = cols.length;
		var i, r=-1, c=-1;
		for (i=0; i<rowCnt; i++) {
			if (y >= rows[i][0] && y < rows[i][1]) {
				r = i;
				break;
			}
		}
		for (i=0; i<colCnt; i++) {
			if (x >= cols[i][0] && x < cols[i][1]) {
				c = i;
				break;
			}
		}
		return (r>=0 && c>=0) ? { row:r, col:c } : null;
	};
	
	
	t.rect = function(row0, col0, row1, col1, originElement) { // row1,col1 is inclusive
		var origin = originElement.offset();
		return {
			top: rows[row0][0] - origin.top,
			left: cols[col0][0] - origin.left,
			width: cols[col1][1] - cols[col0][0],
			height: rows[row1][1] - rows[row0][0]
		};
	};

}

function HoverListener(coordinateGrid) {


	var t = this;
	var bindType;
	var change;
	var firstCell;
	var cell;
	
	
	t.start = function(_change, ev, _bindType) {
		change = _change;
		firstCell = cell = null;
		coordinateGrid.build();
		mouse(ev);
		bindType = _bindType || 'mousemove';
		$(document).bind(bindType, mouse);
	};
	
	
	function mouse(ev) {
		var newCell = coordinateGrid.cell(ev.pageX, ev.pageY);
		if (!newCell != !cell || newCell && (newCell.row != cell.row || newCell.col != cell.col)) {
			if (newCell) {
				if (!firstCell) {
					firstCell = newCell;
				}
				change(newCell, firstCell, newCell.row-firstCell.row, newCell.col-firstCell.col);
			}else{
				change(newCell, firstCell);
			}
			cell = newCell;
		}
	}
	
	
	t.stop = function() {
		$(document).unbind(bindType, mouse);
		return cell;
	};
	
	
}

function HorizontalPositionCache(getElement) {

	var t = this,
		elements = {},
		lefts = {},
		rights = {};
		
	function e(i) {
		return elements[i] = elements[i] || getElement(i);
	}
	
	t.left = function(i) {
		return lefts[i] = lefts[i] === undefined ? e(i).position().left : lefts[i];
	};
	
	t.right = function(i) {
		return rights[i] = rights[i] === undefined ? t.left(i) + e(i).width() : rights[i];
	};
	
	t.clear = function() {
		elements = {};
		lefts = {};
		rights = {};
	};
	
}

})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/fts.js $
// Revision: 14981 $

var fields = new Array;

// [VG] Fonction permettant d\'afficher/cacher un conteneur
function disp_div_with_cond (div_id, div_ref_id, cond)
{
  // conteneur à afficher
  var d = document.getElementById(div_id);
  // conteneur référent
  var value = document.getElementById(div_ref_id).value;
  if (typeof(cond) == 'object')
  {
    d.style.display = "none";
    
    for (var i = 0; i < cond.length; i++)
    {
      if (value == cond[i])
      {
        d.style.display = "block";
        break;
      }
    }
  }
  else
  {
    if (value == cond)
    {
      d.style.display = "block";
    }
    else
    {
      d.style.display = "none";
    }
  }
  resizeWindow();
}

// Fonction permettant d'ouvrir une page externe (Utilisé pour les mots-clés)
function create_popup (page, id, data)
{
  var url = page;
  if (data != "")
  {
    var d = document.getElementById(data).value;
    url = url + "&frm_data=" + d;
  }
  window.open(url,id,"menubar=no, status=no, scrollbars=no, menubar=no, width=400, height=300");
}

function fldRqd (fldID, frm, msg)
{
  // Properties
  this.id = fldID;
  this.frm = frm;
  this.msg = msg;
  
  // Assign Methods
  this.check = checkRqdFld;
  
  // register in global collections
  fields.push(this);
}

// Fonction permettant de vérifier les champs obligatoires
function checkRqdFld ()
{
  aValid = 1;
  var d = document.getElementById(this.id);
  
  if (d == null || d == 'undefined')
  {
    aValid = 0;
  }
  else
  {
    if (d.value == null || d.value == '')
    aValid = 0;
  }
  
  if (aValid == 0)
  {
    d.style.backgroundColor = 'yellow';
    $(d).setCSSComboboxUI("backgroundColor", "yellow");
    alert(this.msg);
  }
  
  return aValid;
}

function saveFormFts (formID)
{
  var cpt = fields.length;
  var aValid = 1;
  
  for (var i = 0; i < cpt; i++)
  {
    if (fields[i].frm == formID)
    {
      aValid = fields[i].check();
      if (aValid == 0)
      return false;
    }
  }
  
  eval(formID + '.submit();');
  
  return true;
}

// Calcul de la position x d'un élément HTML (appelé dans la fonction disp_custom_fts)
function get_offsetTop (elt_id)
{
  var offsetTop = 0;
  
  element = document.getElementById(elt_id);
  while(element)
  {
    offsetTop += element["offsetTop"];
    element = element.offsetParent;
  }
  offsetTop += document.getElementById(elt_id)["offsetHeight"];
  
  return offsetTop;
}

// Calcul de la position y d'un élément HTML (appelé dans la fonction disp_custom_fts)
function get_offsetLeft (elt_id)
{
  var offsetLeft = 0;
  
  element = document.getElementById(elt_id);
  while(element)
  {
    offsetLeft += element["offsetLeft"];
    element = element.offsetParent;
  }
  offsetLeft += document.getElementById(elt_id)["offsetWidth"];
  
  return offsetLeft;
}

// affichage et positionnement du conteneur permettant de sélectionner un moteur de recherche (appelé dans le ficher fts.php / fonction get_searchSelectEngineCmp)
function disp_custom_fts (div_id, parent_id, dwh)
{
  var d = document.getElementById(div_id);
  var p = document.getElementById(parent_id);
  var top = 0;
  var left = 0;
  
  if (p != null && p != "undefined")
  {
    top = get_offsetTop(parent_id);
    left = get_offsetLeft(parent_id);
    left -= dwh;
  }
  if (d != null && d != "undefined")
  {
    if (d.style.display == "none")
    {
      d.style.top = top;
      d.style.left = left;
      d.style.display = "block";
    }
    else
    d.style.display = "none";
  }
}/*
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
/**
 * The YAHOO object is the single global object used by YUI Library.  It
 * contains utility function for setting up namespaces, inheritance, and
 * logging.  YAHOO.util, YAHOO.widget, and YAHOO.example are namespaces
 * created automatically for and used by the library.
 * @module yahoo
 * @title  YAHOO Global
 */

/**
 * YAHOO_config is not included as part of the library.  Instead it is an
 * object that can be defined by the implementer immediately before
 * including the YUI library.  The properties included in this object
 * will be used to configure global properties needed as soon as the
 * library begins to load.
 * @class YAHOO_config
 * @static
 */

/**
 * A reference to a function that will be executed every time a YAHOO module
 * is loaded.  As parameter, this function will receive the version
 * information for the module. See <a href="YAHOO.env.html#getVersion">
 * YAHOO.env.getVersion</a> for the description of the version data structure.
 * @property listener
 * @type Function
 * @static
 * @default undefined
 */

/**
 * Set to true if the library will be dynamically loaded after window.onload.
 * Defaults to false
 * @property injecting
 * @type boolean
 * @static
 * @default undefined
 */

/**
 * Instructs the yuiloader component to dynamically load yui components and
 * their dependencies.  See the yuiloader documentation for more information
 * about dynamic loading
 * @property load
 * @static
 * @default undefined
 * @see yuiloader
 */

/**
 * Forces the use of the supplied locale where applicable in the library
 * @property locale
 * @type string
 * @static
 * @default undefined
 */

if (typeof YAHOO == "undefined" || !YAHOO) {
    /**
     * The YAHOO global namespace object.  If YAHOO is already defined, the
     * existing YAHOO object will not be overwritten so that defined
     * namespaces are preserved.
     * @class YAHOO
     * @static
     */
    var YAHOO = {};
}

/**
 * Returns the namespace specified and creates it if it doesn't exist
 * <pre>
 * YAHOO.namespace("property.package");
 * YAHOO.namespace("YAHOO.property.package");
 * </pre>
 * Either of the above would create YAHOO.property, then
 * YAHOO.property.package
 *
 * Be careful when naming packages. Reserved words may work in some browsers
 * and not others. For instance, the following will fail in Safari:
 * <pre>
 * YAHOO.namespace("really.long.nested.namespace");
 * </pre>
 * This fails because "long" is a future reserved word in ECMAScript
 *
 * For implementation code that uses YUI, do not create your components
 * in the namespaces defined by YUI (
 * <code>YAHOO.util</code>,
 * <code>YAHOO.widget</code>,
 * <code>YAHOO.lang</code>,
 * <code>YAHOO.tool</code>,
 * <code>YAHOO.example</code>,
 * <code>YAHOO.env</code>) -- create your own namespace (e.g., 'companyname').
 *
 * @method namespace
 * @static
 * @param  {String*} arguments 1-n namespaces to create
 * @return {Object}  A reference to the last namespace object created
 */
YAHOO.namespace = function() {
    var a=arguments, o=null, i, j, d;
    for (i=0; i<a.length; i=i+1) {
        d=(""+a[i]).split(".");
        o=YAHOO;

        // YAHOO is implied, so it is ignored if it is included
        for (j=(d[0] == "YAHOO") ? 1 : 0; j<d.length; j=j+1) {
            o[d[j]]=o[d[j]] || {};
            o=o[d[j]];
        }
    }

    return o;
};

/**
 * Uses YAHOO.widget.Logger to output a log message, if the widget is
 * available.
 * Note: LogReader adds the message, category, and source to the DOM as HTML.
 *
 * @method log
 * @static
 * @param  {HTML}  msg  The message to log.
 * @param  {HTML}  cat  The log category for the message.  Default
 *                        categories are "info", "warn", "error", time".
 *                        Custom categories can be used as well. (opt)
 * @param  {HTML}  src  The source of the the message (opt)
 * @return {Boolean}      True if the log operation was successful.
 */
YAHOO.log = function(msg, cat, src) {
    var l=YAHOO.widget.Logger;
    if(l && l.log) {
        return l.log(msg, cat, src);
    } else {
        return false;
    }
};

/**
 * Registers a module with the YAHOO object
 * @method register
 * @static
 * @param {String}   name    the name of the module (event, slider, etc)
 * @param {Function} mainClass a reference to class in the module.  This
 *                             class will be tagged with the version info
 *                             so that it will be possible to identify the
 *                             version that is in use when multiple versions
 *                             have loaded
 * @param {Object}   data      metadata object for the module.  Currently it
 *                             is expected to contain a "version" property
 *                             and a "build" property at minimum.
 */
YAHOO.register = function(name, mainClass, data) {
    var mods = YAHOO.env.modules, m, v, b, ls, i;

    if (!mods[name]) {
        mods[name] = {
            versions:[],
            builds:[]
        };
    }

    m  = mods[name];
    v  = data.version;
    b  = data.build;
    ls = YAHOO.env.listeners;

    m.name = name;
    m.version = v;
    m.build = b;
    m.versions.push(v);
    m.builds.push(b);
    m.mainClass = mainClass;

    // fire the module load listeners
    for (i=0;i<ls.length;i=i+1) {
        ls[i](m);
    }
    // label the main class
    if (mainClass) {
        mainClass.VERSION = v;
        mainClass.BUILD = b;
    } else {
        YAHOO.log("mainClass is undefined for module " + name, "warn");
    }
};

/**
 * YAHOO.env is used to keep track of what is known about the YUI library and
 * the browsing environment
 * @class YAHOO.env
 * @static
 */
YAHOO.env = YAHOO.env || {

    /**
     * Keeps the version info for all YUI modules that have reported themselves
     * @property modules
     * @type Object[]
     */
    modules: [],

    /**
     * List of functions that should be executed every time a YUI module
     * reports itself.
     * @property listeners
     * @type Function[]
     */
    listeners: []
};

/**
 * Returns the version data for the specified module:
 *      <dl>
 *      <dt>name:</dt>      <dd>The name of the module</dd>
 *      <dt>version:</dt>   <dd>The version in use</dd>
 *      <dt>build:</dt>     <dd>The build number in use</dd>
 *      <dt>versions:</dt>  <dd>All versions that were registered</dd>
 *      <dt>builds:</dt>    <dd>All builds that were registered.</dd>
 *      <dt>mainClass:</dt> <dd>An object that was was stamped with the
 *                 current version and build. If
 *                 mainClass.VERSION != version or mainClass.BUILD != build,
 *                 multiple versions of pieces of the library have been
 *                 loaded, potentially causing issues.</dd>
 *       </dl>
 *
 * @method getVersion
 * @static
 * @param {String}  name the name of the module (event, slider, etc)
 * @return {Object} The version info
 */
YAHOO.env.getVersion = function(name) {
    return YAHOO.env.modules[name] || null;
};

/**
 * Do not fork for a browser if it can be avoided.  Use feature detection when
 * you can.  Use the user agent as a last resort.  YAHOO.env.ua stores a version
 * number for the browser engine, 0 otherwise.  This value may or may not map
 * to the version number of the browser using the engine.  The value is
 * presented as a float so that it can easily be used for boolean evaluation
 * as well as for looking for a particular range of versions.  Because of this,
 * some of the granularity of the version info may be lost (e.g., Gecko 1.8.0.9
 * reports 1.8).
 * @class YAHOO.env.ua
 * @static
 */

/**
 * parses a user agent string (or looks for one in navigator to parse if
 * not supplied).
 * @method parseUA
 * @since 2.9.0
 * @static
 */
YAHOO.env.parseUA = function(agent) {

        var numberify = function(s) {
            var c = 0;
            return parseFloat(s.replace(/\./g, function() {
                return (c++ == 1) ? '' : '.';
            }));
        },

        nav = navigator,

        o = {

        /**
         * Internet Explorer version number or 0.  Example: 6
         * @property ie
         * @type float
         * @static
         */
        ie: 0,

        /**
         * Opera version number or 0.  Example: 9.2
         * @property opera
         * @type float
         * @static
         */
        opera: 0,

        /**
         * Gecko engine revision number.  Will evaluate to 1 if Gecko
         * is detected but the revision could not be found. Other browsers
         * will be 0.  Example: 1.8
         * <pre>
         * Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
         * Firefox 1.5.0.9: 1.8.0.9 <-- 1.8
         * Firefox 2.0.0.3: 1.8.1.3 <-- 1.81
         * Firefox 3.0   <-- 1.9
         * Firefox 3.5   <-- 1.91
         * </pre>
         * @property gecko
         * @type float
         * @static
         */
        gecko: 0,

        /**
         * AppleWebKit version.  KHTML browsers that are not WebKit browsers
         * will evaluate to 1, other browsers 0.  Example: 418.9
         * <pre>
         * Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the
         *                                   latest available for Mac OSX 10.3.
         * Safari 2.0.2:         416     <-- hasOwnProperty introduced
         * Safari 2.0.4:         418     <-- preventDefault fixed
         * Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
         *                                   different versions of webkit
         * Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
         *                                   updated, but not updated
         *                                   to the latest patch.
         * Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native
         * SVG and many major issues fixed).
         * Safari 3.0.4 (523.12) 523.12  <-- First Tiger release - automatic
         * update from 2.x via the 10.4.11 OS patch.
         * Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
         *                                   yahoo.com user agent hack removed.
         * </pre>
         * http://en.wikipedia.org/wiki/Safari_version_history
         * @property webkit
         * @type float
         * @static
         */
        webkit: 0,

        /**
         * Chrome will be detected as webkit, but this property will also
         * be populated with the Chrome version number
         * @property chrome
         * @type float
         * @static
         */
        chrome: 0,

        /**
         * The mobile property will be set to a string containing any relevant
         * user agent information when a modern mobile browser is detected.
         * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
         * devices with the WebKit-based browser, and Opera Mini.
         * @property mobile
         * @type string
         * @static
         */
        mobile: null,

        /**
         * Adobe AIR version number or 0.  Only populated if webkit is detected.
         * Example: 1.0
         * @property air
         * @type float
         */
        air: 0,
        /**
         * Detects Apple iPad's OS version
         * @property ipad
         * @type float
         * @static
         */
        ipad: 0,
        /**
         * Detects Apple iPhone's OS version
         * @property iphone
         * @type float
         * @static
         */
        iphone: 0,
        /**
         * Detects Apples iPod's OS version
         * @property ipod
         * @type float
         * @static
         */
        ipod: 0,
        /**
         * General truthy check for iPad, iPhone or iPod
         * @property ios
         * @type float
         * @static
         */
        ios: null,
        /**
         * Detects Googles Android OS version
         * @property android
         * @type float
         * @static
         */
        android: 0,
        /**
         * Detects Palms WebOS version
         * @property webos
         * @type float
         * @static
         */
        webos: 0,

        /**
         * Google Caja version number or 0.
         * @property caja
         * @type float
         */
        caja: nav && nav.cajaVersion,

        /**
         * Set to true if the page appears to be in SSL
         * @property secure
         * @type boolean
         * @static
         */
        secure: false,

        /**
         * The operating system.  Currently only detecting windows or macintosh
         * @property os
         * @type string
         * @static
         */
        os: null

    },

    ua = agent || (navigator && navigator.userAgent),

    loc = window && window.location,

    href = loc && loc.href,

    m;

    o.secure = href && (href.toLowerCase().indexOf("https") === 0);

    if (ua) {

        if ((/windows|win32/i).test(ua)) {
            o.os = 'windows';
        } else if ((/macintosh/i).test(ua)) {
            o.os = 'macintosh';
        } else if ((/rhino/i).test(ua)) {
            o.os = 'rhino';
        }

        // Modern KHTML browsers should qualify as Safari X-Grade
        if ((/KHTML/).test(ua)) {
            o.webkit = 1;
        }
        // Modern WebKit browsers are at least X-Grade
        m = ua.match(/AppleWebKit\/([^\s]*)/);
        if (m && m[1]) {
            o.webkit = numberify(m[1]);

            // Mobile browser check
            if (/ Mobile\//.test(ua)) {
                o.mobile = 'Apple'; // iPhone or iPod Touch

                m = ua.match(/OS ([^\s]*)/);
                if (m && m[1]) {
                    m = numberify(m[1].replace('_', '.'));
                }
                o.ios = m;
                o.ipad = o.ipod = o.iphone = 0;

                m = ua.match(/iPad|iPod|iPhone/);
                if (m && m[0]) {
                    o[m[0].toLowerCase()] = o.ios;
                }
            } else {
                m = ua.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);
                if (m) {
                    // Nokia N-series, Android, webOS, ex: NokiaN95
                    o.mobile = m[0];
                }
                if (/webOS/.test(ua)) {
                    o.mobile = 'WebOS';
                    m = ua.match(/webOS\/([^\s]*);/);
                    if (m && m[1]) {
                        o.webos = numberify(m[1]);
                    }
                }
                if (/ Android/.test(ua)) {
                    o.mobile = 'Android';
                    m = ua.match(/Android ([^\s]*);/);
                    if (m && m[1]) {
                        o.android = numberify(m[1]);
                    }

                }
            }

            m = ua.match(/Chrome\/([^\s]*)/);
            if (m && m[1]) {
                o.chrome = numberify(m[1]); // Chrome
            } else {
                m = ua.match(/AdobeAIR\/([^\s]*)/);
                if (m) {
                    o.air = m[0]; // Adobe AIR 1.0 or better
                }
            }
        }

        if (!o.webkit) { // not webkit
// @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
            m = ua.match(/Opera[\s\/]([^\s]*)/);
            if (m && m[1]) {
                o.opera = numberify(m[1]);
                m = ua.match(/Version\/([^\s]*)/);
                if (m && m[1]) {
                    o.opera = numberify(m[1]); // opera 10+
                }
                m = ua.match(/Opera Mini[^;]*/);
                if (m) {
                    o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
                }
            } else { // not opera or webkit
                m = ua.match(/MSIE\s([^;]*)/);
                if (m && m[1]) {
                    o.ie = numberify(m[1]);
                } else { // not opera, webkit, or ie
                    m = ua.match(/Gecko\/([^\s]*)/);
                    if (m) {
                        o.gecko = 1; // Gecko detected, look for revision
                        m = ua.match(/rv:([^\s\)]*)/);
                        if (m && m[1]) {
                            o.gecko = numberify(m[1]);
                        }
                    }
                }
            }
        }
    }

    return o;
};

YAHOO.env.ua = YAHOO.env.parseUA();

/*
 * Initializes the global by creating the default namespaces and applying
 * any new configuration information that is detected.  This is the setup
 * for env.
 * @method init
 * @static
 * @private
 */
(function() {
    YAHOO.namespace("util", "widget", "example");
    /*global YAHOO_config*/
    if ("undefined" !== typeof YAHOO_config) {
        var l=YAHOO_config.listener, ls=YAHOO.env.listeners,unique=true, i;
        if (l) {
            // if YAHOO is loaded multiple times we need to check to see if
            // this is a new config object.  If it is, add the new component
            // load listener to the stack
            for (i=0; i<ls.length; i++) {
                if (ls[i] == l) {
                    unique = false;
                    break;
                }
            }

            if (unique) {
                ls.push(l);
            }
        }
    }
})();
/**
 * Provides the language utilites and extensions used by the library
 * @class YAHOO.lang
 */
YAHOO.lang = YAHOO.lang || {};

(function() {


var L = YAHOO.lang,

    OP = Object.prototype,
    ARRAY_TOSTRING = '[object Array]',
    FUNCTION_TOSTRING = '[object Function]',
    OBJECT_TOSTRING = '[object Object]',
    NOTHING = [],

    HTML_CHARS = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;',
        '`': '&#x60;'
    },

    // ADD = ["toString", "valueOf", "hasOwnProperty"],
    ADD = ["toString", "valueOf"],

    OB = {

    /**
     * Determines wheather or not the provided object is an array.
     * @method isArray
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isArray: function(o) {
        return OP.toString.apply(o) === ARRAY_TOSTRING;
    },

    /**
     * Determines whether or not the provided object is a boolean
     * @method isBoolean
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isBoolean: function(o) {
        return typeof o === 'boolean';
    },

    /**
     * Determines whether or not the provided object is a function.
     * Note: Internet Explorer thinks certain functions are objects:
     *
     * var obj = document.createElement("object");
     * YAHOO.lang.isFunction(obj.getAttribute) // reports false in IE
     *
     * var input = document.createElement("input"); // append to body
     * YAHOO.lang.isFunction(input.focus) // reports false in IE
     *
     * You will have to implement additional tests if these functions
     * matter to you.
     *
     * @method isFunction
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isFunction: function(o) {
        return (typeof o === 'function') || OP.toString.apply(o) === FUNCTION_TOSTRING;
    },

    /**
     * Determines whether or not the provided object is null
     * @method isNull
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNull: function(o) {
        return o === null;
    },

    /**
     * Determines whether or not the provided object is a legal number
     * @method isNumber
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNumber: function(o) {
        return typeof o === 'number' && isFinite(o);
    },

    /**
     * Determines whether or not the provided object is of type object
     * or function
     * @method isObject
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isObject: function(o) {
return (o && (typeof o === 'object' || L.isFunction(o))) || false;
    },

    /**
     * Determines whether or not the provided object is a string
     * @method isString
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isString: function(o) {
        return typeof o === 'string';
    },

    /**
     * Determines whether or not the provided object is undefined
     * @method isUndefined
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isUndefined: function(o) {
        return typeof o === 'undefined';
    },


    /**
     * IE will not enumerate native functions in a derived object even if the
     * function was overridden.  This is a workaround for specific functions
     * we care about on the Object prototype.
     * @property _IEEnumFix
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @static
     * @private
     */
    _IEEnumFix: (YAHOO.env.ua.ie) ? function(r, s) {
            var i, fname, f;
            for (i=0;i<ADD.length;i=i+1) {

                fname = ADD[i];
                f = s[fname];

                if (L.isFunction(f) && f!=OP[fname]) {
                    r[fname]=f;
                }
            }
    } : function(){},

    /**
     * <p>
     * Returns a copy of the specified string with special HTML characters
     * escaped. The following characters will be converted to their
     * corresponding character entities:
     * <code>&amp; &lt; &gt; &quot; &#x27; &#x2F; &#x60;</code>
     * </p>
     *
     * <p>
     * This implementation is based on the
     * <a href="http://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">OWASP
     * HTML escaping recommendations</a>. In addition to the characters
     * in the OWASP recommendation, we also escape the <code>&#x60;</code>
     * character, since IE interprets it as an attribute delimiter when used in
     * innerHTML.
     * </p>
     *
     * @method escapeHTML
     * @param {String} html String to escape.
     * @return {String} Escaped string.
     * @static
     * @since 2.9.0
     */
    escapeHTML: function (html) {
        return html.replace(/[&<>"'\/`]/g, function (match) {
            return HTML_CHARS[match];
        });
    },

    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (!superc||!subc) {
            throw new Error("extend failed, please check that " +
                            "all dependencies are included.");
        }
        var F = function() {}, i;
        F.prototype=superc.prototype;
        subc.prototype=new F();
        subc.prototype.constructor=subc;
        subc.superclass=superc.prototype;
        if (superc.prototype.constructor == OP.constructor) {
            superc.prototype.constructor=superc;
        }

        if (overrides) {
            for (i in overrides) {
                if (L.hasOwnProperty(overrides, i)) {
                    subc.prototype[i]=overrides[i];
                }
            }

            L._IEEnumFix(subc.prototype, overrides);
        }
    },

    /**
     * Applies all properties in the supplier to the receiver if the
     * receiver does not have these properties yet.  Optionally, one or
     * more methods/properties can be specified (as additional
     * parameters).  This option will overwrite the property if receiver
     * has it already.  If true is passed as the third parameter, all
     * properties will be applied and _will_ overwrite properties in
     * the receiver.
     *
     * @method augmentObject
     * @static
     * @since 2.3.0
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {String*|boolean}  arguments zero or more properties methods
     *        to augment the receiver with.  If none specified, everything
     *        in the supplier will be used unless it would
     *        overwrite an existing property in the receiver. If true
     *        is specified as the third parameter, all properties will
     *        be applied and will overwrite an existing property in
     *        the receiver
     */
    augmentObject: function(r, s) {
        if (!s||!r) {
            throw new Error("Absorb failed, verify dependencies.");
        }
        var a=arguments, i, p, overrideList=a[2];
        if (overrideList && overrideList!==true) { // only absorb the specified properties
            for (i=2; i<a.length; i=i+1) {
                r[a[i]] = s[a[i]];
            }
        } else { // take everything, overwriting only if the third parameter is true
            for (p in s) {
                if (overrideList || !(p in r)) {
                    r[p] = s[p];
                }
            }

            L._IEEnumFix(r, s);
        }

        return r;
    },

    /**
     * Same as YAHOO.lang.augmentObject, except it only applies prototype properties
     * @see YAHOO.lang.augmentObject
     * @method augmentProto
     * @static
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {String*|boolean}  arguments zero or more properties methods
     *        to augment the receiver with.  If none specified, everything
     *        in the supplier will be used unless it would overwrite an existing
     *        property in the receiver.  if true is specified as the third
     *        parameter, all properties will be applied and will overwrite an
     *        existing property in the receiver
     */
    augmentProto: function(r, s) {
        if (!s||!r) {
            throw new Error("Augment failed, verify dependencies.");
        }
        //var a=[].concat(arguments);
        var a=[r.prototype,s.prototype], i;
        for (i=2;i<arguments.length;i=i+1) {
            a.push(arguments[i]);
        }
        L.augmentObject.apply(this, a);

        return r;
    },


    /**
     * Returns a simple string representation of the object or array.
     * Other types of objects will be returned unprocessed.  Arrays
     * are expected to be indexed.  Use object notation for
     * associative arrays.
     * @method dump
     * @since 2.3.0
     * @param o {Object} The object to dump
     * @param d {int} How deep to recurse child objects, default 3
     * @return {String} the dump result
     */
    dump: function(o, d) {
        var i,len,s=[],OBJ="{...}",FUN="f(){...}",
            COMMA=', ', ARROW=' => ';

        // Cast non-objects to string
        // Skip dates because the std toString is what we want
        // Skip HTMLElement-like objects because trying to dump
        // an element will cause an unhandled exception in FF 2.x
        if (!L.isObject(o)) {
            return o + "";
        } else if (o instanceof Date || ("nodeType" in o && "tagName" in o)) {
            return o;
        } else if  (L.isFunction(o)) {
            return FUN;
        }

        // dig into child objects the depth specifed. Default 3
        d = (L.isNumber(d)) ? d : 3;

        // arrays [1, 2, 3]
        if (L.isArray(o)) {
            s.push("[");
            for (i=0,len=o.length;i<len;i=i+1) {
                if (L.isObject(o[i])) {
                    s.push((d > 0) ? L.dump(o[i], d-1) : OBJ);
                } else {
                    s.push(o[i]);
                }
                s.push(COMMA);
            }
            if (s.length > 1) {
                s.pop();
            }
            s.push("]");
        // objects {k1 => v1, k2 => v2}
        } else {
            s.push("{");
            for (i in o) {
                if (L.hasOwnProperty(o, i)) {
                    s.push(i + ARROW);
                    if (L.isObject(o[i])) {
                        s.push((d > 0) ? L.dump(o[i], d-1) : OBJ);
                    } else {
                        s.push(o[i]);
                    }
                    s.push(COMMA);
                }
            }
            if (s.length > 1) {
                s.pop();
            }
            s.push("}");
        }

        return s.join("");
    },

    /**
     * Does variable substitution on a string. It scans through the string
     * looking for expressions enclosed in { } braces. If an expression
     * is found, it is used a key on the object.  If there is a space in
     * the key, the first word is used for the key and the rest is provided
     * to an optional function to be used to programatically determine the
     * value (the extra information might be used for this decision). If
     * the value for the key in the object, or what is returned from the
     * function has a string value, number value, or object value, it is
     * substituted for the bracket expression and it repeats.  If this
     * value is an object, it uses the Object's toString() if this has
     * been overridden, otherwise it does a shallow dump of the key/value
     * pairs.
     *
     * By specifying the recurse option, the string is rescanned after
     * every replacement, allowing for nested template substitutions.
     * The side effect of this option is that curly braces in the
     * replacement content must be encoded.
     *
     * @method substitute
     * @since 2.3.0
     * @param s {String} The string that will be modified.
     * @param o {Object} An object containing the replacement values
     * @param f {Function} An optional function that can be used to
     *                     process each match.  It receives the key,
     *                     value, and any extra metadata included with
     *                     the key inside of the braces.
     * @param recurse {boolean} default true - if not false, the replaced
     * string will be rescanned so that nested substitutions are possible.
     * @return {String} the substituted string
     */
    substitute: function (s, o, f, recurse) {
        var i, j, k, key, v, meta, saved=[], token, lidx=s.length,
            DUMP='dump', SPACE=' ', LBRACE='{', RBRACE='}',
            dump, objstr;

        for (;;) {
            i = s.lastIndexOf(LBRACE, lidx);
            if (i < 0) {
                break;
            }
            j = s.indexOf(RBRACE, i);
            if (i + 1 > j) {
                break;
            }

            //Extract key and meta info
            token = s.substring(i + 1, j);
            key = token;
            meta = null;
            k = key.indexOf(SPACE);
            if (k > -1) {
                meta = key.substring(k + 1);
                key = key.substring(0, k);
            }

            // lookup the value
            v = o[key];

            // if a substitution function was provided, execute it
            if (f) {
                v = f(key, v, meta);
            }

            if (L.isObject(v)) {
                if (L.isArray(v)) {
                    v = L.dump(v, parseInt(meta, 10));
                } else {
                    meta = meta || "";

                    // look for the keyword 'dump', if found force obj dump
                    dump = meta.indexOf(DUMP);
                    if (dump > -1) {
                        meta = meta.substring(4);
                    }

                    objstr = v.toString();

                    // use the toString if it is not the Object toString
                    // and the 'dump' meta info was not found
                    if (objstr === OBJECT_TOSTRING || dump > -1) {
                        v = L.dump(v, parseInt(meta, 10));
                    } else {
                        v = objstr;
                    }
                }
            } else if (!L.isString(v) && !L.isNumber(v)) {
                // This {block} has no replace string. Save it for later.
                v = "~-" + saved.length + "-~";
                saved[saved.length] = token;

                // break;
            }

            s = s.substring(0, i) + v + s.substring(j + 1);

            if (recurse === false) {
                lidx = i-1;
            }

        }

        // restore saved {block}s
        for (i=saved.length-1; i>=0; i=i-1) {
            s = s.replace(new RegExp("~-" + i + "-~"), "{"  + saved[i] + "}", "g");
        }

        return s;
    },


    /**
     * Returns a string without any leading or trailing whitespace.  If
     * the input is not a string, the input will be returned untouched.
     * @method trim
     * @since 2.3.0
     * @param s {string} the string to trim
     * @return {string} the trimmed string
     */
    trim: function(s){
        try {
            return s.replace(/^\s+|\s+$/g, "");
        } catch(e) {
            return s;
        }
    },

    /**
     * Returns a new object containing all of the properties of
     * all the supplied objects.  The properties from later objects
     * will overwrite those in earlier objects.
     * @method merge
     * @since 2.3.0
     * @param arguments {Object*} the objects to merge
     * @return the new merged object
     */
    merge: function() {
        var o={}, a=arguments, l=a.length, i;
        for (i=0; i<l; i=i+1) {
            L.augmentObject(o, a[i], true);
        }
        return o;
    },

    /**
     * Executes the supplied function in the context of the supplied
     * object 'when' milliseconds later.  Executes the function a
     * single time unless periodic is set to true.
     * @method later
     * @since 2.4.0
     * @param when {int} the number of milliseconds to wait until the fn
     * is executed
     * @param o the context object
     * @param fn {Function|String} the function to execute or the name of
     * the method in the 'o' object to execute
     * @param data [Array] data that is provided to the function.  This accepts
     * either a single item or an array.  If an array is provided, the
     * function is executed with one parameter for each array item.  If
     * you need to pass a single array parameter, it needs to be wrapped in
     * an array [myarray]
     * @param periodic {boolean} if true, executes continuously at supplied
     * interval until canceled
     * @return a timer object. Call the cancel() method on this object to
     * stop the timer.
     */
    later: function(when, o, fn, data, periodic) {
        when = when || 0;
        o = o || {};
        var m=fn, d=data, f, r;

        if (L.isString(fn)) {
            m = o[fn];
        }

        if (!m) {
            throw new TypeError("method undefined");
        }

        if (!L.isUndefined(data) && !L.isArray(d)) {
            d = [data];
        }

        f = function() {
            m.apply(o, d || NOTHING);
        };

        r = (periodic) ? setInterval(f, when) : setTimeout(f, when);

        return {
            interval: periodic,
            cancel: function() {
                if (this.interval) {
                    clearInterval(r);
                } else {
                    clearTimeout(r);
                }
            }
        };
    },

    /**
     * A convenience method for detecting a legitimate non-null value.
     * Returns false for null/undefined/NaN, true for other values,
     * including 0/false/''
     * @method isValue
     * @since 2.3.0
     * @param o {any} the item to test
     * @return {boolean} true if it is not null/undefined/NaN || false
     */
    isValue: function(o) {
        // return (o || o === false || o === 0 || o === ''); // Infinity fails
return (L.isObject(o) || L.isString(o) || L.isNumber(o) || L.isBoolean(o));
    }

};

/**
 * Determines whether or not the property was added
 * to the object instance.  Returns false if the property is not present
 * in the object, or was inherited from the prototype.
 * This abstraction is provided to enable hasOwnProperty for Safari 1.3.x.
 * There is a discrepancy between YAHOO.lang.hasOwnProperty and
 * Object.prototype.hasOwnProperty when the property is a primitive added to
 * both the instance AND prototype with the same value:
 * <pre>
 * var A = function() {};
 * A.prototype.foo = 'foo';
 * var a = new A();
 * a.foo = 'foo';
 * alert(a.hasOwnProperty('foo')); // true
 * alert(YAHOO.lang.hasOwnProperty(a, 'foo')); // false when using fallback
 * </pre>
 * @method hasOwnProperty
 * @param {any} o The object being testing
 * @param prop {string} the name of the property to test
 * @return {boolean} the result
 */
L.hasOwnProperty = (OP.hasOwnProperty) ?
    function(o, prop) {
        return o && o.hasOwnProperty && o.hasOwnProperty(prop);
    } : function(o, prop) {
        return !L.isUndefined(o[prop]) &&
                o.constructor.prototype[prop] !== o[prop];
    };

// new lang wins
OB.augmentObject(L, OB, true);

/*
 * An alias for <a href="YAHOO.lang.html">YAHOO.lang</a>
 * @class YAHOO.util.Lang
 */
YAHOO.util.Lang = L;

/**
 * Same as YAHOO.lang.augmentObject, except it only applies prototype
 * properties.  This is an alias for augmentProto.
 * @see YAHOO.lang.augmentObject
 * @method augment
 * @static
 * @param {Function} r  the object to receive the augmentation
 * @param {Function} s  the object that supplies the properties to augment
 * @param {String*|boolean}  arguments zero or more properties methods to
 *        augment the receiver with.  If none specified, everything
 *        in the supplier will be used unless it would
 *        overwrite an existing property in the receiver.  if true
 *        is specified as the third parameter, all properties will
 *        be applied and will overwrite an existing property in
 *        the receiver
 */
L.augment = L.augmentProto;

/**
 * An alias for <a href="YAHOO.lang.html#augment">YAHOO.lang.augment</a>
 * @for YAHOO
 * @method augment
 * @static
 * @param {Function} r  the object to receive the augmentation
 * @param {Function} s  the object that supplies the properties to augment
 * @param {String*}  arguments zero or more properties methods to
 *        augment the receiver with.  If none specified, everything
 *        in the supplier will be used unless it would
 *        overwrite an existing property in the receiver
 */
YAHOO.augment = L.augmentProto;

/**
 * An alias for <a href="YAHOO.lang.html#extend">YAHOO.lang.extend</a>
 * @method extend
 * @static
 * @param {Function} subc   the object to modify
 * @param {Function} superc the object to inherit
 * @param {Object} overrides  additional properties/methods to add to the
 *        subclass prototype.  These will override the
 *        matching items obtained from the superclass if present.
 */
YAHOO.extend = L.extend;

})();
YAHOO.register("yahoo", YAHOO, {version: "2.9.0", build: "2800"});
/*
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
/**
 * The dom module provides helper methods for manipulating Dom elements.
 * @module dom
 *
 */

(function() {
    // for use with generateId (global to save state if Dom is overwritten)
    YAHOO.env._id_counter = YAHOO.env._id_counter || 0;

    // internal shorthand
    var Y = YAHOO.util,
        lang = YAHOO.lang,
        UA = YAHOO.env.ua,
        trim = YAHOO.lang.trim,
        propertyCache = {}, // for faster hyphen converts
        reCache = {}, // cache className regexes
        RE_TABLE = /^t(?:able|d|h)$/i, // for _calcBorders
        RE_COLOR = /color$/i,

        // DOM aliases 
        document = window.document,     
        documentElement = document.documentElement,

        // string constants
        OWNER_DOCUMENT = 'ownerDocument',
        DEFAULT_VIEW = 'defaultView',
        DOCUMENT_ELEMENT = 'documentElement',
        COMPAT_MODE = 'compatMode',
        OFFSET_LEFT = 'offsetLeft',
        OFFSET_TOP = 'offsetTop',
        OFFSET_PARENT = 'offsetParent',
        PARENT_NODE = 'parentNode',
        NODE_TYPE = 'nodeType',
        TAG_NAME = 'tagName',
        SCROLL_LEFT = 'scrollLeft',
        SCROLL_TOP = 'scrollTop',
        GET_BOUNDING_CLIENT_RECT = 'getBoundingClientRect',
        GET_COMPUTED_STYLE = 'getComputedStyle',
        CURRENT_STYLE = 'currentStyle',
        CSS1_COMPAT = 'CSS1Compat',
        _BACK_COMPAT = 'BackCompat',
        _CLASS = 'class', // underscore due to reserved word
        CLASS_NAME = 'className',
        EMPTY = '',
        SPACE = ' ',
        C_START = '(?:^|\\s)',
        C_END = '(?= |$)',
        G = 'g',
        POSITION = 'position',
        FIXED = 'fixed',
        RELATIVE = 'relative',
        LEFT = 'left',
        TOP = 'top',
        MEDIUM = 'medium',
        BORDER_LEFT_WIDTH = 'borderLeftWidth',
        BORDER_TOP_WIDTH = 'borderTopWidth',
    
    // brower detection
        isOpera = UA.opera,
        isSafari = UA.webkit, 
        isGecko = UA.gecko, 
        isIE = UA.ie; 
    
    /**
     * Provides helper methods for DOM elements.
     * @namespace YAHOO.util
     * @class Dom
     * @requires yahoo, event
     */
    Y.Dom = {
        CUSTOM_ATTRIBUTES: (!documentElement.hasAttribute) ? { // IE < 8
            'for': 'htmlFor',
            'class': CLASS_NAME
        } : { // w3c
            'htmlFor': 'for',
            'className': _CLASS
        },

        DOT_ATTRIBUTES: {
            checked: true 
        },

        /**
         * Returns an HTMLElement reference.
         * @method get
         * @param {String | HTMLElement |Array} el Accepts a string to use as an ID for getting a DOM reference, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @return {HTMLElement | Array} A DOM reference to an HTML element or an array of HTMLElements.
         */
        get: function(el) {
            var id, nodes, c, i, len, attr, ret = null;

            if (el) {
                if (typeof el == 'string' || typeof el == 'number') { // id
                    id = el + '';
                    el = document.getElementById(el);
                    attr = (el) ? el.attributes : null;
                    if (el && attr && attr.id && attr.id.value === id) { // IE: avoid false match on "name" attribute
                        return el;
                    } else if (el && document.all) { // filter by name
                        el = null;
                        nodes = document.all[id];
                        if (nodes && nodes.length) {
                            for (i = 0, len = nodes.length; i < len; ++i) {
                                if (nodes[i].id === id) {
                                    return nodes[i];
                                }
                            }
                        }
                    }
                } else if (Y.Element && el instanceof Y.Element) {
                    el = el.get('element');
                } else if (!el.nodeType && 'length' in el) { // array-like 
                    c = [];
                    for (i = 0, len = el.length; i < len; ++i) {
                        c[c.length] = Y.Dom.get(el[i]);
                    }
                    
                    el = c;
                }

                ret = el;
            }

            return ret;
        },
    
        getComputedStyle: function(el, property) {
            if (window[GET_COMPUTED_STYLE]) {
                return el[OWNER_DOCUMENT][DEFAULT_VIEW][GET_COMPUTED_STYLE](el, null)[property];
            } else if (el[CURRENT_STYLE]) {
                return Y.Dom.IE_ComputedStyle.get(el, property);
            }
        },

        /**
         * Normalizes currentStyle and ComputedStyle.
         * @method getStyle
         * @param {String | HTMLElement |Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @param {String} property The style property whose value is returned.
         * @return {String | Array} The current value of the style property for the element(s).
         */
        getStyle: function(el, property) {
            return Y.Dom.batch(el, Y.Dom._getStyle, property);
        },

        // branching at load instead of runtime
        _getStyle: function() {
            if (window[GET_COMPUTED_STYLE]) { // W3C DOM method
                return function(el, property) {
                    property = (property === 'float') ? property = 'cssFloat' :
                            Y.Dom._toCamel(property);

                    var value = el.style[property],
                        computed;
                    
                    if (!value) {
                        computed = el[OWNER_DOCUMENT][DEFAULT_VIEW][GET_COMPUTED_STYLE](el, null);
                        if (computed) { // test computed before touching for safari
                            value = computed[property];
                        }
                    }
                    
                    return value;
                };
            } else if (documentElement[CURRENT_STYLE]) {
                return function(el, property) {                         
                    var value;

                    switch(property) {
                        case 'opacity' :// IE opacity uses filter
                            value = 100;
                            try { // will error if no DXImageTransform
                                value = el.filters['DXImageTransform.Microsoft.Alpha'].opacity;

                            } catch(e) {
                                try { // make sure its in the document
                                    value = el.filters('alpha').opacity;
                                } catch(err) {
                                }
                            }
                            return value / 100;
                        case 'float': // fix reserved word
                            property = 'styleFloat'; // fall through
                        default: 
                            property = Y.Dom._toCamel(property);
                            value = el[CURRENT_STYLE] ? el[CURRENT_STYLE][property] : null;
                            return ( el.style[property] || value );
                    }
                };
            }
        }(),
    
        /**
         * Wrapper for setting style properties of HTMLElements.  Normalizes "opacity" across modern browsers.
         * @method setStyle
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @param {String} property The style property to be set.
         * @param {String} val The value to apply to the given property.
         */
        setStyle: function(el, property, val) {
            Y.Dom.batch(el, Y.Dom._setStyle, { prop: property, val: val });
        },

        _setStyle: function() {
            if (!window.getComputedStyle && document.documentElement.currentStyle) {
                return function(el, args) {
                    var property = Y.Dom._toCamel(args.prop),
                        val = args.val;

                    if (el) {
                        switch (property) {
                            case 'opacity':
                                // remove filter if unsetting or full opacity
                                if (val === '' || val === null || val === 1) {
                                    el.style.removeAttribute('filter');
                                } else if ( lang.isString(el.style.filter) ) { // in case not appended
                                    el.style.filter = 'alpha(opacity=' + val * 100 + ')';
                                    
                                    if (!el[CURRENT_STYLE] || !el[CURRENT_STYLE].hasLayout) {
                                        el.style.zoom = 1; // when no layout or cant tell
                                    }
                                }
                                break;
                            case 'float':
                                property = 'styleFloat';
                            default:
                            el.style[property] = val;
                        }
                    } else {
                    }
                };
            } else {
                return function(el, args) {
                    var property = Y.Dom._toCamel(args.prop),
                        val = args.val;
                    if (el) {
                        if (property == 'float') {
                            property = 'cssFloat';
                        }
                        el.style[property] = val;
                    } else {
                    }
                };
            }

        }(),
        
        /**
         * Gets the current position of an element based on page coordinates. 
         * Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method getXY
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM
         * reference, or an Array of IDs and/or HTMLElements
         * @return {Array} The XY position of the element(s)
         */
        getXY: function(el) {
            return Y.Dom.batch(el, Y.Dom._getXY);
        },

        _canPosition: function(el) {
            return ( Y.Dom._getStyle(el, 'display') !== 'none' && Y.Dom._inDoc(el) );
        },

        _getXY: function(node) {
            var scrollLeft, scrollTop, box, doc,
                clientTop, clientLeft,
                round = Math.round, // TODO: round?
                xy = false;

            if (Y.Dom._canPosition(node)) {
                box = node[GET_BOUNDING_CLIENT_RECT]();
                doc = node[OWNER_DOCUMENT];
                scrollLeft = Y.Dom.getDocumentScrollLeft(doc);
                scrollTop = Y.Dom.getDocumentScrollTop(doc);
                xy = [box[LEFT], box[TOP]];

                // remove IE default documentElement offset (border)
                if (clientTop || clientLeft) {
                    xy[0] -= clientLeft;
                    xy[1] -= clientTop;
                }

                if ((scrollTop || scrollLeft)) {
                    xy[0] += scrollLeft;
                    xy[1] += scrollTop;
                }

                // gecko may return sub-pixel (non-int) values
                xy[0] = round(xy[0]);
                xy[1] = round(xy[1]);
            } else {
            }

            return xy;
        },
        
        /**
         * Gets the current X position of an element based on page coordinates.  The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method getX
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
         * @return {Number | Array} The X position of the element(s)
         */
        getX: function(el) {
            var f = function(el) {
                return Y.Dom.getXY(el)[0];
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        /**
         * Gets the current Y position of an element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method getY
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
         * @return {Number | Array} The Y position of the element(s)
         */
        getY: function(el) {
            var f = function(el) {
                return Y.Dom.getXY(el)[1];
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        /**
         * Set the position of an html element in page coordinates, regardless of how the element is positioned.
         * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method setXY
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
         * @param {Array} pos Contains X & Y values for new position (coordinates are page-based)
         * @param {Boolean} noRetry By default we try and set the position a second time if the first fails
         */
        setXY: function(el, pos, noRetry) {
            Y.Dom.batch(el, Y.Dom._setXY, { pos: pos, noRetry: noRetry });
        },

        _setXY: function(node, args) {
            var pos = Y.Dom._getStyle(node, POSITION),
                setStyle = Y.Dom.setStyle,
                xy = args.pos,
                noRetry = args.noRetry,

                delta = [ // assuming pixels; if not we will have to retry
                    parseInt( Y.Dom.getComputedStyle(node, LEFT), 10 ),
                    parseInt( Y.Dom.getComputedStyle(node, TOP), 10 )
                ],

                currentXY,
                newXY;
        
            currentXY = Y.Dom._getXY(node);

            if (!xy || currentXY === false) { // has to be part of doc to have xy
                return false; 
            }
            
            if (pos == 'static') { // default to relative
                pos = RELATIVE;
                setStyle(node, POSITION, pos);
            }

            if ( isNaN(delta[0]) ) {// in case of 'auto'
                delta[0] = (pos == RELATIVE) ? 0 : node[OFFSET_LEFT];
            } 
            if ( isNaN(delta[1]) ) { // in case of 'auto'
                delta[1] = (pos == RELATIVE) ? 0 : node[OFFSET_TOP];
            } 

            if (xy[0] !== null) { // from setX
                setStyle(node, LEFT, xy[0] - currentXY[0] + delta[0] + 'px');
            }

            if (xy[1] !== null) { // from setY
                setStyle(node, TOP, xy[1] - currentXY[1] + delta[1] + 'px');
            }
          
            if (!noRetry) {
                newXY = Y.Dom._getXY(node);

                // if retry is true, try one more time if we miss 
               if ( (xy[0] !== null && newXY[0] != xy[0]) || 
                    (xy[1] !== null && newXY[1] != xy[1]) ) {
                   Y.Dom._setXY(node, { pos: xy, noRetry: true });
               }
            }        

        },
        
        /**
         * Set the X position of an html element in page coordinates, regardless of how the element is positioned.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method setX
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @param {Int} x The value to use as the X coordinate for the element(s).
         */
        setX: function(el, x) {
            Y.Dom.setXY(el, [x, null]);
        },
        
        /**
         * Set the Y position of an html element in page coordinates, regardless of how the element is positioned.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method setY
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @param {Int} x To use as the Y coordinate for the element(s).
         */
        setY: function(el, y) {
            Y.Dom.setXY(el, [null, y]);
        },
        
        /**
         * Returns the region position of the given element.
         * The element must be part of the DOM tree to have a region (display:none or elements not appended return false).
         * @method getRegion
         * @param {String | HTMLElement | Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
         * @return {Region | Array} A Region or array of Region instances containing "top, left, bottom, right" member data.
         */
        getRegion: function(el) {
            var f = function(el) {
                var region = false;
                if ( Y.Dom._canPosition(el) ) {
                    region = Y.Region.getRegion(el);
                } else {
                }

                return region;
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        /**
         * Returns the width of the client (viewport).
         * @method getClientWidth
         * @deprecated Now using getViewportWidth.  This interface left intact for back compat.
         * @return {Int} The width of the viewable area of the page.
         */
        getClientWidth: function() {
            return Y.Dom.getViewportWidth();
        },
        
        /**
         * Returns the height of the client (viewport).
         * @method getClientHeight
         * @deprecated Now using getViewportHeight.  This interface left intact for back compat.
         * @return {Int} The height of the viewable area of the page.
         */
        getClientHeight: function() {
            return Y.Dom.getViewportHeight();
        },

        /**
         * Returns an array of HTMLElements with the given class.
         * For optimized performance, include a tag and/or root node when possible.
         * Note: This method operates against a live collection, so modifying the 
         * collection in the callback (removing/appending nodes, etc.) will have
         * side effects.  Instead you should iterate the returned nodes array,
         * as you would with the native "getElementsByTagName" method. 
         * @method getElementsByClassName
         * @param {String} className The class name to match against
         * @param {String} tag (optional) The tag name of the elements being collected
         * @param {String | HTMLElement} root (optional) The HTMLElement or an ID to use as the starting point.
         * This element is not included in the className scan.
         * @param {Function} apply (optional) A function to apply to each element when found 
         * @param {Any} o (optional) An optional arg that is passed to the supplied method
         * @param {Boolean} overrides (optional) Whether or not to override the scope of "method" with "o"
         * @return {Array} An array of elements that have the given class name
         */
        getElementsByClassName: function(className, tag, root, apply, o, overrides) {
            tag = tag || '*';
            root = (root) ? Y.Dom.get(root) : null || document; 
            if (!root) {
                return [];
            }

            var nodes = [],
                elements = root.getElementsByTagName(tag),
                hasClass = Y.Dom.hasClass;

            for (var i = 0, len = elements.length; i < len; ++i) {
                if ( hasClass(elements[i], className) ) {
                    nodes[nodes.length] = elements[i];
                }
            }
            
            if (apply) {
                Y.Dom.batch(nodes, apply, o, overrides);
            }

            return nodes;
        },

        /**
         * Determines whether an HTMLElement has the given className.
         * @method hasClass
         * @param {String | HTMLElement | Array} el The element or collection to test
         * @param {String | RegExp} className the class name to search for, or a regular
         * expression to match against
         * @return {Boolean | Array} A boolean value or array of boolean values
         */
        hasClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._hasClass, className);
        },

        _hasClass: function(el, className) {
            var ret = false,
                current;
            
            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                if (current) { // convert line breaks, tabs and other delims to spaces
                    current = current.replace(/\s+/g, SPACE);
                }

                if (className.exec) {
                    ret = className.test(current);
                } else {
                    ret = className && (SPACE + current + SPACE).
                        indexOf(SPACE + className + SPACE) > -1;
                }
            } else {
            }

            return ret;
        },
    
        /**
         * Adds a class name to a given element or collection of elements.
         * @method addClass         
         * @param {String | HTMLElement | Array} el The element or collection to add the class to
         * @param {String} className the class name to add to the class attribute
         * @return {Boolean | Array} A pass/fail boolean or array of booleans
         */
        addClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._addClass, className);
        },

        _addClass: function(el, className) {
            var ret = false,
                current;

            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                if ( !Y.Dom._hasClass(el, className) ) {
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(current + SPACE + className));
                    ret = true;
                }
            } else {
            }

            return ret;
        },
    
        /**
         * Removes a class name from a given element or collection of elements.
         * @method removeClass         
         * @param {String | HTMLElement | Array} el The element or collection to remove the class from
         * @param {String} className the class name to remove from the class attribute
         * @return {Boolean | Array} A pass/fail boolean or array of booleans
         */
        removeClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._removeClass, className);
        },
        
        _removeClass: function(el, className) {
            var ret = false,
                current,
                newClass,
                attr;

            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                Y.Dom.setAttribute(el, CLASS_NAME, current.replace(Y.Dom._getClassRegex(className), EMPTY));

                newClass = Y.Dom._getAttribute(el, CLASS_NAME);
                if (current !== newClass) { // else nothing changed
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(newClass)); // trim after comparing to current class
                    ret = true;

                    if (Y.Dom._getAttribute(el, CLASS_NAME) === '') { // remove class attribute if empty
                        attr = (el.hasAttribute && el.hasAttribute(_CLASS)) ? _CLASS : CLASS_NAME;
                        el.removeAttribute(attr);
                    }
                }

            } else {
            }

            return ret;
        },
        
        /**
         * Replace a class with another class for a given element or collection of elements.
         * If no oldClassName is present, the newClassName is simply added.
         * @method replaceClass  
         * @param {String | HTMLElement | Array} el The element or collection to remove the class from
         * @param {String} oldClassName the class name to be replaced
         * @param {String} newClassName the class name that will be replacing the old class name
         * @return {Boolean | Array} A pass/fail boolean or array of booleans
         */
        replaceClass: function(el, oldClassName, newClassName) {
            return Y.Dom.batch(el, Y.Dom._replaceClass, { from: oldClassName, to: newClassName });
        },

        _replaceClass: function(el, classObj) {
            var className,
                from,
                to,
                ret = false,
                current;

            if (el && classObj) {
                from = classObj.from;
                to = classObj.to;

                if (!to) {
                    ret = false;
                }  else if (!from) { // just add if no "from"
                    ret = Y.Dom._addClass(el, classObj.to);
                } else if (from !== to) { // else nothing to replace
                    // May need to lead with DBLSPACE?
                    current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                    className = (SPACE + current.replace(Y.Dom._getClassRegex(from), SPACE + to).
                            replace(/\s+/g, SPACE)). // normalize white space
                            split(Y.Dom._getClassRegex(to));

                    // insert to into what would have been the first occurrence slot
                    className.splice(1, 0, SPACE + to);
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(className.join(EMPTY)));
                    ret = true;
                }
            } else {
            }

            return ret;
        },
        
        /**
         * Returns an ID and applies it to the element "el", if provided.
         * @method generateId  
         * @param {String | HTMLElement | Array} el (optional) An optional element array of elements to add an ID to (no ID is added if one is already present).
         * @param {String} prefix (optional) an optional prefix to use (defaults to "yui-gen").
         * @return {String | Array} The generated ID, or array of generated IDs (or original ID if already present on an element)
         */
        generateId: function(el, prefix) {
            prefix = prefix || 'yui-gen';

            var f = function(el) {
                if (el && el.id) { // do not override existing ID
                    return el.id;
                }

                var id = prefix + YAHOO.env._id_counter++;

                if (el) {
                    if (el[OWNER_DOCUMENT] && el[OWNER_DOCUMENT].getElementById(id)) { // in case one already exists
                        // use failed id plus prefix to help ensure uniqueness
                        return Y.Dom.generateId(el, id + prefix);
                    }
                    el.id = id;
                }
                
                return id;
            };

            // batch fails when no element, so just generate and return single ID
            return Y.Dom.batch(el, f, Y.Dom, true) || f.apply(Y.Dom, arguments);
        },
        
        /**
         * Determines whether an HTMLElement is an ancestor of another HTML element in the DOM hierarchy.
         * @method isAncestor
         * @param {String | HTMLElement} haystack The possible ancestor
         * @param {String | HTMLElement} needle The possible descendent
         * @return {Boolean} Whether or not the haystack is an ancestor of needle
         */
        isAncestor: function(haystack, needle) {
            haystack = Y.Dom.get(haystack);
            needle = Y.Dom.get(needle);
            
            var ret = false;

            if ( (haystack && needle) && (haystack[NODE_TYPE] && needle[NODE_TYPE]) ) {
                if (haystack.contains && haystack !== needle) { // contains returns true when equal
                    ret = haystack.contains(needle);
                }
                else if (haystack.compareDocumentPosition) { // gecko
                    ret = !!(haystack.compareDocumentPosition(needle) & 16);
                }
            } else {
            }
            return ret;
        },
        
        /**
         * Determines whether an HTMLElement is present in the current document.
         * @method inDocument         
         * @param {String | HTMLElement} el The element to search for
         * @param {Object} doc An optional document to search, defaults to element's owner document 
         * @return {Boolean} Whether or not the element is present in the current document
         */
        inDocument: function(el, doc) {
            return Y.Dom._inDoc(Y.Dom.get(el), doc);
        },

        _inDoc: function(el, doc) {
            var ret = false;
            if (el && el[TAG_NAME]) {
                doc = doc || el[OWNER_DOCUMENT]; 
                ret = Y.Dom.isAncestor(doc[DOCUMENT_ELEMENT], el);
            } else {
            }
            return ret;
        },
        
        /**
         * Returns an array of HTMLElements that pass the test applied by supplied boolean method.
         * For optimized performance, include a tag and/or root node when possible.
         * Note: This method operates against a live collection, so modifying the 
         * collection in the callback (removing/appending nodes, etc.) will have
         * side effects.  Instead you should iterate the returned nodes array,
         * as you would with the native "getElementsByTagName" method. 
         * @method getElementsBy
         * @param {Function} method - A boolean method for testing elements which receives the element as its only argument.
         * @param {String} tag (optional) The tag name of the elements being collected
         * @param {String | HTMLElement} root (optional) The HTMLElement or an ID to use as the starting point 
         * @param {Function} apply (optional) A function to apply to each element when found 
         * @param {Any} o (optional) An optional arg that is passed to the supplied method
         * @param {Boolean} overrides (optional) Whether or not to override the scope of "method" with "o"
         * @return {Array} Array of HTMLElements
         */
        getElementsBy: function(method, tag, root, apply, o, overrides, firstOnly) {
            tag = tag || '*';
            root = (root) ? Y.Dom.get(root) : null || document; 

                var ret = (firstOnly) ? null : [],
                    elements;
            
            // in case Dom.get() returns null
            if (root) {
                elements = root.getElementsByTagName(tag);
                for (var i = 0, len = elements.length; i < len; ++i) {
                    if ( method(elements[i]) ) {
                        if (firstOnly) {
                            ret = elements[i]; 
                            break;
                        } else {
                            ret[ret.length] = elements[i];
                        }
                    }
                }

                if (apply) {
                    Y.Dom.batch(ret, apply, o, overrides);
                }
            }

            
            return ret;
        },
        
        /**
         * Returns the first HTMLElement that passes the test applied by the supplied boolean method.
         * @method getElementBy
         * @param {Function} method - A boolean method for testing elements which receives the element as its only argument.
         * @param {String} tag (optional) The tag name of the elements being collected
         * @param {String | HTMLElement} root (optional) The HTMLElement or an ID to use as the starting point 
         * @return {HTMLElement}
         */
        getElementBy: function(method, tag, root) {
            return Y.Dom.getElementsBy(method, tag, root, null, null, null, true); 
        },

        /**
         * Runs the supplied method against each item in the Collection/Array.
         * The method is called with the element(s) as the first arg, and the optional param as the second ( method(el, o) ).
         * @method batch
         * @param {String | HTMLElement | Array} el (optional) An element or array of elements to apply the method to
         * @param {Function} method The method to apply to the element(s)
         * @param {Any} o (optional) An optional arg that is passed to the supplied method
         * @param {Boolean} overrides (optional) Whether or not to override the scope of "method" with "o"
         * @return {Any | Array} The return value(s) from the supplied method
         */
        batch: function(el, method, o, overrides) {
            var collection = [],
                scope = (overrides) ? o : null;
                
            el = (el && (el[TAG_NAME] || el.item)) ? el : Y.Dom.get(el); // skip get() when possible
            if (el && method) {
                if (el[TAG_NAME] || el.length === undefined) { // element or not array-like 
                    return method.call(scope, el, o);
                } 

                for (var i = 0; i < el.length; ++i) {
                    collection[collection.length] = method.call(scope || el[i], el[i], o);
                }
            } else {
                return false;
            } 
            return collection;
        },
        
        /**
         * Returns the height of the document.
         * @method getDocumentHeight
         * @return {Int} The height of the actual document (which includes the body and its margin).
         */
        getDocumentHeight: function() {
            var scrollHeight = (document[COMPAT_MODE] != CSS1_COMPAT || isSafari) ? document.body.scrollHeight : documentElement.scrollHeight,
                h = Math.max(scrollHeight, Y.Dom.getViewportHeight());

            return h;
        },
        
        /**
         * Returns the width of the document.
         * @method getDocumentWidth
         * @return {Int} The width of the actual document (which includes the body and its margin).
         */
        getDocumentWidth: function() {
            var scrollWidth = (document[COMPAT_MODE] != CSS1_COMPAT || isSafari) ? document.body.scrollWidth : documentElement.scrollWidth,
                w = Math.max(scrollWidth, Y.Dom.getViewportWidth());
            return w;
        },

        /**
         * Returns the current height of the viewport.
         * @method getViewportHeight
         * @return {Int} The height of the viewable area of the page (excludes scrollbars).
         */
        getViewportHeight: function() {
            var height = self.innerHeight, // Safari, Opera
                mode = document[COMPAT_MODE];
        
            if ( (mode || isIE) && !isOpera ) { // IE, Gecko
                height = (mode == CSS1_COMPAT) ?
                        documentElement.clientHeight : // Standards
                        document.body.clientHeight; // Quirks
            }
        
            return height;
        },
        
        /**
         * Returns the current width of the viewport.
         * @method getViewportWidth
         * @return {Int} The width of the viewable area of the page (excludes scrollbars).
         */
        
        getViewportWidth: function() {
            var width = self.innerWidth,  // Safari
                mode = document[COMPAT_MODE];
            
            if (mode || isIE) { // IE, Gecko, Opera
                width = (mode == CSS1_COMPAT) ?
                        documentElement.clientWidth : // Standards
                        document.body.clientWidth; // Quirks
            }
            return width;
        },

       /**
         * Returns the nearest ancestor that passes the test applied by supplied boolean method.
         * For performance reasons, IDs are not accepted and argument validation omitted.
         * @method getAncestorBy
         * @param {HTMLElement} node The HTMLElement to use as the starting point 
         * @param {Function} method - A boolean method for testing elements which receives the element as its only argument.
         * @return {Object} HTMLElement or null if not found
         */
        getAncestorBy: function(node, method) {
            while ( (node = node[PARENT_NODE]) ) { // NOTE: assignment
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            } 

            return null;
        },
        
        /**
         * Returns the nearest ancestor with the given className.
         * @method getAncestorByClassName
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @param {String} className
         * @return {Object} HTMLElement
         */
        getAncestorByClassName: function(node, className) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            var method = function(el) { return Y.Dom.hasClass(el, className); };
            return Y.Dom.getAncestorBy(node, method);
        },

        /**
         * Returns the nearest ancestor with the given tagName.
         * @method getAncestorByTagName
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @param {String} tagName
         * @return {Object} HTMLElement
         */
        getAncestorByTagName: function(node, tagName) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            var method = function(el) {
                 return el[TAG_NAME] && el[TAG_NAME].toUpperCase() == tagName.toUpperCase();
            };

            return Y.Dom.getAncestorBy(node, method);
        },

        /**
         * Returns the previous sibling that is an HTMLElement. 
         * For performance reasons, IDs are not accepted and argument validation omitted.
         * Returns the nearest HTMLElement sibling if no method provided.
         * @method getPreviousSiblingBy
         * @param {HTMLElement} node The HTMLElement to use as the starting point 
         * @param {Function} method A boolean function used to test siblings
         * that receives the sibling node being tested as its only argument
         * @return {Object} HTMLElement or null if not found
         */
        getPreviousSiblingBy: function(node, method) {
            while (node) {
                node = node.previousSibling;
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            }
            return null;
        }, 

        /**
         * Returns the previous sibling that is an HTMLElement 
         * @method getPreviousSibling
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @return {Object} HTMLElement or null if not found
         */
        getPreviousSibling: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }

            return Y.Dom.getPreviousSiblingBy(node);
        }, 

        /**
         * Returns the next HTMLElement sibling that passes the boolean method. 
         * For performance reasons, IDs are not accepted and argument validation omitted.
         * Returns the nearest HTMLElement sibling if no method provided.
         * @method getNextSiblingBy
         * @param {HTMLElement} node The HTMLElement to use as the starting point 
         * @param {Function} method A boolean function used to test siblings
         * that receives the sibling node being tested as its only argument
         * @return {Object} HTMLElement or null if not found
         */
        getNextSiblingBy: function(node, method) {
            while (node) {
                node = node.nextSibling;
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            }
            return null;
        }, 

        /**
         * Returns the next sibling that is an HTMLElement 
         * @method getNextSibling
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @return {Object} HTMLElement or null if not found
         */
        getNextSibling: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }

            return Y.Dom.getNextSiblingBy(node);
        }, 

        /**
         * Returns the first HTMLElement child that passes the test method. 
         * @method getFirstChildBy
         * @param {HTMLElement} node The HTMLElement to use as the starting point 
         * @param {Function} method A boolean function used to test children
         * that receives the node being tested as its only argument
         * @return {Object} HTMLElement or null if not found
         */
        getFirstChildBy: function(node, method) {
            var child = ( Y.Dom._testElement(node.firstChild, method) ) ? node.firstChild : null;
            return child || Y.Dom.getNextSiblingBy(node.firstChild, method);
        }, 

        /**
         * Returns the first HTMLElement child. 
         * @method getFirstChild
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @return {Object} HTMLElement or null if not found
         */
        getFirstChild: function(node, method) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            return Y.Dom.getFirstChildBy(node);
        }, 

        /**
         * Returns the last HTMLElement child that passes the test method. 
         * @method getLastChildBy
         * @param {HTMLElement} node The HTMLElement to use as the starting point 
         * @param {Function} method A boolean function used to test children
         * that receives the node being tested as its only argument
         * @return {Object} HTMLElement or null if not found
         */
        getLastChildBy: function(node, method) {
            if (!node) {
                return null;
            }
            var child = ( Y.Dom._testElement(node.lastChild, method) ) ? node.lastChild : null;
            return child || Y.Dom.getPreviousSiblingBy(node.lastChild, method);
        }, 

        /**
         * Returns the last HTMLElement child. 
         * @method getLastChild
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @return {Object} HTMLElement or null if not found
         */
        getLastChild: function(node) {
            node = Y.Dom.get(node);
            return Y.Dom.getLastChildBy(node);
        }, 

        /**
         * Returns an array of HTMLElement childNodes that pass the test method. 
         * @method getChildrenBy
         * @param {HTMLElement} node The HTMLElement to start from
         * @param {Function} method A boolean function used to test children
         * that receives the node being tested as its only argument
         * @return {Array} A static array of HTMLElements
         */
        getChildrenBy: function(node, method) {
            var child = Y.Dom.getFirstChildBy(node, method),
                children = child ? [child] : [];

            Y.Dom.getNextSiblingBy(child, function(node) {
                if ( !method || method(node) ) {
                    children[children.length] = node;
                }
                return false; // fail test to collect all children
            });

            return children;
        },
 
        /**
         * Returns an array of HTMLElement childNodes. 
         * @method getChildren
         * @param {String | HTMLElement} node The HTMLElement or an ID to use as the starting point 
         * @return {Array} A static array of HTMLElements
         */
        getChildren: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
            }

            return Y.Dom.getChildrenBy(node);
        },

        /**
         * Returns the left scroll value of the document 
         * @method getDocumentScrollLeft
         * @param {HTMLDocument} document (optional) The document to get the scroll value of
         * @return {Int}  The amount that the document is scrolled to the left
         */
        getDocumentScrollLeft: function(doc) {
            doc = doc || document;
            return Math.max(doc[DOCUMENT_ELEMENT].scrollLeft, doc.body.scrollLeft);
        }, 

        /**
         * Returns the top scroll value of the document 
         * @method getDocumentScrollTop
         * @param {HTMLDocument} document (optional) The document to get the scroll value of
         * @return {Int}  The amount that the document is scrolled to the top
         */
        getDocumentScrollTop: function(doc) {
            doc = doc || document;
            return Math.max(doc[DOCUMENT_ELEMENT].scrollTop, doc.body.scrollTop);
        },

        /**
         * Inserts the new node as the previous sibling of the reference node 
         * @method insertBefore
         * @param {String | HTMLElement} newNode The node to be inserted
         * @param {String | HTMLElement} referenceNode The node to insert the new node before 
         * @return {HTMLElement} The node that was inserted (or null if insert fails) 
         */
        insertBefore: function(newNode, referenceNode) {
            newNode = Y.Dom.get(newNode); 
            referenceNode = Y.Dom.get(referenceNode); 
            
            if (!newNode || !referenceNode || !referenceNode[PARENT_NODE]) {
                return null;
            }       

            return referenceNode[PARENT_NODE].insertBefore(newNode, referenceNode); 
        },

        /**
         * Inserts the new node as the next sibling of the reference node 
         * @method insertAfter
         * @param {String | HTMLElement} newNode The node to be inserted
         * @param {String | HTMLElement} referenceNode The node to insert the new node after 
         * @return {HTMLElement} The node that was inserted (or null if insert fails) 
         */
        insertAfter: function(newNode, referenceNode) {
            newNode = Y.Dom.get(newNode); 
            referenceNode = Y.Dom.get(referenceNode); 
            
            if (!newNode || !referenceNode || !referenceNode[PARENT_NODE]) {
                return null;
            }       

            if (referenceNode.nextSibling) {
                return referenceNode[PARENT_NODE].insertBefore(newNode, referenceNode.nextSibling); 
            } else {
                return referenceNode[PARENT_NODE].appendChild(newNode);
            }
        },

        /**
         * Creates a Region based on the viewport relative to the document. 
         * @method getClientRegion
         * @return {Region} A Region object representing the viewport which accounts for document scroll
         */
        getClientRegion: function() {
            var t = Y.Dom.getDocumentScrollTop(),
                l = Y.Dom.getDocumentScrollLeft(),
                r = Y.Dom.getViewportWidth() + l,
                b = Y.Dom.getViewportHeight() + t;

            return new Y.Region(t, r, b, l);
        },

        /**
         * Provides a normalized attribute interface. 
         * @method setAttribute
         * @param {String | HTMLElement} el The target element for the attribute.
         * @param {String} attr The attribute to set.
         * @param {String} val The value of the attribute.
         */
        setAttribute: function(el, attr, val) {
            Y.Dom.batch(el, Y.Dom._setAttribute, { attr: attr, val: val });
        },

        _setAttribute: function(el, args) {
            var attr = Y.Dom._toCamel(args.attr),
                val = args.val;

            if (el && el.setAttribute) {
                // set as DOM property, except for BUTTON, which errors on property setter
                if (Y.Dom.DOT_ATTRIBUTES[attr] && el.tagName && el.tagName != 'BUTTON') {
                    el[attr] = val;
                } else {
                    attr = Y.Dom.CUSTOM_ATTRIBUTES[attr] || attr;
                    el.setAttribute(attr, val);
                }
            } else {
            }
        },

        /**
         * Provides a normalized attribute interface. 
         * @method getAttribute
         * @param {String | HTMLElement} el The target element for the attribute.
         * @param {String} attr The attribute to get.
         * @return {String} The current value of the attribute. 
         */
        getAttribute: function(el, attr) {
            return Y.Dom.batch(el, Y.Dom._getAttribute, attr);
        },


        _getAttribute: function(el, attr) {
            var val;
            attr = Y.Dom.CUSTOM_ATTRIBUTES[attr] || attr;

            if (Y.Dom.DOT_ATTRIBUTES[attr]) {
                val = el[attr];
            } else if (el && 'getAttribute' in el) {
                if (/^(?:href|src)$/.test(attr)) { // use IE flag to return exact value
                    val = el.getAttribute(attr, 2);
                } else {
                    val = el.getAttribute(attr);
                }
            } else {
            }

            return val;
        },

        _toCamel: function(property) {
            var c = propertyCache;

            function tU(x,l) {
                return l.toUpperCase();
            }

            return c[property] || (c[property] = property.indexOf('-') === -1 ? 
                                    property :
                                    property.replace( /-([a-z])/gi, tU ));
        },

        _getClassRegex: function(className) {
            var re;
            if (className !== undefined) { // allow empty string to pass
                if (className.exec) { // already a RegExp
                    re = className;
                } else {
                    re = reCache[className];
                    if (!re) {
                        // escape special chars (".", "[", etc.)
                        className = className.replace(Y.Dom._patterns.CLASS_RE_TOKENS, '\\$1');
                        className = className.replace(/\s+/g, SPACE); // convert line breaks and other delims
                        re = reCache[className] = new RegExp(C_START + className + C_END, G);
                    }
                }
            }
            return re;
        },

        _patterns: {
            ROOT_TAG: /^body|html$/i, // body for quirks mode, html for standards,
            CLASS_RE_TOKENS: /([\.\(\)\^\$\*\+\?\|\[\]\{\}\\])/g
        },


        _testElement: function(node, method) {
            return node && node[NODE_TYPE] == 1 && ( !method || method(node) );
        },

        _calcBorders: function(node, xy2) {
            var t = parseInt(Y.Dom[GET_COMPUTED_STYLE](node, BORDER_TOP_WIDTH), 10) || 0,
                l = parseInt(Y.Dom[GET_COMPUTED_STYLE](node, BORDER_LEFT_WIDTH), 10) || 0;
            if (isGecko) {
                if (RE_TABLE.test(node[TAG_NAME])) {
                    t = 0;
                    l = 0;
                }
            }
            xy2[0] += l;
            xy2[1] += t;
            return xy2;
        }
    };
        
    var _getComputedStyle = Y.Dom[GET_COMPUTED_STYLE];
    // fix opera computedStyle default color unit (convert to rgb)
    if (UA.opera) {
        Y.Dom[GET_COMPUTED_STYLE] = function(node, att) {
            var val = _getComputedStyle(node, att);
            if (RE_COLOR.test(att)) {
                val = Y.Dom.Color.toRGB(val);
            }

            return val;
        };

    }

    // safari converts transparent to rgba(), others use "transparent"
    if (UA.webkit) {
        Y.Dom[GET_COMPUTED_STYLE] = function(node, att) {
            var val = _getComputedStyle(node, att);

            if (val === 'rgba(0, 0, 0, 0)') {
                val = 'transparent'; 
            }

            return val;
        };

    }

    if (UA.ie && UA.ie >= 8) {
        Y.Dom.DOT_ATTRIBUTES.type = true; // IE 8 errors on input.setAttribute('type')
    }
})();
/**
 * A region is a representation of an object on a grid.  It is defined
 * by the top, right, bottom, left extents, so is rectangular by default.  If 
 * other shapes are required, this class could be extended to support it.
 * @namespace YAHOO.util
 * @class Region
 * @param {Int} t the top extent
 * @param {Int} r the right extent
 * @param {Int} b the bottom extent
 * @param {Int} l the left extent
 * @constructor
 */
YAHOO.util.Region = function(t, r, b, l) {

    /**
     * The region's top extent
     * @property top
     * @type Int
     */
    this.top = t;
    
    /**
     * The region's top extent
     * @property y
     * @type Int
     */
    this.y = t;
    
    /**
     * The region's top extent as index, for symmetry with set/getXY
     * @property 1
     * @type Int
     */
    this[1] = t;

    /**
     * The region's right extent
     * @property right
     * @type int
     */
    this.right = r;

    /**
     * The region's bottom extent
     * @property bottom
     * @type Int
     */
    this.bottom = b;

    /**
     * The region's left extent
     * @property left
     * @type Int
     */
    this.left = l;
    
    /**
     * The region's left extent
     * @property x
     * @type Int
     */
    this.x = l;
    
    /**
     * The region's left extent as index, for symmetry with set/getXY
     * @property 0
     * @type Int
     */
    this[0] = l;

    /**
     * The region's total width 
     * @property width 
     * @type Int
     */
    this.width = this.right - this.left;

    /**
     * The region's total height 
     * @property height 
     * @type Int
     */
    this.height = this.bottom - this.top;
};

/**
 * Returns true if this region contains the region passed in
 * @method contains
 * @param  {Region}  region The region to evaluate
 * @return {Boolean}        True if the region is contained with this region, 
 *                          else false
 */
YAHOO.util.Region.prototype.contains = function(region) {
    return ( region.left   >= this.left   && 
             region.right  <= this.right  && 
             region.top    >= this.top    && 
             region.bottom <= this.bottom    );

};

/**
 * Returns the area of the region
 * @method getArea
 * @return {Int} the region's area
 */
YAHOO.util.Region.prototype.getArea = function() {
    return ( (this.bottom - this.top) * (this.right - this.left) );
};

/**
 * Returns the region where the passed in region overlaps with this one
 * @method intersect
 * @param  {Region} region The region that intersects
 * @return {Region}        The overlap region, or null if there is no overlap
 */
YAHOO.util.Region.prototype.intersect = function(region) {
    var t = Math.max( this.top,    region.top    ),
        r = Math.min( this.right,  region.right  ),
        b = Math.min( this.bottom, region.bottom ),
        l = Math.max( this.left,   region.left   );
    
    if (b >= t && r >= l) {
        return new YAHOO.util.Region(t, r, b, l);
    } else {
        return null;
    }
};

/**
 * Returns the region representing the smallest region that can contain both
 * the passed in region and this region.
 * @method union
 * @param  {Region} region The region that to create the union with
 * @return {Region}        The union region
 */
YAHOO.util.Region.prototype.union = function(region) {
    var t = Math.min( this.top,    region.top    ),
        r = Math.max( this.right,  region.right  ),
        b = Math.max( this.bottom, region.bottom ),
        l = Math.min( this.left,   region.left   );

    return new YAHOO.util.Region(t, r, b, l);
};

/**
 * toString
 * @method toString
 * @return string the region properties
 */
YAHOO.util.Region.prototype.toString = function() {
    return ( "Region {"    +
             "top: "       + this.top    + 
             ", right: "   + this.right  + 
             ", bottom: "  + this.bottom + 
             ", left: "    + this.left   + 
             ", height: "  + this.height + 
             ", width: "    + this.width   + 
             "}" );
};

/**
 * Returns a region that is occupied by the DOM element
 * @method getRegion
 * @param  {HTMLElement} el The element
 * @return {Region}         The region that the element occupies
 * @static
 */
YAHOO.util.Region.getRegion = function(el) {
    var p = YAHOO.util.Dom.getXY(el),
        t = p[1],
        r = p[0] + el.offsetWidth,
        b = p[1] + el.offsetHeight,
        l = p[0];

    return new YAHOO.util.Region(t, r, b, l);
};

/////////////////////////////////////////////////////////////////////////////


/**
 * A point is a region that is special in that it represents a single point on 
 * the grid.
 * @namespace YAHOO.util
 * @class Point
 * @param {Int} x The X position of the point
 * @param {Int} y The Y position of the point
 * @constructor
 * @extends YAHOO.util.Region
 */
YAHOO.util.Point = function(x, y) {
   if (YAHOO.lang.isArray(x)) { // accept input from Dom.getXY, Event.getXY, etc.
      y = x[1]; // dont blow away x yet
      x = x[0];
   }
 
    YAHOO.util.Point.superclass.constructor.call(this, y, x, y, x);
};

YAHOO.extend(YAHOO.util.Point, YAHOO.util.Region);

(function() {
/**
 * Internal methods used to add style management functionality to DOM.
 * @module dom
 * @class IEStyle
 * @namespace YAHOO.util.Dom
 */

var Y = YAHOO.util, 
    CLIENT_TOP = 'clientTop',
    CLIENT_LEFT = 'clientLeft',
    PARENT_NODE = 'parentNode',
    RIGHT = 'right',
    HAS_LAYOUT = 'hasLayout',
    PX = 'px',
    OPACITY = 'opacity',
    AUTO = 'auto',
    BORDER_LEFT_WIDTH = 'borderLeftWidth',
    BORDER_TOP_WIDTH = 'borderTopWidth',
    BORDER_RIGHT_WIDTH = 'borderRightWidth',
    BORDER_BOTTOM_WIDTH = 'borderBottomWidth',
    VISIBLE = 'visible',
    TRANSPARENT = 'transparent',
    HEIGHT = 'height',
    WIDTH = 'width',
    STYLE = 'style',
    CURRENT_STYLE = 'currentStyle',

// IE getComputedStyle
// TODO: unit-less lineHeight (e.g. 1.22)
    re_size = /^width|height$/,
    re_unit = /^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,

    ComputedStyle = {
        /**
        * @method get
        * @description Method used by DOM to get style information for IE
        * @param {HTMLElement} el The element to check
        * @param {String} property The property to check
        * @returns {String} The computed style
        */
        get: function(el, property) {
            var value = '',
                current = el[CURRENT_STYLE][property];

            if (property === OPACITY) {
                value = Y.Dom.getStyle(el, OPACITY);        
            } else if (!current || (current.indexOf && current.indexOf(PX) > -1)) { // no need to convert
                value = current;
            } else if (Y.Dom.IE_COMPUTED[property]) { // use compute function
                value = Y.Dom.IE_COMPUTED[property](el, property);
            } else if (re_unit.test(current)) { // convert to pixel
                value = Y.Dom.IE.ComputedStyle.getPixel(el, property);
            } else {
                value = current;
            }

            return value;
        },
        /**
        * @method getOffset
        * @description Determine the offset of an element
        * @param {HTMLElement} el The element to check
        * @param {String} prop The property to check.
        * @return {String} The offset
        */
        getOffset: function(el, prop) {
            var current = el[CURRENT_STYLE][prop],                        // value of "width", "top", etc.
                capped = prop.charAt(0).toUpperCase() + prop.substr(1), // "Width", "Top", etc.
                offset = 'offset' + capped,                             // "offsetWidth", "offsetTop", etc.
                pixel = 'pixel' + capped,                               // "pixelWidth", "pixelTop", etc.
                value = '',
                actual;

            if (current == AUTO) {
                actual = el[offset]; // offsetHeight/Top etc.
                if (actual === undefined) { // likely "right" or "bottom"
                    value = 0;
                }

                value = actual;
                if (re_size.test(prop)) { // account for box model diff 
                    el[STYLE][prop] = actual; 
                    if (el[offset] > actual) {
                        // the difference is padding + border (works in Standards & Quirks modes)
                        value = actual - (el[offset] - actual);
                    }
                    el[STYLE][prop] = AUTO; // revert to auto
                }
            } else { // convert units to px
                if (!el[STYLE][pixel] && !el[STYLE][prop]) { // need to map style.width to currentStyle (no currentStyle.pixelWidth)
                    el[STYLE][prop] = current;              // no style.pixelWidth if no style.width
                }
                value = el[STYLE][pixel];
            }
            return value + PX;
        },
        /**
        * @method getBorderWidth
        * @description Try to determine the width of an elements border
        * @param {HTMLElement} el The element to check
        * @param {String} property The property to check
        * @return {String} The elements border width
        */
        getBorderWidth: function(el, property) {
            // clientHeight/Width = paddingBox (e.g. offsetWidth - borderWidth)
            // clientTop/Left = borderWidth
            var value = null;
            if (!el[CURRENT_STYLE][HAS_LAYOUT]) { // TODO: unset layout?
                el[STYLE].zoom = 1; // need layout to measure client
            }

            switch(property) {
                case BORDER_TOP_WIDTH:
                    value = el[CLIENT_TOP];
                    break;
                case BORDER_BOTTOM_WIDTH:
                    value = el.offsetHeight - el.clientHeight - el[CLIENT_TOP];
                    break;
                case BORDER_LEFT_WIDTH:
                    value = el[CLIENT_LEFT];
                    break;
                case BORDER_RIGHT_WIDTH:
                    value = el.offsetWidth - el.clientWidth - el[CLIENT_LEFT];
                    break;
            }
            return value + PX;
        },
        /**
        * @method getPixel
        * @description Get the pixel value from a style property
        * @param {HTMLElement} node The element to check
        * @param {String} att The attribute to check
        * @return {String} The pixel value
        */
        getPixel: function(node, att) {
            // use pixelRight to convert to px
            var val = null,
                styleRight = node[CURRENT_STYLE][RIGHT],
                current = node[CURRENT_STYLE][att];

            node[STYLE][RIGHT] = current;
            val = node[STYLE].pixelRight;
            node[STYLE][RIGHT] = styleRight; // revert

            return val + PX;
        },

        /**
        * @method getMargin
        * @description Get the margin value from a style property
        * @param {HTMLElement} node The element to check
        * @param {String} att The attribute to check
        * @return {String} The margin value
        */
        getMargin: function(node, att) {
            var val;
            if (node[CURRENT_STYLE][att] == AUTO) {
                val = 0 + PX;
            } else {
                val = Y.Dom.IE.ComputedStyle.getPixel(node, att);
            }
            return val;
        },

        /**
        * @method getVisibility
        * @description Get the visibility of an element
        * @param {HTMLElement} node The element to check
        * @param {String} att The attribute to check
        * @return {String} The value
        */
        getVisibility: function(node, att) {
            var current;
            while ( (current = node[CURRENT_STYLE]) && current[att] == 'inherit') { // NOTE: assignment in test
                node = node[PARENT_NODE];
            }
            return (current) ? current[att] : VISIBLE;
        },

        /**
        * @method getColor
        * @description Get the color of an element
        * @param {HTMLElement} node The element to check
        * @param {String} att The attribute to check
        * @return {String} The value
        */
        getColor: function(node, att) {
            return Y.Dom.Color.toRGB(node[CURRENT_STYLE][att]) || TRANSPARENT;
        },

        /**
        * @method getBorderColor
        * @description Get the bordercolor of an element
        * @param {HTMLElement} node The element to check
        * @param {String} att The attribute to check
        * @return {String} The value
        */
        getBorderColor: function(node, att) {
            var current = node[CURRENT_STYLE],
                val = current[att] || current.color;
            return Y.Dom.Color.toRGB(Y.Dom.Color.toHex(val));
        }

    },

//fontSize: getPixelFont,
    IEComputed = {};

IEComputed.top = IEComputed.right = IEComputed.bottom = IEComputed.left = 
        IEComputed[WIDTH] = IEComputed[HEIGHT] = ComputedStyle.getOffset;

IEComputed.color = ComputedStyle.getColor;

IEComputed[BORDER_TOP_WIDTH] = IEComputed[BORDER_RIGHT_WIDTH] =
        IEComputed[BORDER_BOTTOM_WIDTH] = IEComputed[BORDER_LEFT_WIDTH] =
        ComputedStyle.getBorderWidth;

IEComputed.marginTop = IEComputed.marginRight = IEComputed.marginBottom =
        IEComputed.marginLeft = ComputedStyle.getMargin;

IEComputed.visibility = ComputedStyle.getVisibility;
IEComputed.borderColor = IEComputed.borderTopColor =
        IEComputed.borderRightColor = IEComputed.borderBottomColor =
        IEComputed.borderLeftColor = ComputedStyle.getBorderColor;

Y.Dom.IE_COMPUTED = IEComputed;
Y.Dom.IE_ComputedStyle = ComputedStyle;
})();
(function() {
/**
 * Add style management functionality to DOM.
 * @module dom
 * @class Color
 * @namespace YAHOO.util.Dom
 */

var TO_STRING = 'toString',
    PARSE_INT = parseInt,
    RE = RegExp,
    Y = YAHOO.util;

Y.Dom.Color = {
    /**
    * @property KEYWORDS
    * @type Object
    * @description Color keywords used when converting to Hex
    */
    KEYWORDS: {
        black: '000',
        silver: 'c0c0c0',
        gray: '808080',
        white: 'fff',
        maroon: '800000',
        red: 'f00',
        purple: '800080',
        fuchsia: 'f0f',
        green: '008000',
        lime: '0f0',
        olive: '808000',
        yellow: 'ff0',
        navy: '000080',
        blue: '00f',
        teal: '008080',
        aqua: '0ff'
    },
    /**
    * @property re_RGB
    * @private
    * @type Regex
    * @description Regex to parse rgb(0,0,0) formatted strings
    */
    re_RGB: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
    /**
    * @property re_hex
    * @private
    * @type Regex
    * @description Regex to parse #123456 formatted strings
    */
    re_hex: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
    /**
    * @property re_hex3
    * @private
    * @type Regex
    * @description Regex to parse #123 formatted strings
    */
    re_hex3: /([0-9A-F])/gi,
    /**
    * @method toRGB
    * @description Converts a hex or color string to an rgb string: rgb(0,0,0)
    * @param {String} val The string to convert to RGB notation.
    * @returns {String} The converted string
    */
    toRGB: function(val) {
        if (!Y.Dom.Color.re_RGB.test(val)) {
            val = Y.Dom.Color.toHex(val);
        }

        if(Y.Dom.Color.re_hex.exec(val)) {
            val = 'rgb(' + [
                PARSE_INT(RE.$1, 16),
                PARSE_INT(RE.$2, 16),
                PARSE_INT(RE.$3, 16)
            ].join(', ') + ')';
        }
        return val;
    },
    /**
    * @method toHex
    * @description Converts an rgb or color string to a hex string: #123456
    * @param {String} val The string to convert to hex notation.
    * @returns {String} The converted string
    */
    toHex: function(val) {
        val = Y.Dom.Color.KEYWORDS[val] || val;
        if (Y.Dom.Color.re_RGB.exec(val)) {
            val = [
                Number(RE.$1).toString(16),
                Number(RE.$2).toString(16),
                Number(RE.$3).toString(16)
            ];

            for (var i = 0; i < val.length; i++) {
                if (val[i].length < 2) {
                    val[i] = '0' + val[i];
                }
            }

            val = val.join('');
        }

        if (val.length < 6) {
            val = val.replace(Y.Dom.Color.re_hex3, '$1$1');
        }

        if (val !== 'transparent' && val.indexOf('#') < 0) {
            val = '#' + val;
        }

        return val.toUpperCase();
    }
};
}());
YAHOO.register("dom", YAHOO.util.Dom, {version: "2.9.0", build: "2800"});
/*
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/

/**
 * The CustomEvent class lets you define events for your application
 * that can be subscribed to by one or more independent component.
 *
 * @param {String}  type The type of event, which is passed to the callback
 *                  when the event fires
 * @param {Object}  context The context the event will fire from.  "this" will
 *                  refer to this object in the callback.  Default value:
 *                  the window object.  The listener can override this.
 * @param {boolean} silent pass true to prevent the event from writing to
 *                  the debugsystem
 * @param {int}     signature the signature that the custom event subscriber
 *                  will receive. YAHOO.util.CustomEvent.LIST or
 *                  YAHOO.util.CustomEvent.FLAT.  The default is
 *                  YAHOO.util.CustomEvent.LIST.
 * @param fireOnce {boolean} If configured to fire once, the custom event
 * will only notify subscribers a single time regardless of how many times
 * the event is fired.  In addition, new subscribers will be notified
 * immediately if the event has already been fired.
 * @namespace YAHOO.util
 * @class CustomEvent
 * @constructor
 */
YAHOO.util.CustomEvent = function(type, context, silent, signature, fireOnce) {

    /**
     * The type of event, returned to subscribers when the event fires
     * @property type
     * @type string
     */
    this.type = type;

    /**
     * The context the event will fire from by default. Defaults to the window obj.
     * @property scope
     * @type object
     */
    this.scope = context || window;

    /**
     * By default all custom events are logged in the debug build. Set silent to true
     * to disable debug output for this event.
     * @property silent
     * @type boolean
     */
    this.silent = silent;

    /**
     * If configured to fire once, the custom event will only notify subscribers
     * a single time regardless of how many times the event is fired.  In addition,
     * new subscribers will be notified immediately if the event has already been
     * fired.
     * @property fireOnce
     * @type boolean
     * @default false
     */
    this.fireOnce = fireOnce;

    /**
     * Indicates whether or not this event has ever been fired.
     * @property fired
     * @type boolean
     * @default false
     */
    this.fired = false;

    /**
     * For fireOnce events the arguments the event was fired with are stored
     * so that new subscribers get the proper payload.
     * @property firedWith
     * @type Array
     */
    this.firedWith = null;

    /**
     * Custom events support two styles of arguments provided to the event
     * subscribers.
     * <ul>
     * <li>YAHOO.util.CustomEvent.LIST:
     *   <ul>
     *   <li>param1: event name</li>
     *   <li>param2: array of arguments sent to fire</li>
     *   <li>param3: <optional> a custom object supplied by the subscriber</li>
     *   </ul>
     * </li>
     * <li>YAHOO.util.CustomEvent.FLAT
     *   <ul>
     *   <li>param1: the first argument passed to fire.  If you need to
     *           pass multiple parameters, use and array or object literal</li>
     *   <li>param2: <optional> a custom object supplied by the subscriber</li>
     *   </ul>
     * </li>
     * </ul>
     *   @property signature
     *   @type int
     */
    this.signature = signature || YAHOO.util.CustomEvent.LIST;

    /**
     * The subscribers to this event
     * @property subscribers
     * @type Subscriber[]
     */
    this.subscribers = [];

    if (!this.silent) {
    }

    var onsubscribeType = "_YUICEOnSubscribe";

    // Only add subscribe events for events that are not generated by
    // CustomEvent
    if (type !== onsubscribeType) {

        /**
         * Custom events provide a custom event that fires whenever there is
         * a new subscriber to the event.  This provides an opportunity to
         * handle the case where there is a non-repeating event that has
         * already fired has a new subscriber.
         *
         * @event subscribeEvent
         * @type YAHOO.util.CustomEvent
         * @param fn {Function} The function to execute
         * @param obj <Object> An object to be passed along when the event fires.
         * Defaults to the custom event.
         * @param override <boolean|Object> If true, the obj passed in becomes the
         * execution context of the listener. If an object, that object becomes
         * the execution context. Defaults to the custom event.
         */
        this.subscribeEvent =
                new YAHOO.util.CustomEvent(onsubscribeType, this, true);

    }


    /**
     * In order to make it possible to execute the rest of the subscriber
     * stack when one thows an exception, the subscribers exceptions are
     * caught.  The most recent exception is stored in this property
     * @property lastError
     * @type Error
     */
    this.lastError = null;
};

/**
 * Subscriber listener sigature constant.  The LIST type returns three
 * parameters: the event type, the array of args passed to fire, and
 * the optional custom object
 * @property YAHOO.util.CustomEvent.LIST
 * @static
 * @type int
 */
YAHOO.util.CustomEvent.LIST = 0;

/**
 * Subscriber listener sigature constant.  The FLAT type returns two
 * parameters: the first argument passed to fire and the optional
 * custom object
 * @property YAHOO.util.CustomEvent.FLAT
 * @static
 * @type int
 */
YAHOO.util.CustomEvent.FLAT = 1;

YAHOO.util.CustomEvent.prototype = {

    /**
     * Subscribes the caller to this event
     * @method subscribe
     * @param {Function} fn        The function to execute
     * @param {Object}   obj       An object to be passed along when the event
     * fires.
     * @param {boolean|Object} overrideContext If true, the obj passed in
     * becomes the execution.
     * context of the listener. If an object, that object becomes the execution
     * context.
     */
    subscribe: function(fn, obj, overrideContext) {

        if (!fn) {
throw new Error("Invalid callback for subscriber to '" + this.type + "'");
        }

        if (this.subscribeEvent) {
            this.subscribeEvent.fire(fn, obj, overrideContext);
        }

        var s = new YAHOO.util.Subscriber(fn, obj, overrideContext);

        if (this.fireOnce && this.fired) {
            this.notify(s, this.firedWith);
        } else {
            this.subscribers.push(s);
        }
    },

    /**
     * Unsubscribes subscribers.
     * @method unsubscribe
     * @param {Function} fn  The subscribed function to remove, if not supplied
     *                       all will be removed
     * @param {Object}   obj  The custom object passed to subscribe.  This is
     *                        optional, but if supplied will be used to
     *                        disambiguate multiple listeners that are the same
     *                        (e.g., you subscribe many object using a function
     *                        that lives on the prototype)
     * @return {boolean} True if the subscriber was found and detached.
     */
    unsubscribe: function(fn, obj) {

        if (!fn) {
            return this.unsubscribeAll();
        }

        var found = false;
        for (var i=0, len=this.subscribers.length; i<len; ++i) {
            var s = this.subscribers[i];
            if (s && s.contains(fn, obj)) {
                this._delete(i);
                found = true;
            }
        }

        return found;
    },

    /**
     * Notifies the subscribers.  The callback functions will be executed
     * from the context specified when the event was created, and with the
     * following parameters:
     *   <ul>
     *   <li>The type of event</li>
     *   <li>All of the arguments fire() was executed with as an array</li>
     *   <li>The custom object (if any) that was passed into the subscribe()
     *       method</li>
     *   </ul>
     * @method fire
     * @param {Object*} arguments an arbitrary set of parameters to pass to
     *                            the handler.
     * @return {boolean} false if one of the subscribers returned false,
     *                   true otherwise
     */
    fire: function() {

        this.lastError = null;

        var errors = [],
            len=this.subscribers.length;


        var args=[].slice.call(arguments, 0), ret=true, i, rebuild=false;

        if (this.fireOnce) {
            if (this.fired) {
                return true;
            } else {
                this.firedWith = args;
            }
        }

        this.fired = true;

        if (!len && this.silent) {
            return true;
        }

        if (!this.silent) {
        }

        // make a copy of the subscribers so that there are
        // no index problems if one subscriber removes another.
        var subs = this.subscribers.slice();

        for (i=0; i<len; ++i) {
            var s = subs[i];
            if (!s || !s.fn) {
                rebuild=true;
            } else {

                ret = this.notify(s, args);

                if (false === ret) {
                    if (!this.silent) {
                    }

                    break;
                }
            }
        }

        return (ret !== false);
    },

    notify: function(s, args) {

        var ret, param=null, scope = s.getScope(this.scope),
                 throwErrors = YAHOO.util.Event.throwErrors;

        if (!this.silent) {
        }

        if (this.signature == YAHOO.util.CustomEvent.FLAT) {

            if (args.length > 0) {
                param = args[0];
            }

            try {
                ret = s.fn.call(scope, param, s.obj);
            } catch(e) {
                this.lastError = e;
                // errors.push(e);
                if (throwErrors) {
                    throw e;
                }
            }
        } else {
            try {
                ret = s.fn.call(scope, this.type, args, s.obj);
            } catch(ex) {
                this.lastError = ex;
                if (throwErrors) {
                    throw ex;
                }
            }
        }

        return ret;
    },

    /**
     * Removes all listeners
     * @method unsubscribeAll
     * @return {int} The number of listeners unsubscribed
     */
    unsubscribeAll: function() {
        var l = this.subscribers.length, i;
        for (i=l-1; i>-1; i--) {
            this._delete(i);
        }

        this.subscribers=[];

        return l;
    },

    /**
     * @method _delete
     * @private
     */
    _delete: function(index) {
        var s = this.subscribers[index];
        if (s) {
            delete s.fn;
            delete s.obj;
        }

        // this.subscribers[index]=null;
        this.subscribers.splice(index, 1);
    },

    /**
     * @method toString
     */
    toString: function() {
         return "CustomEvent: " + "'" + this.type  + "', " +
             "context: " + this.scope;

    }
};

/////////////////////////////////////////////////////////////////////

/**
 * Stores the subscriber information to be used when the event fires.
 * @param {Function} fn       The function to execute
 * @param {Object}   obj      An object to be passed along when the event fires
 * @param {boolean}  overrideContext If true, the obj passed in becomes the execution
 *                            context of the listener
 * @class Subscriber
 * @constructor
 */
YAHOO.util.Subscriber = function(fn, obj, overrideContext) {

    /**
     * The callback that will be execute when the event fires
     * @property fn
     * @type function
     */
    this.fn = fn;

    /**
     * An optional custom object that will passed to the callback when
     * the event fires
     * @property obj
     * @type object
     */
    this.obj = YAHOO.lang.isUndefined(obj) ? null : obj;

    /**
     * The default execution context for the event listener is defined when the
     * event is created (usually the object which contains the event).
     * By setting overrideContext to true, the execution context becomes the custom
     * object passed in by the subscriber.  If overrideContext is an object, that
     * object becomes the context.
     * @property overrideContext
     * @type boolean|object
     */
    this.overrideContext = overrideContext;

};

/**
 * Returns the execution context for this listener.  If overrideContext was set to true
 * the custom obj will be the context.  If overrideContext is an object, that is the
 * context, otherwise the default context will be used.
 * @method getScope
 * @param {Object} defaultScope the context to use if this listener does not
 *                              override it.
 */
YAHOO.util.Subscriber.prototype.getScope = function(defaultScope) {
    if (this.overrideContext) {
        if (this.overrideContext === true) {
            return this.obj;
        } else {
            return this.overrideContext;
        }
    }
    return defaultScope;
};

/**
 * Returns true if the fn and obj match this objects properties.
 * Used by the unsubscribe method to match the right subscriber.
 *
 * @method contains
 * @param {Function} fn the function to execute
 * @param {Object} obj an object to be passed along when the event fires
 * @return {boolean} true if the supplied arguments match this
 *                   subscriber's signature.
 */
YAHOO.util.Subscriber.prototype.contains = function(fn, obj) {
    if (obj) {
        return (this.fn == fn && this.obj == obj);
    } else {
        return (this.fn == fn);
    }
};

/**
 * @method toString
 */
YAHOO.util.Subscriber.prototype.toString = function() {
    return "Subscriber { obj: " + this.obj  +
           ", overrideContext: " +  (this.overrideContext || "no") + " }";
};

/**
 * The Event Utility provides utilities for managing DOM Events and tools
 * for building event systems
 *
 * @module event
 * @title Event Utility
 * @namespace YAHOO.util
 * @requires yahoo
 */

// The first instance of Event will win if it is loaded more than once.
// @TODO this needs to be changed so that only the state data that needs to
// be preserved is kept, while methods are overwritten/added as needed.
// This means that the module pattern can't be used.
if (!YAHOO.util.Event) {

/**
 * The event utility provides functions to add and remove event listeners,
 * event cleansing.  It also tries to automatically remove listeners it
 * registers during the unload event.
 *
 * @class Event
 * @static
 */
    YAHOO.util.Event = function() {

        /**
         * True after the onload event has fired
         * @property loadComplete
         * @type boolean
         * @static
         * @private
         */
        var loadComplete =  false,

        /**
         * Cache of wrapped listeners
         * @property listeners
         * @type array
         * @static
         * @private
         */
        listeners = [],


        /**
         * User-defined unload function that will be fired before all events
         * are detached
         * @property unloadListeners
         * @type array
         * @static
         * @private
         */
        unloadListeners = [],

        /**
         * The number of times to poll after window.onload.  This number is
         * increased if additional late-bound handlers are requested after
         * the page load.
         * @property retryCount
         * @static
         * @private
         */
        retryCount = 0,

        /**
         * onAvailable listeners
         * @property onAvailStack
         * @static
         * @private
         */
        onAvailStack = [],

        /**
         * Counter for auto id generation
         * @property counter
         * @static
         * @private
         */
        counter = 0,

        /**
         * Normalized keycodes for webkit/safari
         * @property webkitKeymap
         * @type {int: int}
         * @private
         * @static
         * @final
         */
         webkitKeymap = {
            63232: 38, // up
            63233: 40, // down
            63234: 37, // left
            63235: 39, // right
            63276: 33, // page up
            63277: 34, // page down
            25: 9      // SHIFT-TAB (Safari provides a different key code in
                       // this case, even though the shiftKey modifier is set)
        },

        isIE = YAHOO.env.ua.ie,

        // String constants used by the addFocusListener and removeFocusListener methods

        FOCUSIN = "focusin",
        FOCUSOUT = "focusout";

        return {

            /**
             * The number of times we should look for elements that are not
             * in the DOM at the time the event is requested after the document
             * has been loaded.  The default is 500@amp;40 ms, so it will poll
             * for 20 seconds or until all outstanding handlers are bound
             * (whichever comes first).
             * @property POLL_RETRYS
             * @type int
             * @static
             * @final
             */
            POLL_RETRYS: 500,

            /**
             * The poll interval in milliseconds
             * @property POLL_INTERVAL
             * @type int
             * @static
             * @final
             */
            POLL_INTERVAL: 40,

            /**
             * Element to bind, int constant
             * @property EL
             * @type int
             * @static
             * @final
             */
            EL: 0,

            /**
             * Type of event, int constant
             * @property TYPE
             * @type int
             * @static
             * @final
             */
            TYPE: 1,

            /**
             * Function to execute, int constant
             * @property FN
             * @type int
             * @static
             * @final
             */
            FN: 2,

            /**
             * Function wrapped for context correction and cleanup, int constant
             * @property WFN
             * @type int
             * @static
             * @final
             */
            WFN: 3,

            /**
             * Object passed in by the user that will be returned as a
             * parameter to the callback, int constant.  Specific to
             * unload listeners
             * @property OBJ
             * @type int
             * @static
             * @final
             */
            UNLOAD_OBJ: 3,

            /**
             * Adjusted context, either the element we are registering the event
             * on or the custom object passed in by the listener, int constant
             * @property ADJ_SCOPE
             * @type int
             * @static
             * @final
             */
            ADJ_SCOPE: 4,

            /**
             * The original obj passed into addListener
             * @property OBJ
             * @type int
             * @static
             * @final
             */
            OBJ: 5,

            /**
             * The original context parameter passed into addListener
             * @property OVERRIDE
             * @type int
             * @static
             * @final
             */
            OVERRIDE: 6,

            /**
             * The original capture parameter passed into addListener
             * @property CAPTURE
             * @type int
             * @static
             * @final
             */
            CAPTURE: 7,

            /**
             * addListener/removeListener can throw errors in unexpected scenarios.
             * These errors are suppressed, the method returns false, and this property
             * is set
             * @property lastError
             * @static
             * @type Error
             */
            lastError: null,

            /**
             * Safari detection
             * @property isSafari
             * @private
             * @static
             * @deprecated use YAHOO.env.ua.webkit
             */
            isSafari: YAHOO.env.ua.webkit,

            /**
             * webkit version
             * @property webkit
             * @type string
             * @private
             * @static
             * @deprecated use YAHOO.env.ua.webkit
             */
            webkit: YAHOO.env.ua.webkit,

            /**
             * IE detection
             * @property isIE
             * @private
             * @static
             * @deprecated use YAHOO.env.ua.ie
             */
            isIE: isIE,

            /**
             * poll handle
             * @property _interval
             * @static
             * @private
             */
            _interval: null,

            /**
             * document readystate poll handle
             * @property _dri
             * @static
             * @private
             */
             _dri: null,


            /**
             * Map of special event types
             * @property _specialTypes
             * @static
             * @private
             */
            _specialTypes: {
                focusin: (isIE ? "focusin" : "focus"),
                focusout: (isIE ? "focusout" : "blur")
            },


            /**
             * True when the document is initially usable
             * @property DOMReady
             * @type boolean
             * @static
             */
            DOMReady: false,

            /**
             * Errors thrown by subscribers of custom events are caught
             * and the error message is written to the debug console.  If
             * this property is set to true, it will also re-throw the
             * error.
             * @property throwErrors
             * @type boolean
             * @default false
             */
            throwErrors: false,


            /**
             * @method startInterval
             * @static
             * @private
             */
            startInterval: function() {
                if (!this._interval) {
                    // var self = this;
                    // var callback = function() { self._tryPreloadAttach(); };
                    // this._interval = setInterval(callback, this.POLL_INTERVAL);
                    this._interval = YAHOO.lang.later(this.POLL_INTERVAL, this, this._tryPreloadAttach, null, true);
                }
            },

            /**
             * Executes the supplied callback when the item with the supplied
             * id is found.  This is meant to be used to execute behavior as
             * soon as possible as the page loads.  If you use this after the
             * initial page load it will poll for a fixed time for the element.
             * The number of times it will poll and the frequency are
             * configurable.  By default it will poll for 10 seconds.
             *
             * <p>The callback is executed with a single parameter:
             * the custom object parameter, if provided.</p>
             *
             * @method onAvailable
             *
             * @param {string||string[]}   id the id of the element, or an array
             * of ids to look for.
             * @param {function} fn what to execute when the element is found.
             * @param {object}   obj an optional object to be passed back as
             *                   a parameter to fn.
             * @param {boolean|object}  overrideContext If set to true, fn will execute
             *                   in the context of obj, if set to an object it
             *                   will execute in the context of that object
             * @param checkContent {boolean} check child node readiness (onContentReady)
             * @static
             */
            onAvailable: function(id, fn, obj, overrideContext, checkContent) {

                var a = (YAHOO.lang.isString(id)) ? [id] : id;

                for (var i=0; i<a.length; i=i+1) {
                    onAvailStack.push({id:         a[i],
                                       fn:         fn,
                                       obj:        obj,
                                       overrideContext:   overrideContext,
                                       checkReady: checkContent });
                }

                retryCount = this.POLL_RETRYS;

                this.startInterval();
            },

            /**
             * Works the same way as onAvailable, but additionally checks the
             * state of sibling elements to determine if the content of the
             * available element is safe to modify.
             *
             * <p>The callback is executed with a single parameter:
             * the custom object parameter, if provided.</p>
             *
             * @method onContentReady
             *
             * @param {string}   id the id of the element to look for.
             * @param {function} fn what to execute when the element is ready.
             * @param {object}   obj an optional object to be passed back as
             *                   a parameter to fn.
             * @param {boolean|object}  overrideContext If set to true, fn will execute
             *                   in the context of obj.  If an object, fn will
             *                   exectute in the context of that object
             *
             * @static
             */
            onContentReady: function(id, fn, obj, overrideContext) {
                this.onAvailable(id, fn, obj, overrideContext, true);
            },

            /**
             * Executes the supplied callback when the DOM is first usable.  This
             * will execute immediately if called after the DOMReady event has
             * fired.   @todo the DOMContentReady event does not fire when the
             * script is dynamically injected into the page.  This means the
             * DOMReady custom event will never fire in FireFox or Opera when the
             * library is injected.  It _will_ fire in Safari, and the IE
             * implementation would allow for us to fire it if the defered script
             * is not available.  We want this to behave the same in all browsers.
             * Is there a way to identify when the script has been injected
             * instead of included inline?  Is there a way to know whether the
             * window onload event has fired without having had a listener attached
             * to it when it did so?
             *
             * <p>The callback is a CustomEvent, so the signature is:</p>
             * <p>type &lt;string&gt;, args &lt;array&gt;, customobject &lt;object&gt;</p>
             * <p>For DOMReady events, there are no fire argments, so the
             * signature is:</p>
             * <p>"DOMReady", [], obj</p>
             *
             *
             * @method onDOMReady
             *
             * @param {function} fn what to execute when the element is found.
             * @param {object}   obj an optional object to be passed back as
             *                   a parameter to fn.
             * @param {boolean|object}  overrideContext If set to true, fn will execute
             *                   in the context of obj, if set to an object it
             *                   will execute in the context of that object
             *
             * @static
             */
            // onDOMReady: function(fn, obj, overrideContext) {
            onDOMReady: function() {
                this.DOMReadyEvent.subscribe.apply(this.DOMReadyEvent, arguments);
            },


            /**
             * Appends an event handler
             *
             * @method _addListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to assign the
             *  listener to.
             * @param {String}   sType     The type of event to append
             * @param {Function} fn        The method the event invokes
             * @param {Object}   obj    An arbitrary object that will be
             *                             passed as a parameter to the handler
             * @param {Boolean|object}  overrideContext  If true, the obj passed in becomes
             *                             the execution context of the listener. If an
             *                             object, this object becomes the execution
             *                             context.
             * @param {boolen}      capture capture or bubble phase
             * @return {Boolean} True if the action was successful or defered,
             *                        false if one or more of the elements
             *                        could not have the listener attached,
             *                        or if the operation throws an exception.
             * @private
             * @static
             */
            _addListener: function(el, sType, fn, obj, overrideContext, bCapture) {

                if (!fn || !fn.call) {
                    return false;
                }

                // The el argument can be an array of elements or element ids.
                if ( this._isValidCollection(el)) {
                    var ok = true;
                    for (var i=0,len=el.length; i<len; ++i) {
                        ok = this.on(el[i],
                                       sType,
                                       fn,
                                       obj,
                                       overrideContext) && ok;
                    }
                    return ok;

                } else if (YAHOO.lang.isString(el)) {
                    var oEl = this.getEl(el);
                    // If the el argument is a string, we assume it is
                    // actually the id of the element.  If the page is loaded
                    // we convert el to the actual element, otherwise we
                    // defer attaching the event until onload event fires

                    // check to see if we need to delay hooking up the event
                    // until after the page loads.
                    if (oEl) {
                        el = oEl;
                    } else {
                        // defer adding the event until the element is available
                        this.onAvailable(el, function() {
                           YAHOO.util.Event._addListener(el, sType, fn, obj, overrideContext, bCapture);
                        });

                        return true;
                    }
                }

                // Element should be an html element or an array if we get
                // here.
                if (!el) {
                    return false;
                }

                // we need to make sure we fire registered unload events
                // prior to automatically unhooking them.  So we hang on to
                // these instead of attaching them to the window and fire the
                // handles explicitly during our one unload event.
                if ("unload" == sType && obj !== this) {
                    unloadListeners[unloadListeners.length] =
                            [el, sType, fn, obj, overrideContext];
                    return true;
                }


                // if the user chooses to override the context, we use the custom
                // object passed in, otherwise the executing context will be the
                // HTML element that the event is registered on
                var context = el;
                if (overrideContext) {
                    if (overrideContext === true) {
                        context = obj;
                    } else {
                        context = overrideContext;
                    }
                }

                // wrap the function so we can return the obj object when
                // the event fires;
                var wrappedFn = function(e) {
                        return fn.call(context, YAHOO.util.Event.getEvent(e, el),
                                obj);
                    };

                var li = [el, sType, fn, wrappedFn, context, obj, overrideContext, bCapture];
                var index = listeners.length;
                // cache the listener so we can try to automatically unload
                listeners[index] = li;

                try {
                    this._simpleAdd(el, sType, wrappedFn, bCapture);
                } catch(ex) {
                    // handle an error trying to attach an event.  If it fails
                    // we need to clean up the cache
                    this.lastError = ex;
                    this.removeListener(el, sType, fn);
                    return false;
                }

                return true;

            },

            /**
             * Checks to see if the type requested is a special type
             * (as defined by the _specialTypes hash), and (if so) returns
             * the special type name.
             *
             * @method _getType
             *
             * @param {String}   sType     The type to look up
             * @private
             */
            _getType: function (type) {

                return this._specialTypes[type] || type;

            },


            /**
             * Appends an event handler
             *
             * @method addListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to assign the
             *  listener to.
             * @param {String}   sType     The type of event to append
             * @param {Function} fn        The method the event invokes
             * @param {Object}   obj    An arbitrary object that will be
             *                             passed as a parameter to the handler
             * @param {Boolean|object}  overrideContext  If true, the obj passed in becomes
             *                             the execution context of the listener. If an
             *                             object, this object becomes the execution
             *                             context.
             * @return {Boolean} True if the action was successful or defered,
             *                        false if one or more of the elements
             *                        could not have the listener attached,
             *                        or if the operation throws an exception.
             * @static
             */
            addListener: function (el, sType, fn, obj, overrideContext) {

                var capture = ((sType == FOCUSIN || sType == FOCUSOUT) && !YAHOO.env.ua.ie) ? true : false;

                return this._addListener(el, this._getType(sType), fn, obj, overrideContext, capture);

            },


            /**
             * Attaches a focusin event listener to the specified element for
             * the purpose of listening for the focus event on the element's
             * descendants.
             * @method addFocusListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to assign the
             *  listener to.
             * @param {Function} fn        The method the event invokes
             * @param {Object}   obj    An arbitrary object that will be
             *                             passed as a parameter to the handler
             * @param {Boolean|object}  overrideContext  If true, the obj passed in becomes
             *                             the execution context of the listener. If an
             *                             object, this object becomes the execution
             *                             context.
             * @return {Boolean} True if the action was successful or defered,
             *                        false if one or more of the elements
             *                        could not have the listener attached,
             *                        or if the operation throws an exception.
             * @static
            * @deprecated use YAHOO.util.Event.on and specify "focusin" as the event type.
             */
            addFocusListener: function (el, fn, obj, overrideContext) {
                return this.on(el, FOCUSIN, fn, obj, overrideContext);
            },


            /**
             * Removes a focusin event listener to the specified element for
             * the purpose of listening for the focus event on the element's
             * descendants.
             *
             * @method removeFocusListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to remove
             *  the listener from.
             * @param {Function} fn the method the event invokes.  If fn is
             *  undefined, then all event handlers for the type of event are
             *  removed.
             * @return {boolean} true if the unbind was successful, false
             *  otherwise.
             * @static
             * @deprecated use YAHOO.util.Event.removeListener and specify "focusin" as the event type.
             */
            removeFocusListener: function (el, fn) {
                return this.removeListener(el, FOCUSIN, fn);
            },

            /**
             * Attaches a focusout event listener to the specified element for
             * the purpose of listening for the blur event on the element's
             * descendants.
             *
             * @method addBlurListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to assign the
             *  listener to.
             * @param {Function} fn        The method the event invokes
             * @param {Object}   obj    An arbitrary object that will be
             *                             passed as a parameter to the handler
             * @param {Boolean|object}  overrideContext  If true, the obj passed in becomes
             *                             the execution context of the listener. If an
             *                             object, this object becomes the execution
             *                             context.
             * @return {Boolean} True if the action was successful or defered,
             *                        false if one or more of the elements
             *                        could not have the listener attached,
             *                        or if the operation throws an exception.
             * @static
             * @deprecated use YAHOO.util.Event.on and specify "focusout" as the event type.
             */
            addBlurListener: function (el, fn, obj, overrideContext) {
                return this.on(el, FOCUSOUT, fn, obj, overrideContext);
            },

            /**
             * Removes a focusout event listener to the specified element for
             * the purpose of listening for the blur event on the element's
             * descendants.
             *
             * @method removeBlurListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to remove
             *  the listener from.
             * @param {Function} fn the method the event invokes.  If fn is
             *  undefined, then all event handlers for the type of event are
             *  removed.
             * @return {boolean} true if the unbind was successful, false
             *  otherwise.
             * @static
             * @deprecated use YAHOO.util.Event.removeListener and specify "focusout" as the event type.
             */
            removeBlurListener: function (el, fn) {
                return this.removeListener(el, FOCUSOUT, fn);
            },

            /**
             * Removes an event listener
             *
             * @method removeListener
             *
             * @param {String|HTMLElement|Array|NodeList} el An id, an element
             *  reference, or a collection of ids and/or elements to remove
             *  the listener from.
             * @param {String} sType the type of event to remove.
             * @param {Function} fn the method the event invokes.  If fn is
             *  undefined, then all event handlers for the type of event are
             *  removed.
             * @return {boolean} true if the unbind was successful, false
             *  otherwise.
             * @static
             */
            removeListener: function(el, sType, fn) {
                var i, len, li;

                sType = this._getType(sType);

                // The el argument can be a string
                if (typeof el == "string") {
                    el = this.getEl(el);
                // The el argument can be an array of elements or element ids.
                } else if ( this._isValidCollection(el)) {
                    var ok = true;
                    for (i=el.length-1; i>-1; i--) {
                        ok = ( this.removeListener(el[i], sType, fn) && ok );
                    }
                    return ok;
                }

                if (!fn || !fn.call) {
                    //return false;
                    return this.purgeElement(el, false, sType);
                }

                if ("unload" == sType) {

                    for (i=unloadListeners.length-1; i>-1; i--) {
                        li = unloadListeners[i];
                        if (li &&
                            li[0] == el &&
                            li[1] == sType &&
                            li[2] == fn) {
                                unloadListeners.splice(i, 1);
                                // unloadListeners[i]=null;
                                return true;
                        }
                    }

                    return false;
                }

                var cacheItem = null;

                // The index is a hidden parameter; needed to remove it from
                // the method signature because it was tempting users to
                // try and take advantage of it, which is not possible.
                var index = arguments[3];

                if ("undefined" === typeof index) {
                    index = this._getCacheIndex(listeners, el, sType, fn);
                }

                if (index >= 0) {
                    cacheItem = listeners[index];
                }

                if (!el || !cacheItem) {
                    return false;
                }


                var bCapture = cacheItem[this.CAPTURE] === true ? true : false;

                try {
                    this._simpleRemove(el, sType, cacheItem[this.WFN], bCapture);
                } catch(ex) {
                    this.lastError = ex;
                    return false;
                }

                // removed the wrapped handler
                delete listeners[index][this.WFN];
                delete listeners[index][this.FN];
                listeners.splice(index, 1);
                // listeners[index]=null;

                return true;

            },

            /**
             * Returns the event's target element.  Safari sometimes provides
             * a text node, and this is automatically resolved to the text
             * node's parent so that it behaves like other browsers.
             * @method getTarget
             * @param {Event} ev the event
             * @param {boolean} resolveTextNode when set to true the target's
             *                  parent will be returned if the target is a
             *                  text node.  @deprecated, the text node is
             *                  now resolved automatically
             * @return {HTMLElement} the event's target
             * @static
             */
            getTarget: function(ev, resolveTextNode) {
                var t = ev.target || ev.srcElement;
                return this.resolveTextNode(t);
            },

            /**
             * In some cases, some browsers will return a text node inside
             * the actual element that was targeted.  This normalizes the
             * return value for getTarget and getRelatedTarget.
             *
             * If accessing a property of the node throws an error, this is
             * probably the anonymous div wrapper Gecko adds inside text
             * nodes.  This likely will only occur when attempting to access
             * the relatedTarget.  In this case, we now return null because
             * the anonymous div is completely useless and we do not know
             * what the related target was because we can't even get to
             * the element's parent node.
             *
             * @method resolveTextNode
             * @param {HTMLElement} node node to resolve
             * @return {HTMLElement} the normized node
             * @static
             */
            resolveTextNode: function(n) {
                try {
                    if (n && 3 == n.nodeType) {
                        return n.parentNode;
                    }
                } catch(e) {
                    return null;
                }

                return n;
            },

            /**
             * Returns the event's pageX
             * @method getPageX
             * @param {Event} ev the event
             * @return {int} the event's pageX
             * @static
             */
            getPageX: function(ev) {
                var x = ev.pageX;
                if (!x && 0 !== x) {
                    x = ev.clientX || 0;

                    if ( this.isIE ) {
                        x += this._getScrollLeft();
                    }
                }

                return x;
            },

            /**
             * Returns the event's pageY
             * @method getPageY
             * @param {Event} ev the event
             * @return {int} the event's pageY
             * @static
             */
            getPageY: function(ev) {
                var y = ev.pageY;
                if (!y && 0 !== y) {
                    y = ev.clientY || 0;

                    if ( this.isIE ) {
                        y += this._getScrollTop();
                    }
                }


                return y;
            },

            /**
             * Returns the pageX and pageY properties as an indexed array.
             * @method getXY
             * @param {Event} ev the event
             * @return {[x, y]} the pageX and pageY properties of the event
             * @static
             */
            getXY: function(ev) {
                return [this.getPageX(ev), this.getPageY(ev)];
            },

            /**
             * Returns the event's related target
             * @method getRelatedTarget
             * @param {Event} ev the event
             * @return {HTMLElement} the event's relatedTarget
             * @static
             */
            getRelatedTarget: function(ev) {
                var t = ev.relatedTarget;
                if (!t) {
                    if (ev.type == "mouseout") {
                        t = ev.toElement;
                    } else if (ev.type == "mouseover") {
                        t = ev.fromElement;
                    }
                }

                return this.resolveTextNode(t);
            },

            /**
             * Returns the time of the event.  If the time is not included, the
             * event is modified using the current time.
             * @method getTime
             * @param {Event} ev the event
             * @return {Date} the time of the event
             * @static
             */
            getTime: function(ev) {
                if (!ev.time) {
                    var t = new Date().getTime();
                    try {
                        ev.time = t;
                    } catch(ex) {
                        this.lastError = ex;
                        return t;
                    }
                }

                return ev.time;
            },

            /**
             * Convenience method for stopPropagation + preventDefault
             * @method stopEvent
             * @param {Event} ev the event
             * @static
             */
            stopEvent: function(ev) {
                this.stopPropagation(ev);
                this.preventDefault(ev);
            },

            /**
             * Stops event propagation
             * @method stopPropagation
             * @param {Event} ev the event
             * @static
             */
            stopPropagation: function(ev) {
                if (ev.stopPropagation) {
                    ev.stopPropagation();
                } else {
                    ev.cancelBubble = true;
                }
            },

            /**
             * Prevents the default behavior of the event
             * @method preventDefault
             * @param {Event} ev the event
             * @static
             */
            preventDefault: function(ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                } else {
                    ev.returnValue = false;
                }
            },

            /**
             * Finds the event in the window object, the caller's arguments, or
             * in the arguments of another method in the callstack.  This is
             * executed automatically for events registered through the event
             * manager, so the implementer should not normally need to execute
             * this function at all.
             * @method getEvent
             * @param {Event} e the event parameter from the handler
             * @param {HTMLElement} boundEl the element the listener is attached to
             * @return {Event} the event
             * @static
             */
            getEvent: function(e, boundEl) {
                var ev = e || window.event;

                if (!ev) {
                    var c = this.getEvent.caller;
                    while (c) {
                        ev = c.arguments[0];
                        if (ev && Event == ev.constructor) {
                            break;
                        }
                        c = c.caller;
                    }
                }

                return ev;
            },

            /**
             * Returns the charcode for an event
             * @method getCharCode
             * @param {Event} ev the event
             * @return {int} the event's charCode
             * @static
             */
            getCharCode: function(ev) {
                var code = ev.keyCode || ev.charCode || 0;

                // webkit key normalization
                if (YAHOO.env.ua.webkit && (code in webkitKeymap)) {
                    code = webkitKeymap[code];
                }
                return code;
            },

            /**
             * Locating the saved event handler data by function ref
             *
             * @method _getCacheIndex
             * @static
             * @private
             */
            _getCacheIndex: function(a, el, sType, fn) {
                for (var i=0, l=a.length; i<l; i=i+1) {
                    var li = a[i];
                    if ( li                 &&
                         li[this.FN] == fn  &&
                         li[this.EL] == el  &&
                         li[this.TYPE] == sType ) {
                        return i;
                    }
                }

                return -1;
            },

            /**
             * Generates an unique ID for the element if it does not already
             * have one.
             * @method generateId
             * @param el the element to create the id for
             * @return {string} the resulting id of the element
             * @static
             */
            generateId: function(el) {
                var id = el.id;

                if (!id) {
                    id = "yuievtautoid-" + counter;
                    ++counter;
                    el.id = id;
                }

                return id;
            },


            /**
             * We want to be able to use getElementsByTagName as a collection
             * to attach a group of events to.  Unfortunately, different
             * browsers return different types of collections.  This function
             * tests to determine if the object is array-like.  It will also
             * fail if the object is an array, but is empty.
             * @method _isValidCollection
             * @param o the object to test
             * @return {boolean} true if the object is array-like and populated
             * @static
             * @private
             */
            _isValidCollection: function(o) {
                try {
                    return ( o                     && // o is something
                             typeof o !== "string" && // o is not a string
                             o.length              && // o is indexed
                             !o.tagName            && // o is not an HTML element
                             !o.alert              && // o is not a window
                             typeof o[0] !== "undefined" );
                } catch(ex) {
                    return false;
                }

            },

            /**
             * @private
             * @property elCache
             * DOM element cache
             * @static
             * @deprecated Elements are not cached due to issues that arise when
             * elements are removed and re-added
             */
            elCache: {},

            /**
             * We cache elements bound by id because when the unload event
             * fires, we can no longer use document.getElementById
             * @method getEl
             * @static
             * @private
             * @deprecated Elements are not cached any longer
             */
            getEl: function(id) {
                return (typeof id === "string") ? document.getElementById(id) : id;
            },

            /**
             * Clears the element cache
             * @deprecated Elements are not cached any longer
             * @method clearCache
             * @static
             * @private
             */
            clearCache: function() { },

            /**
             * Custom event the fires when the dom is initially usable
             * @event DOMReadyEvent
             */
            DOMReadyEvent: new YAHOO.util.CustomEvent("DOMReady", YAHOO, 0, 0, 1),

            /**
             * hook up any deferred listeners
             * @method _load
             * @static
             * @private
             */
            _load: function(e) {

                if (!loadComplete) {
                    loadComplete = true;
                    var EU = YAHOO.util.Event;

                    // Just in case DOMReady did not go off for some reason
                    EU._ready();

                    // Available elements may not have been detected before the
                    // window load event fires. Try to find them now so that the
                    // the user is more likely to get the onAvailable notifications
                    // before the window load notification
                    EU._tryPreloadAttach();

                }
            },

            /**
             * Fires the DOMReady event listeners the first time the document is
             * usable.
             * @method _ready
             * @static
             * @private
             */
            _ready: function(e) {
                var EU = YAHOO.util.Event;
                if (!EU.DOMReady) {
                    EU.DOMReady=true;

                    // Fire the content ready custom event
                    EU.DOMReadyEvent.fire();

                    // Remove the DOMContentLoaded (FF/Opera)
                    EU._simpleRemove(document, "DOMContentLoaded", EU._ready);
                }
            },

            /**
             * Polling function that runs before the onload event fires,
             * attempting to attach to DOM Nodes as soon as they are
             * available
             * @method _tryPreloadAttach
             * @static
             * @private
             */
            _tryPreloadAttach: function() {

                if (onAvailStack.length === 0) {
                    retryCount = 0;
                    if (this._interval) {
                        // clearInterval(this._interval);
                        this._interval.cancel();
                        this._interval = null;
                    }
                    return;
                }

                if (this.locked) {
                    return;
                }

                if (this.isIE) {
                    // Hold off if DOMReady has not fired and check current
                    // readyState to protect against the IE operation aborted
                    // issue.
                    if (!this.DOMReady) {
                        this.startInterval();
                        return;
                    }
                }

                this.locked = true;


                // keep trying until after the page is loaded.  We need to
                // check the page load state prior to trying to bind the
                // elements so that we can be certain all elements have been
                // tested appropriately
                var tryAgain = !loadComplete;
                if (!tryAgain) {
                    tryAgain = (retryCount > 0 && onAvailStack.length > 0);
                }

                // onAvailable
                var notAvail = [];

                var executeItem = function (el, item) {
                    var context = el;
                    if (item.overrideContext) {
                        if (item.overrideContext === true) {
                            context = item.obj;
                        } else {
                            context = item.overrideContext;
                        }
                    }
                    item.fn.call(context, item.obj);
                };

                var i, len, item, el, ready=[];

                // onAvailable onContentReady
                for (i=0, len=onAvailStack.length; i<len; i=i+1) {
                    item = onAvailStack[i];
                    if (item) {
                        el = this.getEl(item.id);
                        if (el) {
                            if (item.checkReady) {
                                if (loadComplete || el.nextSibling || !tryAgain) {
                                    ready.push(item);
                                    onAvailStack[i] = null;
                                }
                            } else {
                                executeItem(el, item);
                                onAvailStack[i] = null;
                            }
                        } else {
                            notAvail.push(item);
                        }
                    }
                }

                // make sure onContentReady fires after onAvailable
                for (i=0, len=ready.length; i<len; i=i+1) {
                    item = ready[i];
                    executeItem(this.getEl(item.id), item);
                }


                retryCount--;

                if (tryAgain) {
                    for (i=onAvailStack.length-1; i>-1; i--) {
                        item = onAvailStack[i];
                        if (!item || !item.id) {
                            onAvailStack.splice(i, 1);
                        }
                    }

                    this.startInterval();
                } else {
                    if (this._interval) {
                        // clearInterval(this._interval);
                        this._interval.cancel();
                        this._interval = null;
                    }
                }

                this.locked = false;

            },

            /**
             * Removes all listeners attached to the given element via addListener.
             * Optionally, the node's children can also be purged.
             * Optionally, you can specify a specific type of event to remove.
             * @method purgeElement
             * @param {HTMLElement} el the element to purge
             * @param {boolean} recurse recursively purge this element's children
             * as well.  Use with caution.
             * @param {string} sType optional type of listener to purge. If
             * left out, all listeners will be removed
             * @static
             */
            purgeElement: function(el, recurse, sType) {
                var oEl = (YAHOO.lang.isString(el)) ? this.getEl(el) : el;
                var elListeners = this.getListeners(oEl, sType), i, len;
                if (elListeners) {
                    for (i=elListeners.length-1; i>-1; i--) {
                        var l = elListeners[i];
                        this.removeListener(oEl, l.type, l.fn);
                    }
                }

                if (recurse && oEl && oEl.childNodes) {
                    for (i=0,len=oEl.childNodes.length; i<len ; ++i) {
                        this.purgeElement(oEl.childNodes[i], recurse, sType);
                    }
                }
            },

            /**
             * Returns all listeners attached to the given element via addListener.
             * Optionally, you can specify a specific type of event to return.
             * @method getListeners
             * @param el {HTMLElement|string} the element or element id to inspect
             * @param sType {string} optional type of listener to return. If
             * left out, all listeners will be returned
             * @return {Object} the listener. Contains the following fields:
             * &nbsp;&nbsp;type:   (string)   the type of event
             * &nbsp;&nbsp;fn:     (function) the callback supplied to addListener
             * &nbsp;&nbsp;obj:    (object)   the custom object supplied to addListener
             * &nbsp;&nbsp;adjust: (boolean|object)  whether or not to adjust the default context
             * &nbsp;&nbsp;scope: (boolean)  the derived context based on the adjust parameter
             * &nbsp;&nbsp;index:  (int)      its position in the Event util listener cache
             * @static
             */
            getListeners: function(el, sType) {
                var results=[], searchLists;
                if (!sType) {
                    searchLists = [listeners, unloadListeners];
                } else if (sType === "unload") {
                    searchLists = [unloadListeners];
                } else {
                    sType = this._getType(sType);
                    searchLists = [listeners];
                }

                var oEl = (YAHOO.lang.isString(el)) ? this.getEl(el) : el;

                for (var j=0;j<searchLists.length; j=j+1) {
                    var searchList = searchLists[j];
                    if (searchList) {
                        for (var i=0,len=searchList.length; i<len ; ++i) {
                            var l = searchList[i];
                            if ( l  && l[this.EL] === oEl &&
                                    (!sType || sType === l[this.TYPE]) ) {
                                results.push({
                                    type:   l[this.TYPE],
                                    fn:     l[this.FN],
                                    obj:    l[this.OBJ],
                                    adjust: l[this.OVERRIDE],
                                    scope:  l[this.ADJ_SCOPE],
                                    index:  i
                                });
                            }
                        }
                    }
                }

                return (results.length) ? results : null;
            },

            /**
             * Removes all listeners registered by pe.event.  Called
             * automatically during the unload event.
             * @method _unload
             * @static
             * @private
             */
            _unload: function(e) {

                var EU = YAHOO.util.Event, i, j, l, len, index,
                         ul = unloadListeners.slice(), context;

                // execute and clear stored unload listeners
                for (i=0, len=unloadListeners.length; i<len; ++i) {
                    l = ul[i];
                    if (l) {
                        try {
                            context = window;
                            if (l[EU.ADJ_SCOPE]) {
                                if (l[EU.ADJ_SCOPE] === true) {
                                    context = l[EU.UNLOAD_OBJ];
                                } else {
                                    context = l[EU.ADJ_SCOPE];
                                }
                            }
                            l[EU.FN].call(context, EU.getEvent(e, l[EU.EL]), l[EU.UNLOAD_OBJ] );
                        } catch(e1) {}
                        ul[i] = null;
                    }
                }

                l = null;
                context = null;
                unloadListeners = null;

                // Remove listeners to handle IE memory leaks
                // 2.5.0 listeners are removed for all browsers again.  FireFox preserves
                // at least some listeners between page refreshes, potentially causing
                // errors during page load (mouseover listeners firing before they
                // should if the user moves the mouse at the correct moment).
                if (listeners) {
                    for (j=listeners.length-1; j>-1; j--) {
                        l = listeners[j];
                        if (l) {
                            try {
                                EU.removeListener(l[EU.EL], l[EU.TYPE], l[EU.FN], j);
                            } catch(e2) {}
                        }
                    }
                    l=null;
                }

                try {
                    EU._simpleRemove(window, "unload", EU._unload);
                    EU._simpleRemove(window, "load", EU._load);
                } catch(e3) {}

            },

            /**
             * Returns scrollLeft
             * @method _getScrollLeft
             * @static
             * @private
             */
            _getScrollLeft: function() {
                return this._getScroll()[1];
            },

            /**
             * Returns scrollTop
             * @method _getScrollTop
             * @static
             * @private
             */
            _getScrollTop: function() {
                return this._getScroll()[0];
            },

            /**
             * Returns the scrollTop and scrollLeft.  Used to calculate the
             * pageX and pageY in Internet Explorer
             * @method _getScroll
             * @static
             * @private
             */
            _getScroll: function() {
                var dd = document.documentElement, db = document.body;
                if (dd && (dd.scrollTop || dd.scrollLeft)) {
                    return [dd.scrollTop, dd.scrollLeft];
                } else if (db) {
                    return [db.scrollTop, db.scrollLeft];
                } else {
                    return [0, 0];
                }
            },

            /**
             * Used by old versions of CustomEvent, restored for backwards
             * compatibility
             * @method regCE
             * @private
             * @static
             * @deprecated still here for backwards compatibility
             */
            regCE: function() {},

            /**
             * Adds a DOM event directly without the caching, cleanup, context adj, etc
             *
             * @method _simpleAdd
             * @param {HTMLElement} el      the element to bind the handler to
             * @param {string}      sType   the type of event handler
             * @param {function}    fn      the callback to invoke
             * @param {boolen}      capture capture or bubble phase
             * @static
             * @private
             */
            _simpleAdd: function () {
                if (window.addEventListener) {
                    return function(el, sType, fn, capture) {
                        el.addEventListener(sType, fn, (capture));
                    };
                } else if (window.attachEvent) {
                    return function(el, sType, fn, capture) {
                        el.attachEvent("on" + sType, fn);
                    };
                } else {
                    return function(){};
                }
            }(),

            /**
             * Basic remove listener
             *
             * @method _simpleRemove
             * @param {HTMLElement} el      the element to bind the handler to
             * @param {string}      sType   the type of event handler
             * @param {function}    fn      the callback to invoke
             * @param {boolen}      capture capture or bubble phase
             * @static
             * @private
             */
            _simpleRemove: function() {
                if (window.removeEventListener) {
                    return function (el, sType, fn, capture) {
                        el.removeEventListener(sType, fn, (capture));
                    };
                } else if (window.detachEvent) {
                    return function (el, sType, fn) {
                        el.detachEvent("on" + sType, fn);
                    };
                } else {
                    return function(){};
                }
            }()
        };

    }();

    (function() {
        var EU = YAHOO.util.Event;

        /**
         * Appends an event handler.  This is an alias for <code>addListener</code>
         *
         * @method on
         *
         * @param {String|HTMLElement|Array|NodeList} el An id, an element
         *  reference, or a collection of ids and/or elements to assign the
         *  listener to.
         * @param {String}   sType     The type of event to append
         * @param {Function} fn        The method the event invokes
         * @param {Object}   obj    An arbitrary object that will be
         *                             passed as a parameter to the handler
         * @param {Boolean|object}  overrideContext  If true, the obj passed in becomes
         *                             the execution context of the listener. If an
         *                             object, this object becomes the execution
         *                             context.
         * @return {Boolean} True if the action was successful or defered,
         *                        false if one or more of the elements
         *                        could not have the listener attached,
         *                        or if the operation throws an exception.
         * @static
         */
        EU.on = EU.addListener;

        /**
         * YAHOO.util.Event.onFocus is an alias for addFocusListener
         * @method onFocus
         * @see addFocusListener
         * @static
         * @deprecated use YAHOO.util.Event.on and specify "focusin" as the event type.
         */
        EU.onFocus = EU.addFocusListener;

        /**
         * YAHOO.util.Event.onBlur is an alias for addBlurListener
         * @method onBlur
         * @see addBlurListener
         * @static
         * @deprecated use YAHOO.util.Event.on and specify "focusout" as the event type.
         */
        EU.onBlur = EU.addBlurListener;

/*! DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller/Diego Perini */

        // Internet Explorer: use the readyState of a defered script.
        // This isolates what appears to be a safe moment to manipulate
        // the DOM prior to when the document's readyState suggests
        // it is safe to do so.
        if (EU.isIE) {
            if (self !== self.top) {
                document.onreadystatechange = function() {
                    if (document.readyState == 'complete') {
                        document.onreadystatechange = null;
                        EU._ready();
                    }
                };
            } else {

                // Process onAvailable/onContentReady items when the
                // DOM is ready.
                YAHOO.util.Event.onDOMReady(
                        YAHOO.util.Event._tryPreloadAttach,
                        YAHOO.util.Event, true);

                var n = document.createElement('p');

                EU._dri = setInterval(function() {
                    try {
                        // throws an error if doc is not ready
                        n.doScroll('left');
                        clearInterval(EU._dri);
                        EU._dri = null;
                        EU._ready();
                        n = null;
                    } catch (ex) {
                    }
                }, EU.POLL_INTERVAL);
            }

        // The document's readyState in Safari currently will
        // change to loaded/complete before images are loaded.
        } else if (EU.webkit && EU.webkit < 525) {

            EU._dri = setInterval(function() {
                var rs=document.readyState;
                if ("loaded" == rs || "complete" == rs) {
                    clearInterval(EU._dri);
                    EU._dri = null;
                    EU._ready();
                }
            }, EU.POLL_INTERVAL);

        // FireFox and Opera: These browsers provide a event for this
        // moment.  The latest WebKit releases now support this event.
        } else {

            EU._simpleAdd(document, "DOMContentLoaded", EU._ready);

        }
        /////////////////////////////////////////////////////////////


        EU._simpleAdd(window, "load", EU._load);
        EU._simpleAdd(window, "unload", EU._unload);
        EU._tryPreloadAttach();
    })();

}
/**
 * EventProvider is designed to be used with YAHOO.augment to wrap
 * CustomEvents in an interface that allows events to be subscribed to
 * and fired by name.  This makes it possible for implementing code to
 * subscribe to an event that either has not been created yet, or will
 * not be created at all.
 *
 * @Class EventProvider
 */
YAHOO.util.EventProvider = function() { };

YAHOO.util.EventProvider.prototype = {

    /**
     * Private storage of custom events
     * @property __yui_events
     * @type Object[]
     * @private
     */
    __yui_events: null,

    /**
     * Private storage of custom event subscribers
     * @property __yui_subscribers
     * @type Object[]
     * @private
     */
    __yui_subscribers: null,

    /**
     * Subscribe to a CustomEvent by event type
     *
     * @method subscribe
     * @param p_type     {string}   the type, or name of the event
     * @param p_fn       {function} the function to exectute when the event fires
     * @param p_obj      {Object}   An object to be passed along when the event
     *                              fires
     * @param overrideContext {boolean}  If true, the obj passed in becomes the
     *                              execution scope of the listener
     */
    subscribe: function(p_type, p_fn, p_obj, overrideContext) {

        this.__yui_events = this.__yui_events || {};
        var ce = this.__yui_events[p_type];

        if (ce) {
            ce.subscribe(p_fn, p_obj, overrideContext);
        } else {
            this.__yui_subscribers = this.__yui_subscribers || {};
            var subs = this.__yui_subscribers;
            if (!subs[p_type]) {
                subs[p_type] = [];
            }
            subs[p_type].push(
                { fn: p_fn, obj: p_obj, overrideContext: overrideContext } );
        }
    },

    /**
     * Unsubscribes one or more listeners the from the specified event
     * @method unsubscribe
     * @param p_type {string}   The type, or name of the event.  If the type
     *                          is not specified, it will attempt to remove
     *                          the listener from all hosted events.
     * @param p_fn   {Function} The subscribed function to unsubscribe, if not
     *                          supplied, all subscribers will be removed.
     * @param p_obj  {Object}   The custom object passed to subscribe.  This is
     *                        optional, but if supplied will be used to
     *                        disambiguate multiple listeners that are the same
     *                        (e.g., you subscribe many object using a function
     *                        that lives on the prototype)
     * @return {boolean} true if the subscriber was found and detached.
     */
    unsubscribe: function(p_type, p_fn, p_obj) {
        this.__yui_events = this.__yui_events || {};
        var evts = this.__yui_events;
        if (p_type) {
            var ce = evts[p_type];
            if (ce) {
                return ce.unsubscribe(p_fn, p_obj);
            }
        } else {
            var ret = true;
            for (var i in evts) {
                if (YAHOO.lang.hasOwnProperty(evts, i)) {
                    ret = ret && evts[i].unsubscribe(p_fn, p_obj);
                }
            }
            return ret;
        }

        return false;
    },

    /**
     * Removes all listeners from the specified event.  If the event type
     * is not specified, all listeners from all hosted custom events will
     * be removed.
     * @method unsubscribeAll
     * @param p_type {string}   The type, or name of the event
     */
    unsubscribeAll: function(p_type) {
        return this.unsubscribe(p_type);
    },

    /**
     * Creates a new custom event of the specified type.  If a custom event
     * by that name already exists, it will not be re-created.  In either
     * case the custom event is returned.
     *
     * @method createEvent
     *
     * @param p_type {string} the type, or name of the event
     * @param p_config {object} optional config params.  Valid properties are:
     *
     *  <ul>
     *    <li>
     *      scope: defines the default execution scope.  If not defined
     *      the default scope will be this instance.
     *    </li>
     *    <li>
     *      silent: if true, the custom event will not generate log messages.
     *      This is false by default.
     *    </li>
     *    <li>
     *      fireOnce: if true, the custom event will only notify subscribers
     *      once regardless of the number of times the event is fired.  In
     *      addition, new subscribers will be executed immediately if the
     *      event has already fired.
     *      This is false by default.
     *    </li>
     *    <li>
     *      onSubscribeCallback: specifies a callback to execute when the
     *      event has a new subscriber.  This will fire immediately for
     *      each queued subscriber if any exist prior to the creation of
     *      the event.
     *    </li>
     *  </ul>
     *
     *  @return {CustomEvent} the custom event
     *
     */
    createEvent: function(p_type, p_config) {

        this.__yui_events = this.__yui_events || {};
        var opts = p_config || {},
            events = this.__yui_events, ce;

        if (events[p_type]) {
        } else {

            ce = new YAHOO.util.CustomEvent(p_type, opts.scope || this, opts.silent,
                         YAHOO.util.CustomEvent.FLAT, opts.fireOnce);

            events[p_type] = ce;

            if (opts.onSubscribeCallback) {
                ce.subscribeEvent.subscribe(opts.onSubscribeCallback);
            }

            this.__yui_subscribers = this.__yui_subscribers || {};
            var qs = this.__yui_subscribers[p_type];

            if (qs) {
                for (var i=0; i<qs.length; ++i) {
                    ce.subscribe(qs[i].fn, qs[i].obj, qs[i].overrideContext);
                }
            }
        }

        return events[p_type];
    },


   /**
     * Fire a custom event by name.  The callback functions will be executed
     * from the scope specified when the event was created, and with the
     * following parameters:
     *   <ul>
     *   <li>The first argument fire() was executed with</li>
     *   <li>The custom object (if any) that was passed into the subscribe()
     *       method</li>
     *   </ul>
     * @method fireEvent
     * @param p_type    {string}  the type, or name of the event
     * @param arguments {Object*} an arbitrary set of parameters to pass to
     *                            the handler.
     * @return {boolean} the return value from CustomEvent.fire
     *
     */
    fireEvent: function(p_type) {

        this.__yui_events = this.__yui_events || {};
        var ce = this.__yui_events[p_type];

        if (!ce) {
            return null;
        }

        var args = [];
        for (var i=1; i<arguments.length; ++i) {
            args.push(arguments[i]);
        }
        return ce.fire.apply(ce, args);
    },

    /**
     * Returns true if the custom event of the provided type has been created
     * with createEvent.
     * @method hasEvent
     * @param type {string} the type, or name of the event
     */
    hasEvent: function(type) {
        if (this.__yui_events) {
            if (this.__yui_events[type]) {
                return true;
            }
        }
        return false;
    }

};

(function() {

    var Event = YAHOO.util.Event, Lang = YAHOO.lang;

/**
* KeyListener is a utility that provides an easy interface for listening for
* keydown/keyup events fired against DOM elements.
* @namespace YAHOO.util
* @class KeyListener
* @constructor
* @param {HTMLElement} attachTo The element or element ID to which the key
*                               event should be attached
* @param {String}      attachTo The element or element ID to which the key
*                               event should be attached
* @param {Object}      keyData  The object literal representing the key(s)
*                               to detect. Possible attributes are
*                               shift(boolean), alt(boolean), ctrl(boolean)
*                               and keys(either an int or an array of ints
*                               representing keycodes).
* @param {Function}    handler  The CustomEvent handler to fire when the
*                               key event is detected
* @param {Object}      handler  An object literal representing the handler.
* @param {String}      event    Optional. The event (keydown or keyup) to
*                               listen for. Defaults automatically to keydown.
*
* @knownissue the "keypress" event is completely broken in Safari 2.x and below.
*             the workaround is use "keydown" for key listening.  However, if
*             it is desired to prevent the default behavior of the keystroke,
*             that can only be done on the keypress event.  This makes key
*             handling quite ugly.
* @knownissue keydown is also broken in Safari 2.x and below for the ESC key.
*             There currently is no workaround other than choosing another
*             key to listen for.
*/
YAHOO.util.KeyListener = function(attachTo, keyData, handler, event) {
    if (!attachTo) {
    } else if (!keyData) {
    } else if (!handler) {
    }

    if (!event) {
        event = YAHOO.util.KeyListener.KEYDOWN;
    }

    /**
    * The CustomEvent fired internally when a key is pressed
    * @event keyEvent
    * @private
    * @param {Object} keyData The object literal representing the key(s) to
    *                         detect. Possible attributes are shift(boolean),
    *                         alt(boolean), ctrl(boolean) and keys(either an
    *                         int or an array of ints representing keycodes).
    */
    var keyEvent = new YAHOO.util.CustomEvent("keyPressed");

    /**
    * The CustomEvent fired when the KeyListener is enabled via the enable()
    * function
    * @event enabledEvent
    * @param {Object} keyData The object literal representing the key(s) to
    *                         detect. Possible attributes are shift(boolean),
    *                         alt(boolean), ctrl(boolean) and keys(either an
    *                         int or an array of ints representing keycodes).
    */
    this.enabledEvent = new YAHOO.util.CustomEvent("enabled");

    /**
    * The CustomEvent fired when the KeyListener is disabled via the
    * disable() function
    * @event disabledEvent
    * @param {Object} keyData The object literal representing the key(s) to
    *                         detect. Possible attributes are shift(boolean),
    *                         alt(boolean), ctrl(boolean) and keys(either an
    *                         int or an array of ints representing keycodes).
    */
    this.disabledEvent = new YAHOO.util.CustomEvent("disabled");

    if (Lang.isString(attachTo)) {
        attachTo = document.getElementById(attachTo); // No Dom util
    }

    if (Lang.isFunction(handler)) {
        keyEvent.subscribe(handler);
    } else {
        keyEvent.subscribe(handler.fn, handler.scope, handler.correctScope);
    }

    /**
    * Handles the key event when a key is pressed.
    * @method handleKeyPress
    * @param {DOMEvent} e   The keypress DOM event
    * @param {Object}   obj The DOM event scope object
    * @private
    */
    function handleKeyPress(e, obj) {
        if (! keyData.shift) {
            keyData.shift = false;
        }
        if (! keyData.alt) {
            keyData.alt = false;
        }
        if (! keyData.ctrl) {
            keyData.ctrl = false;
        }

        // check held down modifying keys first
        if (e.shiftKey == keyData.shift &&
            e.altKey   == keyData.alt &&
            e.ctrlKey  == keyData.ctrl) { // if we pass this, all modifiers match

            var dataItem, keys = keyData.keys, key;

            if (YAHOO.lang.isArray(keys)) {
                for (var i=0;i<keys.length;i++) {
                    dataItem = keys[i];
                    key = Event.getCharCode(e);

                    if (dataItem == key) {
                        keyEvent.fire(key, e);
                        break;
                    }
                }
            } else {
                key = Event.getCharCode(e);
                if (keys == key ) {
                    keyEvent.fire(key, e);
                }
            }
        }
    }

    /**
    * Enables the KeyListener by attaching the DOM event listeners to the
    * target DOM element
    * @method enable
    */
    this.enable = function() {
        if (! this.enabled) {
            Event.on(attachTo, event, handleKeyPress);
            this.enabledEvent.fire(keyData);
        }
        /**
        * Boolean indicating the enabled/disabled state of the Tooltip
        * @property enabled
        * @type Boolean
        */
        this.enabled = true;
    };

    /**
    * Disables the KeyListener by removing the DOM event listeners from the
    * target DOM element
    * @method disable
    */
    this.disable = function() {
        if (this.enabled) {
            Event.removeListener(attachTo, event, handleKeyPress);
            this.disabledEvent.fire(keyData);
        }
        this.enabled = false;
    };

    /**
    * Returns a String representation of the object.
    * @method toString
    * @return {String}  The string representation of the KeyListener
    */
    this.toString = function() {
        return "KeyListener [" + keyData.keys + "] " + attachTo.tagName +
                (attachTo.id ? "[" + attachTo.id + "]" : "");
    };

};

var KeyListener = YAHOO.util.KeyListener;

/**
 * Constant representing the DOM "keydown" event.
 * @property YAHOO.util.KeyListener.KEYDOWN
 * @static
 * @final
 * @type String
 */
KeyListener.KEYDOWN = "keydown";

/**
 * Constant representing the DOM "keyup" event.
 * @property YAHOO.util.KeyListener.KEYUP
 * @static
 * @final
 * @type String
 */
KeyListener.KEYUP = "keyup";

/**
 * keycode constants for a subset of the special keys
 * @property KEY
 * @static
 * @final
 */
KeyListener.KEY = {
    ALT          : 18,
    BACK_SPACE   : 8,
    CAPS_LOCK    : 20,
    CONTROL      : 17,
    DELETE       : 46,
    DOWN         : 40,
    END          : 35,
    ENTER        : 13,
    ESCAPE       : 27,
    HOME         : 36,
    LEFT         : 37,
    META         : 224,
    NUM_LOCK     : 144,
    PAGE_DOWN    : 34,
    PAGE_UP      : 33,
    PAUSE        : 19,
    PRINTSCREEN  : 44,
    RIGHT        : 39,
    SCROLL_LOCK  : 145,
    SHIFT        : 16,
    SPACE        : 32,
    TAB          : 9,
    UP           : 38
};

})();
YAHOO.register("event", YAHOO.util.Event, {version: "2.9.0", build: "2800"});
/*
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 * @module dragdrop
 * @title Drag and Drop
 * @requires yahoo,dom,event
 * @namespace YAHOO.util
 */

// Only load the library once.  Rewriting the manager class would orphan 
// existing drag and drop instances.
if (!YAHOO.util.DragDropMgr) {

/**
 * DragDropMgr is a singleton that tracks the element interaction for 
 * all DragDrop items in the window.  Generally, you will not call 
 * this class directly, but it does have helper methods that could 
 * be useful in your DragDrop implementations.
 * @class DragDropMgr
 * @static
 */
YAHOO.util.DragDropMgr = function() {

    var Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom;

    return {
        /**
        * This property is used to turn on global use of the shim element on all DragDrop instances, defaults to false for backcompat. (Use: YAHOO.util.DDM.useShim = true)
        * @property useShim
        * @type Boolean
        * @static
        */
        useShim: false,
        /**
        * This property is used to determine if the shim is active over the screen, default false.
        * @private
        * @property _shimActive
        * @type Boolean
        * @static
        */
        _shimActive: false,
        /**
        * This property is used when useShim is set on a DragDrop object to store the current state of DDM.useShim so it can be reset when a drag operation is done.
        * @private
        * @property _shimState
        * @type Boolean
        * @static
        */
        _shimState: false,
        /**
        * This property is used when useShim is set to true, it will set the opacity on the shim to .5 for debugging. Use: (YAHOO.util.DDM._debugShim = true;)
        * @private
        * @property _debugShim
        * @type Boolean
        * @static
        */
        _debugShim: false,
        /**
        * This method will create a shim element (giving it the id of yui-ddm-shim), it also attaches the mousemove and mouseup listeners to it and attaches a scroll listener on the window
        * @private
        * @method _sizeShim
        * @static
        */
        _createShim: function() {
            var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            Dom.setStyle(s, 'opacity', '0');
            this._shim = s;
            Event.on(s, "mouseup",   this.handleMouseUp, this, true);
            Event.on(s, "mousemove", this.handleMouseMove, this, true);
            Event.on(window, 'scroll', this._sizeShim, this, true);
        },
        /**
        * This method will size the shim, called from activate and on window scroll event
        * @private
        * @method _sizeShim
        * @static
        */
        _sizeShim: function() {
            if (this._shimActive) {
                var s = this._shim;
                s.style.height = Dom.getDocumentHeight() + 'px';
                s.style.width = Dom.getDocumentWidth() + 'px';
                s.style.top = '0';
                s.style.left = '0';
            }
        },
        /**
        * This method will create the shim element if needed, then show the shim element, size the element and set the _shimActive property to true
        * @private
        * @method _activateShim
        * @static
        */
        _activateShim: function() {
            if (this.useShim) {
                if (!this._shim) {
                    this._createShim();
                }
                this._shimActive = true;
                var s = this._shim,
                    o = '0';
                if (this._debugShim) {
                    o = '.5';
                }
                Dom.setStyle(s, 'opacity', o);
                this._sizeShim();
                s.style.display = 'block';
            }
        },
        /**
        * This method will hide the shim element and set the _shimActive property to false
        * @private
        * @method _deactivateShim
        * @static
        */
        _deactivateShim: function() {
            this._shim.style.display = 'none';
            this._shimActive = false;
        },
        /**
        * The HTML element created to use as a shim over the document to track mouse movements
        * @private
        * @property _shim
        * @type HTMLElement
        * @static
        */
        _shim: null,
        /**
         * Two dimensional Array of registered DragDrop objects.  The first 
         * dimension is the DragDrop item group, the second the DragDrop 
         * object.
         * @property ids
         * @type {string: string}
         * @private
         * @static
         */
        ids: {},

        /**
         * Array of element ids defined as drag handles.  Used to determine 
         * if the element that generated the mousedown event is actually the 
         * handle and not the html element itself.
         * @property handleIds
         * @type {string: string}
         * @private
         * @static
         */
        handleIds: {},

        /**
         * the DragDrop object that is currently being dragged
         * @property dragCurrent
         * @type DragDrop
         * @private
         * @static
         **/
        dragCurrent: null,

        /**
         * the DragDrop object(s) that are being hovered over
         * @property dragOvers
         * @type Array
         * @private
         * @static
         */
        dragOvers: {},

        /**
         * the X distance between the cursor and the object being dragged
         * @property deltaX
         * @type int
         * @private
         * @static
         */
        deltaX: 0,

        /**
         * the Y distance between the cursor and the object being dragged
         * @property deltaY
         * @type int
         * @private
         * @static
         */
        deltaY: 0,

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to 
         * false if you need the default behavior (not recommended)
         * @property preventDefault
         * @type boolean
         * @static
         */
        preventDefault: true,

        /**
         * Flag to determine if we should stop the propagation of the events 
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         * @property stopPropagation
         * @type boolean
         * @static
         */
        stopPropagation: true,

        /**
         * Internal flag that is set to true when drag and drop has been
         * initialized
         * @property initialized
         * @private
         * @static
         */
        initialized: false,

        /**
         * All drag and drop can be disabled.
         * @property locked
         * @private
         * @static
         */
        locked: false,

        /**
         * Provides additional information about the the current set of
         * interactions.  Can be accessed from the event handlers. It
         * contains the following properties:
         *
         *       out:       onDragOut interactions
         *       enter:     onDragEnter interactions
         *       over:      onDragOver interactions
         *       drop:      onDragDrop interactions
         *       point:     The location of the cursor
         *       draggedRegion: The location of dragged element at the time
         *                      of the interaction
         *       sourceRegion: The location of the source elemtn at the time
         *                     of the interaction
         *       validDrop: boolean
         * @property interactionInfo
         * @type object
         * @static
         */
        interactionInfo: null,

        /**
         * Called the first time an element is registered.
         * @method init
         * @private
         * @static
         */
        init: function() {
            this.initialized = true;
        },

        /**
         * In point mode, drag and drop interaction is defined by the 
         * location of the cursor during the drag/drop
         * @property POINT
         * @type int
         * @static
         * @final
         */
        POINT: 0,

        /**
         * In intersect mode, drag and drop interaction is defined by the 
         * cursor position or the amount of overlap of two or more drag and 
         * drop objects.
         * @property INTERSECT
         * @type int
         * @static
         * @final
         */
        INTERSECT: 1,

        /**
         * In intersect mode, drag and drop interaction is defined only by the 
         * overlap of two or more drag and drop objects.
         * @property STRICT_INTERSECT
         * @type int
         * @static
         * @final
         */
        STRICT_INTERSECT: 2,

        /**
         * The current drag and drop mode.  Default: POINT
         * @property mode
         * @type int
         * @static
         */
        mode: 0,

        /**
         * Runs method on all drag and drop objects
         * @method _execOnAll
         * @private
         * @static
         */
        _execOnAll: function(sMethod, args) {
            for (var i in this.ids) {
                for (var j in this.ids[i]) {
                    var oDD = this.ids[i][j];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }
                    oDD[sMethod].apply(oDD, args);
                }
            }
        },

        /**
         * Drag and drop initialization.  Sets up the global event handlers
         * @method _onLoad
         * @private
         * @static
         */
        _onLoad: function() {

            this.init();

            Event.on(document, "mouseup",   this.handleMouseUp, this, true);
            Event.on(document, "mousemove", this.handleMouseMove, this, true);
            Event.on(window,   "unload",    this._onUnload, this, true);
            Event.on(window,   "resize",    this._onResize, this, true);
            // Event.on(window,   "mouseout",    this._test);

        },

        /**
         * Reset constraints on all drag and drop objs
         * @method _onResize
         * @private
         * @static
         */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
         * Lock all drag and drop functionality
         * @method lock
         * @static
         */
        lock: function() { this.locked = true; },

        /**
         * Unlock all drag and drop functionality
         * @method unlock
         * @static
         */
        unlock: function() { this.locked = false; },

        /**
         * Is drag and drop locked?
         * @method isLocked
         * @return {boolean} True if drag and drop is locked, false otherwise.
         * @static
         */
        isLocked: function() { return this.locked; },

        /**
         * Location cache that is set for all drag drop objects when a drag is
         * initiated, cleared when the drag is finished.
         * @property locationCache
         * @private
         * @static
         */
        locationCache: {},

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * @property useCache
         * @type boolean
         * @static
         */
        useCache: true,

        /**
         * The number of pixels that the mouse needs to move after the 
         * mousedown before the drag is initiated.  Default=3;
         * @property clickPixelThresh
         * @type int
         * @static
         */
        clickPixelThresh: 3,

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * @property clickTimeThresh
         * @type int
         * @static
         */
        clickTimeThresh: 1000,

        /**
         * Flag that indicates that either the drag pixel threshold or the 
         * mousdown time threshold has been met
         * @property dragThreshMet
         * @type boolean
         * @private
         * @static
         */
        dragThreshMet: false,

        /**
         * Timeout used for the click time threshold
         * @property clickTimeout
         * @type Object
         * @private
         * @static
         */
        clickTimeout: null,

        /**
         * The X position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startX
         * @type int
         * @private
         * @static
         */
        startX: 0,

        /**
         * The Y position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startY
         * @type int
         * @private
         * @static
         */
        startY: 0,

        /**
         * Flag to determine if the drag event was fired from the click timeout and
         * not the mouse move threshold.
         * @property fromTimeout
         * @type boolean
         * @private
         * @static
         */
        fromTimeout: false,

        /**
         * Each DragDrop instance must be registered with the DragDropMgr.  
         * This is executed in DragDrop.init()
         * @method regDragDrop
         * @param {DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         * @static
         */
        regDragDrop: function(oDD, sGroup) {
            if (!this.initialized) { this.init(); }
            
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }
            this.ids[sGroup][oDD.id] = oDD;
        },

        /**
         * Removes the supplied dd instance from the supplied group. Executed
         * by DragDrop.removeFromGroup, so don't call this function directly.
         * @method removeDDFromGroup
         * @private
         * @static
         */
        removeDDFromGroup: function(oDD, sGroup) {
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }

            var obj = this.ids[sGroup];
            if (obj && obj[oDD.id]) {
                delete obj[oDD.id];
            }
        },

        /**
         * Unregisters a drag and drop item.  This is executed in 
         * DragDrop.unreg, use that method instead of calling this directly.
         * @method _remove
         * @private
         * @static
         */
        _remove: function(oDD) {
            for (var g in oDD.groups) {
                if (g) {
                    var item = this.ids[g];
                    if (item && item[oDD.id]) {
                        delete item[oDD.id];
                    }
                }
                
            }
            delete this.handleIds[oDD.id];
        },

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @method regHandle
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag 
         * handle
         * @static
         */
        regHandle: function(sDDId, sHandleId) {
            if (!this.handleIds[sDDId]) {
                this.handleIds[sDDId] = {};
            }
            this.handleIds[sDDId][sHandleId] = sHandleId;
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop item.
         * @method isDragDrop
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop item, 
         * false otherwise
         * @static
         */
        isDragDrop: function(id) {
            return ( this.getDDById(id) ) ? true : false;
        },

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @method getRelated
         * @param {DragDrop} p_oDD the obj to get related data for
         * @param {boolean} bTargetsOnly if true, only return targetable objs
         * @return {DragDrop[]} the related instances
         * @static
         */
        getRelated: function(p_oDD, bTargetsOnly) {
            var oDDs = [];
            for (var i in p_oDD.groups) {
                for (var j in this.ids[i]) {
                    var dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            return oDDs;
        },

        /**
         * Returns true if the specified dd target is a legal target for 
         * the specifice drag obj
         * @method isLegalTarget
         * @param {DragDrop} the drag obj
         * @param {DragDrop} the target
         * @return {boolean} true if the target is a legal target for the 
         * dd obj
         * @static
         */
        isLegalTarget: function (oDD, oTargetDD) {
            var targets = this.getRelated(oDD, true);
            for (var i=0, len=targets.length;i<len;++i) {
                if (targets[i].id == oTargetDD.id) {
                    return true;
                }
            }

            return false;
        },

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof 
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @method isTypeOfDD
         * @param {Object} the object to evaluate
         * @return {boolean} true if typeof oDD = DragDrop
         * @static
         */
        isTypeOfDD: function (oDD) {
            return (oDD && oDD.__ygDragDrop);
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop handle for the given Drag Drop object.
         * @method isHandle
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop handle, false 
         * otherwise
         * @static
         */
        isHandle: function(sDDId, sHandleId) {
            return ( this.handleIds[sDDId] && 
                            this.handleIds[sDDId][sHandleId] );
        },

        /**
         * Returns the DragDrop instance for a given id
         * @method getDDById
         * @param {String} id the id of the DragDrop object
         * @return {DragDrop} the drag drop object, null if it is not found
         * @static
         */
        getDDById: function(id) {
            for (var i in this.ids) {
                if (this.ids[i][id]) {
                    return this.ids[i][id];
                }
            }
            return null;
        },

        /**
         * Fired after a registered DragDrop object gets the mousedown event.
         * Sets up the events required to track the object being dragged
         * @method handleMouseDown
         * @param {Event} e the event
         * @param oDD the DragDrop object being dragged
         * @private
         * @static
         */
        handleMouseDown: function(e, oDD) {
            //this._activateShim();

            this.currentTarget = YAHOO.util.Event.getTarget(e);

            this.dragCurrent = oDD;

            var el = oDD.getEl();

            // track start position
            this.startX = YAHOO.util.Event.getPageX(e);
            this.startY = YAHOO.util.Event.getPageY(e);

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout( 
                    function() { 
                        var DDM = YAHOO.util.DDM;
                        DDM.startDrag(DDM.startX, DDM.startY);
                        DDM.fromTimeout = true;
                    }, 
                    this.clickTimeThresh );
        },

        /**
         * Fired when either the drag pixel threshold or the mousedown hold 
         * time threshold has been met.
         * @method startDrag
         * @param x {int} the X position of the original mousedown
         * @param y {int} the Y position of the original mousedown
         * @static
         */
        startDrag: function(x, y) {
            if (this.dragCurrent && this.dragCurrent.useShim) {
                this._shimState = this.useShim;
                this.useShim = true;
            }
            this._activateShim();
            clearTimeout(this.clickTimeout);
            var dc = this.dragCurrent;
            if (dc && dc.events.b4StartDrag) {
                dc.b4StartDrag(x, y);
                dc.fireEvent('b4StartDragEvent', { x: x, y: y });
            }
            if (dc && dc.events.startDrag) {
                dc.startDrag(x, y);
                dc.fireEvent('startDragEvent', { x: x, y: y });
            }
            this.dragThreshMet = true;
        },

        /**
         * Internal function to handle the mouseup event.  Will be invoked 
         * from the context of the document.
         * @method handleMouseUp
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseUp: function(e) {
            if (this.dragCurrent) {
                clearTimeout(this.clickTimeout);

                if (this.dragThreshMet) {
                    if (this.fromTimeout) {
                        this.fromTimeout = false;
                        this.handleMouseMove(e);
                    }
                    this.fromTimeout = false;
                    this.fireEvents(e, true);
                } else {
                }

                this.stopDrag(e);

                this.stopEvent(e);
            }
        },

        /**
         * Utility to stop event propagation and event default, if these 
         * features are turned on.
         * @method stopEvent
         * @param {Event} e the event as returned by this.getEvent()
         * @static
         */
        stopEvent: function(e) {
            if (this.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            if (this.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        },

        /** 
         * Ends the current drag, cleans up the state, and fires the endDrag
         * and mouseUp events.  Called internally when a mouseup is detected
         * during the drag.  Can be fired manually during the drag by passing
         * either another event (such as the mousemove event received in onDrag)
         * or a fake event with pageX and pageY defined (so that endDrag and
         * onMouseUp have usable position data.).  Alternatively, pass true
         * for the silent parameter so that the endDrag and onMouseUp events
         * are skipped (so no event data is needed.)
         *
         * @method stopDrag
         * @param {Event} e the mouseup event, another event (or a fake event) 
         *                  with pageX and pageY defined, or nothing if the 
         *                  silent parameter is true
         * @param {boolean} silent skips the enddrag and mouseup events if true
         * @static
         */
        stopDrag: function(e, silent) {
            var dc = this.dragCurrent;
            // Fire the drag end event for the item that was dragged
            if (dc && !silent) {
                if (this.dragThreshMet) {
                    if (dc.events.b4EndDrag) {
                        dc.b4EndDrag(e);
                        dc.fireEvent('b4EndDragEvent', { e: e });
                    }
                    if (dc.events.endDrag) {
                        dc.endDrag(e);
                        dc.fireEvent('endDragEvent', { e: e });
                    }
                }
                if (dc.events.mouseUp) {
                    dc.onMouseUp(e);
                    dc.fireEvent('mouseUpEvent', { e: e });
                }
            }

            if (this._shimActive) {
                this._deactivateShim();
                if (this.dragCurrent && this.dragCurrent.useShim) {
                    this.useShim = this._shimState;
                    this._shimState = false;
                }
            }

            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /** 
         * Internal function to handle the mousemove event.  Will be invoked 
         * from the context of the html element.
         *
         * @TODO figure out what we can do about mouse events lost when the 
         * user drags objects beyond the window boundary.  Currently we can 
         * detect this in internet explorer by verifying that the mouse is 
         * down during the mousemove event.  Firefox doesn't give us the 
         * button state on the mousemove event.
         * @method handleMouseMove
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseMove: function(e) {

            var dc = this.dragCurrent;
            if (dc) {

                // var button = e.which || e.button;

                // check for IE < 9 mouseup outside of page boundary
                if (YAHOO.env.ua.ie && (YAHOO.env.ua.ie < 9) && !e.button) {
                    this.stopEvent(e);
                    return this.handleMouseUp(e);
                } else {
                    if (e.clientX < 0 || e.clientY < 0) {
                        //This will stop the element from leaving the viewport in FF, Opera & Safari
                        //Not turned on yet
                        //this.stopEvent(e);
                        //return false;
                    }
                }

                if (!this.dragThreshMet) {
                    var diffX = Math.abs(this.startX - YAHOO.util.Event.getPageX(e));
                    var diffY = Math.abs(this.startY - YAHOO.util.Event.getPageY(e));
                    if (diffX > this.clickPixelThresh || 
                                diffY > this.clickPixelThresh) {
                        this.startDrag(this.startX, this.startY);
                    }
                }

                if (this.dragThreshMet) {
                    if (dc && dc.events.b4Drag) {
                        dc.b4Drag(e);
                        dc.fireEvent('b4DragEvent', { e: e});
                    }
                    if (dc && dc.events.drag) {
                        dc.onDrag(e);
                        dc.fireEvent('dragEvent', { e: e});
                    }
                    if (dc) {
                        this.fireEvents(e, false);
                    }
                }

                this.stopEvent(e);
            }
        },
        
        /**
         * Iterates over all of the DragDrop elements to find ones we are 
         * hovering over or dropping on
         * @method fireEvents
         * @param {Event} e the event
         * @param {boolean} isDrop is this a drop op or a mouseover op?
         * @private
         * @static
         */
        fireEvents: function(e, isDrop) {
            var dc = this.dragCurrent;

            // If the user did the mouse up outside of the window, we could 
            // get here even though we have ended the drag.
            // If the config option dragOnly is true, bail out and don't fire the events
            if (!dc || dc.isLocked() || dc.dragOnly) {
                return;
            }

            //lorsqu'on fait deplacer le splitter , il faut calculer le x par rapport au nouveau repre .            
            if (YAHOO.util.Event.isIE ) {
              var x = YAHOO.util.Event.getPageX(e) - e.offsetX - g_vertical_splitter_left ;
            } else{
              var x = YAHOO.util.Event.getPageX(e) - e.layerX  - g_vertical_splitter_left ;
            }

            var //x = YAHOO.util.Event.getPageX(e),
                y = YAHOO.util.Event.getPageY(e),
                pt = new YAHOO.util.Point(x,y),
                pos = dc.getTargetCoord(pt.x, pt.y),
                el = dc.getDragEl(),
                events = ['out', 'over', 'drop', 'enter'],
                curRegion = new YAHOO.util.Region( pos.y, 
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight, 
                                               pos.x ),
            
                oldOvers = [], // cache the previous dragOver array
                inGroupsObj  = {},
                b4Results = {},
                inGroups  = [],
                data = {
                    outEvts: [],
                    overEvts: [],
                    dropEvts: [],
                    enterEvts: []
                };


            // Check to see if the object(s) we were hovering over is no longer 
            // being hovered over so we can fire the onDragOut event
            for (var i in this.dragOvers) {

                var ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }
                if (! this.isOverTarget(pt, ddo, this.mode, curRegion)) {
                    data.outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete this.dragOvers[i];
            }

            for (var sGroup in dc.groups) {
                
                if ("string" != typeof sGroup) {
                    continue;
                }

                for (i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }

                    if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
                        if (this.isOverTarget(pt, oDD, this.mode, curRegion)) {
                            inGroupsObj[sGroup] = true;
                            // look for drop interactions
                            if (isDrop) {
                                data.dropEvts.push( oDD );
                            // look for drag enter and drag over interactions
                            } else {

                                // initial drag over: dragEnter fires
                                if (!oldOvers[oDD.id]) {
                                    data.enterEvts.push( oDD );
                                // subsequent drag overs: dragOver fires
                                } else {
                                    data.overEvts.push( oDD );
                                }

                                this.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            this.interactionInfo = {
                out:       data.outEvts,
                enter:     data.enterEvts,
                over:      data.overEvts,
                drop:      data.dropEvts,
                point:     pt,
                draggedRegion:    curRegion,
                sourceRegion: this.locationCache[dc.id],
                validDrop: isDrop
            };

            
            for (var inG in inGroupsObj) {
                inGroups.push(inG);
            }

            // notify about a drop that did not find a target
            if (isDrop && !data.dropEvts.length) {
                this.interactionInfo.validDrop = false;
                if (dc.events.invalidDrop) {
                    dc.onInvalidDrop(e);
                    dc.fireEvent('invalidDropEvent', { e: e });
                }
            }
            for (i = 0; i < events.length; i++) {
                var tmp = null;
                if (data[events[i] + 'Evts']) {
                    tmp = data[events[i] + 'Evts'];
                }
                if (tmp && tmp.length) {
                    var type = events[i].charAt(0).toUpperCase() + events[i].substr(1),
                        ev = 'onDrag' + type,
                        b4 = 'b4Drag' + type,
                        cev = 'drag' + type + 'Event',
                        check = 'drag' + type;
                    if (this.mode) {
                        if (dc.events[b4]) {
                            dc[b4](e, tmp, inGroups);
                            b4Results[ev] = dc.fireEvent(b4 + 'Event', { event: e, info: tmp, group: inGroups });
                            
                        }
                        if (dc.events[check] && (b4Results[ev] !== false)) {
                            dc[ev](e, tmp, inGroups);
                            dc.fireEvent(cev, { event: e, info: tmp, group: inGroups });
                        }
                    } else {
                        for (var b = 0, len = tmp.length; b < len; ++b) {
                            if (dc.events[b4]) {
                                dc[b4](e, tmp[b].id, inGroups[0]);
                                b4Results[ev] = dc.fireEvent(b4 + 'Event', { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                            if (dc.events[check] && (b4Results[ev] !== false)) {
                                dc[ev](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(cev, { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                        }
                    }
                }
            }
        },

        /**
         * Helper function for getting the best match from the list of drag 
         * and drop objects returned by the drag and drop events when we are 
         * in INTERSECT mode.  It returns either the first object that the 
         * cursor is over, or the object that has the greatest overlap with 
         * the dragged element.
         * @method getBestMatch
         * @param  {DragDrop[]} dds The array of drag and drop objects 
         * targeted
         * @return {DragDrop}       The best single match
         * @static
         */
        getBestMatch: function(dds) {
            var winner = null;

            var len = dds.length;

            if (len == 1) {
                winner = dds[0];
            } else {
                // Loop through the targeted items
                for (var i=0; i<len; ++i) {
                    var dd = dds[i];
                    // If the cursor is over the object, it wins.  If the 
                    // cursor is over multiple matches, the first one we come
                    // to wins.
                    if (this.mode == this.INTERSECT && dd.cursorIsOver) {
                        winner = dd;
                        break;
                    // Otherwise the object with the most overlap wins
                    } else {
                        if (!winner || !winner.overlap || (dd.overlap &&
                            winner.overlap.getArea() < dd.overlap.getArea())) {
                            winner = dd;
                        }
                    }
                }
            }

            return winner;
        },

        /**
         * Refreshes the cache of the top-left and bottom-right points of the 
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical 
         * usage is:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
         * Alternatively:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
         * @TODO this really should be an indexed array.  Alternatively this
         * method could accept both.
         * @method refreshCache
         * @param {Object} groups an associative array of groups to refresh
         * @static
         */
        refreshCache: function(groups) {

            // refresh everything if group array is not provided
            var g = groups || this.ids;

            for (var sGroup in g) {
                if ("string" != typeof sGroup) {
                    continue;
                }
                for (var i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];

                    if (this.isTypeOfDD(oDD)) {
                        var loc = this.getLocation(oDD);
                        if (loc) {
                            this.locationCache[oDD.id] = loc;
                        } else {
                            delete this.locationCache[oDD.id];
                        }
                    }
                }
            }
        },

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @method verifyEl
         * @param {HTMLElement} el the element to check
         * @return {boolean} true if the element looks usable
         * @static
         */
        verifyEl: function(el) {
            try {
                if (el) {
                    var parent = el.offsetParent;
                    if (parent) {
                        return true;
                    }
                }
            } catch(e) {
            }

            return false;
        },
        
        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @method getLocation
         * @param {DragDrop} oDD the drag and drop object to get the 
         *                       location for
         * @return {YAHOO.util.Region} a Region object representing the total area
         *                             the element occupies, including any padding
         *                             the instance is configured for.
         * @static
         */
        getLocation: function(oDD) {
            if (! this.isTypeOfDD(oDD)) {
                return null;
            }

            var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

            try {
                pos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            if (!pos) {
                return null;
            }

            x1 = pos[0];
            x2 = x1 + el.offsetWidth;
            y1 = pos[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - oDD.padding[0];
            r = x2 + oDD.padding[1];
            b = y2 + oDD.padding[2];
            l = x1 - oDD.padding[3];

            return new YAHOO.util.Region( t, r, b, l );
        },

        /**
         * Checks the cursor location to see if it over the target
         * @method isOverTarget
         * @param {YAHOO.util.Point} pt The point to evaluate
         * @param {DragDrop} oTarget the DragDrop object we are inspecting
         * @param {boolean} intersect true if we are in intersect mode
         * @param {YAHOO.util.Region} pre-cached location of the dragged element
         * @return {boolean} true if the mouse is over the target
         * @private
         * @static
         */
        isOverTarget: function(pt, oTarget, intersect, curRegion) {
            // use cache if available
            var loc = this.locationCache[oTarget.id];
            if (!loc || !this.useCache) {
                loc = this.getLocation(oTarget);
                this.locationCache[oTarget.id] = loc;

            }

            if (!loc) {
                return false;
            }

            oTarget.cursorIsOver = loc.contains( pt );

            // DragDrop is using this as a sanity check for the initial mousedown
            // in this case we are done.  In POINT mode, if the drag obj has no
            // contraints, we are done. Otherwise we need to evaluate the 
            // region the target as occupies to determine if the dragged element
            // overlaps with it.
            
            var dc = this.dragCurrent;
            if (!dc || (!intersect && !dc.constrainX && !dc.constrainY)) {

                //if (oTarget.cursorIsOver) {
                //}
                return oTarget.cursorIsOver;
            }

            oTarget.overlap = null;


            // Get the current location of the drag element, this is the
            // location of the mouse event less the delta that represents
            // where the original mousedown happened on the element.  We
            // need to consider constraints and ticks as well.

            if (!curRegion) {
                var pos = dc.getTargetCoord(pt.x, pt.y);
                var el = dc.getDragEl();
                curRegion = new YAHOO.util.Region( pos.y, 
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight, 
                                                   pos.x );
            }

            var overlap = curRegion.intersect(loc);

            if (overlap) {
                oTarget.overlap = overlap;
                return (intersect) ? true : oTarget.cursorIsOver;
            } else {
                return false;
            }
        },

        /**
         * unload event handler
         * @method _onUnload
         * @private
         * @static
         */
        _onUnload: function(e, me) {
            this.unregAll();
        },

        /**
         * Cleans up the drag and drop events and objects.
         * @method unregAll
         * @private
         * @static
         */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }

            this._execOnAll("unreg", []);

            //for (var i in this.elementCache) {
                //delete this.elementCache[i];
            //}
            //this.elementCache = {};

            this.ids = {};
        },

        /**
         * A cache of DOM elements
         * @property elementCache
         * @private
         * @static
         * @deprecated elements are not cached now
         */
        elementCache: {},
        
        /**
         * Get the wrapper for the DOM element specified
         * @method getElWrapper
         * @param {String} id the id of the element to get
         * @return {YAHOO.util.DDM.ElementWrapper} the wrapped element
         * @private
         * @deprecated This wrapper isn't that useful
         * @static
         */
        getElWrapper: function(id) {
            var oWrapper = this.elementCache[id];
            if (!oWrapper || !oWrapper.el) {
                oWrapper = this.elementCache[id] = 
                    new this.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            return oWrapper;
        },

        /**
         * Returns the actual DOM element
         * @method getElement
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use YAHOO.util.Dom.get instead
         * @static
         */
        getElement: function(id) {
            return YAHOO.util.Dom.get(id);
        },
        
        /**
         * Returns the style property for the DOM element (i.e., 
         * document.getElById(id).style)
         * @method getCss
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         * @deprecated use YAHOO.util.Dom instead
         * @static
         */
        getCss: function(id) {
            var el = YAHOO.util.Dom.get(id);
            return (el) ? el.style : null;
        },

        /**
         * Inner class for cached elements
         * @class DragDropMgr.ElementWrapper
         * @for DragDropMgr
         * @private
         * @deprecated
         */
        ElementWrapper: function(el) {
                /**
                 * The element
                 * @property el
                 */
                this.el = el || null;
                /**
                 * The element id
                 * @property id
                 */
                this.id = this.el && el.id;
                /**
                 * A reference to the style property
                 * @property css
                 */
                this.css = this.el && el.style;
            },

        /**
         * Returns the X position of an html element
         * @method getPosX
         * @param el the element for which to get the position
         * @return {int} the X coordinate
         * @for DragDropMgr
         * @deprecated use YAHOO.util.Dom.getX instead
         * @static
         */
        getPosX: function(el) {
            return YAHOO.util.Dom.getX(el);
        },

        /**
         * Returns the Y position of an html element
         * @method getPosY
         * @param el the element for which to get the position
         * @return {int} the Y coordinate
         * @deprecated use YAHOO.util.Dom.getY instead
         * @static
         */
        getPosY: function(el) {
            return YAHOO.util.Dom.getY(el); 
        },

        /**
         * Swap two nodes.  In IE, we use the native method, for others we 
         * emulate the IE behavior
         * @method swapNode
         * @param n1 the first node to swap
         * @param n2 the other node to swap
         * @static
         */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else {
                var p = n2.parentNode;
                var s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
         * Returns the current scroll position
         * @method getScroll
         * @private
         * @static
         */
        getScroll: function () {
            var t, l, dde=document.documentElement, db=document.body;
            if (dde && (dde.scrollTop || dde.scrollLeft)) {
                t = dde.scrollTop;
                l = dde.scrollLeft;
            } else if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else {
            }
            return { top: t, left: l };
        },

        /**
         * Returns the specified element style property
         * @method getStyle
         * @param {HTMLElement} el          the element
         * @param {string}      styleProp   the style property
         * @return {string} The value of the style property
         * @deprecated use YAHOO.util.Dom.getStyle
         * @static
         */
        getStyle: function(el, styleProp) {
            return YAHOO.util.Dom.getStyle(el, styleProp);
        },

        /**
         * Gets the scrollTop
         * @method getScrollTop
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollTop: function () { return this.getScroll().top; },

        /**
         * Gets the scrollLeft
         * @method getScrollLeft
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollLeft: function () { return this.getScroll().left; },

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @method moveToEl
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         * @static
         */
        moveToEl: function (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        },

        /**
         * Gets the client height
         * @method getClientHeight
         * @return {int} client height in px
         * @deprecated use YAHOO.util.Dom.getViewportHeight instead
         * @static
         */
        getClientHeight: function() {
            return YAHOO.util.Dom.getViewportHeight();
        },

        /**
         * Gets the client width
         * @method getClientWidth
         * @return {int} client width in px
         * @deprecated use YAHOO.util.Dom.getViewportWidth instead
         * @static
         */
        getClientWidth: function() {
            return YAHOO.util.Dom.getViewportWidth();
        },

        /**
         * Numeric array sort function
         * @method numericSort
         * @static
         */
        numericSort: function(a, b) { return (a - b); },

        /**
         * Internal counter
         * @property _timeoutCount
         * @private
         * @static
         */
        _timeoutCount: 0,

        /**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * @method _addListeners
         * @private
         * @static
         */
        _addListeners: function() {
            var DDM = YAHOO.util.DDM;
            if ( YAHOO.util.Event && document ) {
                DDM._onLoad();
            } else {
                if (DDM._timeoutCount > 2000) {
                } else {
                    setTimeout(DDM._addListeners, 10);
                    if (document && document.body) {
                        DDM._timeoutCount += 1;
                    }
                }
            }
        },

        /**
         * Recursively searches the immediate parent and all child nodes for 
         * the handle element in order to determine wheter or not it was 
         * clicked.
         * @method handleWasClicked
         * @param node the html element to inspect
         * @static
         */
        handleWasClicked: function(node, id) {
            if (this.isHandle(id, node.id)) {
                return true;
            } else {
                // check to see if this is a text node child of the one we want
                var p = node.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return true;
                    } else {
                        p = p.parentNode;
                    }
                }
            }

            return false;
        }

    };

}();

// shorter alias, save a few bytes
YAHOO.util.DDM = YAHOO.util.DragDropMgr;
YAHOO.util.DDM._addListeners();

}

(function() {

var Event=YAHOO.util.Event; 
var Dom=YAHOO.util.Dom;

/**
 * Defines the interface and base operation of items that that can be 
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver, onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with 
 * other DragDrop objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that 
 * was clicked matches a handle element.  By default this is the linked 
 * element, but there are times that you will want only a portion of the 
 * linked element to initiate the drag operation, and the setHandleElId() 
 * method provides a way to define this.</li>
 * <li>drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in {@link YAHOO.util.DD}.  setDragElId() lets you define
 * a separate element that would be moved, as in {@link YAHOO.util.DDProxy}
 * </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any 
 * other DragDrop obj in the "group1" group:
 * <pre>
 *  dd = new YAHOO.util.DragDrop("div1", "group1");
 * </pre>
 * Since none of the event handlers have been implemented, nothing would 
 * actually happen if you were to run the code above.  Normally you would 
 * override this class or one of the default implementations, but you can 
 * also override the methods you want on an instance of the class...
 * <pre>
 *  dd.onDragDrop = function(e, id) {
 *  &nbsp;&nbsp;alert("dd was dropped on " + id);
 *  }
 * </pre>
 * @namespace YAHOO.util
 * @class DragDrop
 * @constructor
 * @param {String} id of the element that is linked to this instance
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DragDrop: 
 *                    padding, isTarget, maintainOffset, primaryButtonOnly,
 */
YAHOO.util.DragDrop = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config); 
    }
};

YAHOO.util.DragDrop.prototype = {
    /**
     * An Object Literal containing the events that we will be using: mouseDown, b4MouseDown, mouseUp, b4StartDrag, startDrag, b4EndDrag, endDrag, mouseUp, drag, b4Drag, invalidDrop, b4DragOut, dragOut, dragEnter, b4DragOver, dragOver, b4DragDrop, dragDrop
     * By setting any of these to false, then event will not be fired.
     * @property events
     * @type object
     */
    events: null,
    /**
    * @method on
    * @description Shortcut for EventProvider.subscribe, see <a href="YAHOO.util.EventProvider.html#subscribe">YAHOO.util.EventProvider.subscribe</a>
    */
    on: function() {
        this.subscribe.apply(this, arguments);
    },
    /**
     * The id of the element associated with this object.  This is what we 
     * refer to as the "linked element" because the size and position of 
     * this element is used to determine when the drag and drop objects have 
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same 
     * as the linked element , but could be changed to another element. Ex: 
     * YAHOO.util.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null, 

    /**
     * the id of the element that initiates the drag operation.  By default 
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the 
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null, 

    /**
     * An associative array of HTML tags that will be ignored if clicked.
     * @property invalidHandleTypes
     * @type {string: string}
     */
    invalidHandleTypes: null, 

    /**
     * An associative array of ids for elements that will be ignored if clicked
     * @property invalidHandleIds
     * @type {string: string}
     */
    invalidHandleIds: null, 

    /**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * @property invalidHandleClasses
     * @type string[]
     */
    invalidHandleClasses: null, 

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are 
     * related.  Instances only get events when interacting with other 
     * DragDrop object in the same group.  This lets us define multiple 
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type {string: string}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent 
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function() { this.locked = true; },

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function() { this.locked = false; },

    /**
     * By default, all instances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @property isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @property padding
     * @type int[]
     */
    padding: null,
    /**
     * If this flag is true, do not fire drop events. The element is a drag only element (for movement not dropping)
     * @property dragOnly
     * @type Boolean
     */
    dragOnly: false,

    /**
     * If this flag is true, a shim will be placed over the screen/viewable area to track mouse events. Should help with dragging elements over iframes and other controls.
     * @property useShim
     * @type Boolean
     */
    useShim: false,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint 
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint 
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaX
     * @type int
     * @private
     */
    deltaX: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaY
     * @type int
     * @private
     */
    deltaY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * vertical graduation/interval.  This array is generated automatically 
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This property
     * can be used in intersect mode to help determine the focus of
     * the mouse interaction.  DDM.getBestMatch uses this property first to
     * determine the closest match in INTERSECT mode when multiple targets
     * are part of the same interaction.
     * @property cursorIsOver
     * @type boolean
     */
    cursorIsOver: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This is a region
     * that represents the area the draggable element overlaps this target.
     * DDM.getBestMatch uses this property to compare the size of the overlap
     * to that of other targets in order to determine the closest match in
     * INTERSECT mode when multiple targets are part of the same interaction.
     * @property overlap 
     * @type YAHOO.util.Region
     */
    overlap: null,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function(x, y) { },

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function(x, y) { /* override this */ },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function(e) { },

    /**
     * Abstract method called during the onMouseMove event while dragging an 
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function(e) { /* override this */ },

    /**
     * Abstract method called when this element fist begins hovering over 
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more 
     * dragdrop items being hovered over.
     */
    onDragEnter: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function(e) { },

    /**
     * Abstract method called when this element is hovering over another 
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items 
     * being hovered over.
     */
    onDragOver: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function(e) { },

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items 
     * that the mouse is no longer over.
     */
    onDragOut: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function(e) { },

    /**
     * Abstract method called when this item is dropped on another DragDrop 
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this 
     * was dropped on.
     */
    onDragDrop: function(e, id) { /* override this */ },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function(e) { /* override this */ },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function(e) { },

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function(e) { /* override this */ },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function(e) {  },

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function(e) { /* override this */ },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function(e) { /* override this */ },
   
    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () { 
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element 
     */
    getEl: function() { 
        if (!this._domRef) {
            this._domRef = Dom.get(this.id); 
        }

        return this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another 
     * element. An example of this can be found in YAHOO.util.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element 
     */
    getDragEl: function() {
        return Dom.get(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * YAHOO.util.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function(id, sGroup, config) {
        this.initTarget(id, sGroup, config);
        Event.on(this._domRef || this.id, "mousedown", 
                        this.handleMouseDown, this, true);

        // Event.on(this.id, "selectstart", Event.preventDefault);
        for (var i in this.events) {
            this.createEvent(i + 'Event');
        }
        
    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function(id, sGroup, config) {

        // configuration attributes 
        this.config = config || {};

        this.events = {};

        // create a local reference to the drag and drop manager
        this.DDM = YAHOO.util.DDM;

        // initialize the groups object
        this.groups = {};

        // assume that we have an element reference instead of an id if the
        // parameter is not a string
        if (typeof id !== "string") {
            this._domRef = id;
            id = Dom.generateId(id);
        }

        // set the id
        this.id = id;

        // add to an interaction group
        this.addToGroup((sGroup) ? sGroup : "default");

        // We don't want to register this as the handle with the manager
        // so we just set the id rather than calling the setter.
        this.handleElId = id;

        Event.onAvailable(id, this.handleOnAvailable, this, true);


        // the linked element is the element that gets dragged by default
        this.setDragElId(id); 

        // by default, clicked anchors will not start drag operations. 
        // @TODO what else should be here?  Probably form fields.
        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and 
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function() {
        this.events = {
            mouseDown: true,
            b4MouseDown: true,
            mouseUp: true,
            b4StartDrag: true,
            startDrag: true,
            b4EndDrag: true,
            endDrag: true,
            drag: true,
            b4Drag: true,
            invalidDrop: true,
            b4DragOut: true,
            dragOut: true,
            dragEnter: true,
            b4DragOver: true,
            dragOver: true,
            b4DragDrop: true,
            dragDrop: true
        };
        
        if (this.config.events) {
            for (var i in this.config.events) {
                if (this.config.events[i] === false) {
                    this.events[i] = false;
                }
            }
        }


        // configurable properties: 
        //    padding, isTarget, maintainOffset, primaryButtonOnly
        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
        this.dragOnly = ((this.config.dragOnly === true) ? true : false);
        this.useShim = ((this.config.useShim === true) ? true : false);
    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.  
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function(iTop, iRight, iBot, iLeft) {
        // this.padding = [iLeft, iRight, iTop, iBot];
        if (!iRight && 0 !== iRight) {
            this.padding = [iTop, iTop, iTop, iTop];
        } else if (!iBot && 0 !== iBot) {
            this.padding = [iTop, iRight, iTop, iRight];
        } else {
            this.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitialPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     * @private
     */
    setInitPosition: function(diffX, diffY) {
        var el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            if (el && el.style && (el.style.display == 'none')) {
            } else {
            }
            return;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = Dom.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];



        this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function(pos) {
        var p = pos || Dom.getXY(this.getEl());

        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All 
     * instances belong to at least one group, and can belong to as many 
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function(sGroup) {
        this.groups[sGroup] = true;
        this.DDM.regDragDrop(this, sGroup);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function(sGroup) {
        if (this.groups[sGroup]) {
            delete this.groups[sGroup];
        }

        this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
     * Allows you to specify that an element other than the linked element 
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be 
     * used to initiate the drag operation.  An example of this would be if 
     * you have a content div with text and links.  Clicking anywhere in the 
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element 
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to 
     * initiate the drag.
     */
    setHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag 
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        Event.on(id, "mousedown", 
                this.handleMouseDown, this, true);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function() {
        Event.removeListener(this.id, "mousedown", 
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else 
     * false
     */
    isLocked: function() {
        return (this.DDM.isLocked() || this.locked);
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e 
     * @param {YAHOO.util.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function(e, oDD) {

        var button = e.which || e.button;

        if (this.primaryButtonOnly && button > 1) {
            return;
        }

        if (this.isLocked()) {
            return;
        }



        // firing the mousedown events prior to calculating positions
        var b4Return = this.b4MouseDown(e),
        b4Return2 = true;

        if (this.events.b4MouseDown) {
            b4Return2 = this.fireEvent('b4MouseDownEvent', e);
        }
        var mDownReturn = this.onMouseDown(e),
            mDownReturn2 = true;
        if (this.events.mouseDown) {
            if (mDownReturn === false) {
                //Fixes #2528759 - Mousedown function returned false, don't fire the event and cancel everything.
                 mDownReturn2 = false;
            } else {
                mDownReturn2 = this.fireEvent('mouseDownEvent', e);
            }
        }

        if ((b4Return === false) || (mDownReturn === false) || (b4Return2 === false) || (mDownReturn2 === false)) {
            return;
        }

        this.DDM.refreshCache(this.groups);
        // var self = this;
        // setTimeout( function() { self.DDM.refreshCache(self.groups); }, 0);

        // Only process the event if we really clicked within the linked 
        // element.  The reason we make this check is that in the case that 
        // another element was moved between the clicked element and the 
        // cursor in the time between the mousedown and mouseup events. When 
        // this happens, the element gets the next mousedown event 
        // regardless of where on the screen it happened.  
        var pt = new YAHOO.util.Point(Event.getPageX(e), Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else {
            if (this.clickValidator(e)) {


                // set the initial element position
                this.setStartPosition();

                // start tracking mousemove distance and mousedown time to
                // determine when to start the actual drag
                this.DDM.handleMouseDown(e, this);

                // this mousedown is mine
                this.DDM.stopEvent(e);
            } else {


            }
        }
    },

    /**
     * @method clickValidator
     * @description Method validates that the clicked element
     * was indeed the handle or a valid child of the handle
     * @param {Event} e 
     */
    clickValidator: function(e) {
        var target = YAHOO.util.Event.getTarget(e);
        return ( this.isValidHandleChild(target) &&
                    (this.id == this.handleElId || 
                        this.DDM.handleWasClicked(target, this.id)) );
    },

    /**
     * Finds the location the element should be placed if we want to move
     * it to where the mouse location less the click offset would place us.
     * @method getTargetCoord
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     * @return an object that contains the coordinates (Object.x and Object.y)
     * @private
     */
    getTargetCoord: function(iPageX, iPageY) {


        var x = iPageX - this.deltaX;
        var y = iPageY - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }

        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return {x:x, y:y};
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        this.invalidHandleTypes[type] = type;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.invalidHandleIds[id] = id;
    },


    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function(cssClass) {
        this.invalidHandleClasses.push(cssClass);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        // this.invalidHandleTypes[type] = null;
        delete this.invalidHandleTypes[type];
    },
    
    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        delete this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to 
     * re-enable
     */
    removeInvalidHandleClass: function(cssClass) {
        for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == cssClass) {
                delete this.invalidHandleClasses[i];
            }
        }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function(node) {

        var valid = true;
        // var n = (node.nodeName == "#text") ? node.parentNode : node;
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid && !this.invalidHandleTypes[nodeName];
        valid = valid && !this.invalidHandleIds[node.id];

        for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
            valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);
        }


        return valid;

    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function(iStartX, iTickSize) {
        this.xTicks = [];
        this.xTickSize = iTickSize;
        
        var tickMap = {};

        for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in 
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function(iStartY, iTickSize) {
        this.yTicks = [];
        this.yTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use 
     * this method to limit the horizontal travel of the element.  Pass in 
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the 
     * right
     * @param {int} iTickSize optional parameter for specifying that the 
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = parseInt(iLeft, 10);
        this.rightConstraint = parseInt(iRight, 10);

        this.minX = this.initPageX - this.leftConstraint;
        this.maxX = this.initPageX + this.rightConstraint;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set 
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the 
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = parseInt(iUp, 10);
        this.bottomConstraint = parseInt(iDown, 10);

        this.minY = this.initPageY - this.topConstraint;
        this.maxY = this.initPageY + this.bottomConstraint;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;
        
    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     */
    resetConstraints: function() {


        // Maintain offsets if necessary
        if (this.initPageX || this.initPageX === 0) {
            // figure out how much this thing has moved
            var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
        } else {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint, 
                                 this.rightConstraint, 
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint, 
                                 this.bottomConstraint, 
                                 this.yTickSize         );
        }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify 
     * that it move a number of pixels at a time.  This method resolves the 
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function(val, tickArray) {

        if (!tickArray) {
            // If tick interval is not defined, it is effectively 1 pixel, 
            // so we return the value passed to us.
            return val; 
        } else if (tickArray[0] >= val) {
            // The value is lower than the first tick, so we return the first
            // tick.
            return tickArray[0];
        } else {
            for (var i=0, len=tickArray.length; i<len; ++i) {
                var next = i + 1;
                if (tickArray[next] && tickArray[next] >= val) {
                    var diff1 = val - tickArray[i];
                    var diff2 = tickArray[next] - val;
                    return (diff2 > diff1) ? tickArray[i] : tickArray[next];
                }
            }

            // The value is larger than the last tick, so we return the last
            // tick.
            return tickArray[tickArray.length - 1];
        }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function() {
        return ("DragDrop " + this.id);
    }

};
YAHOO.augment(YAHOO.util.DragDrop, YAHOO.util.EventProvider);

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
})();
/**
 * A DragDrop implementation where the linked element follows the 
 * mouse cursor during a drag.
 * @class DD
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String} id the id of the linked element 
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD: 
 *                    scroll
 */
YAHOO.util.DD = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DD, YAHOO.util.DragDrop, {

    /**
     * When set to true, the utility automatically tries to scroll the browser
     * window when a drag and drop element is dragged near the viewport boundary.
     * Defaults to true.
     * @property scroll
     * @type boolean
     */
    scroll: true, 

    /**
     * Sets the pointer offset to the distance between the linked element's top 
     * left corner and the location the element was clicked
     * @method autoOffset
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     */
    autoOffset: function(iPageX, iPageY) {
        var x = iPageX - this.startPageX;
        var y = iPageY - this.startPageY;
        this.setDelta(x, y);
    },

    /** 
     * Sets the pointer offset.  You can call this directly to force the 
     * offset to be in a particular location (e.g., pass in 0,0 to set it 
     * to the center of the object, as done in YAHOO.widget.Slider)
     * @method setDelta
     * @param {int} iDeltaX the distance from the left
     * @param {int} iDeltaY the distance from the top
     */
    setDelta: function(iDeltaX, iDeltaY) {
        this.deltaX = iDeltaX;
        this.deltaY = iDeltaY;
    },

    /**
     * Sets the drag element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method setDragElPos
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    setDragElPos: function(iPageX, iPageY) {
        // the first time we do this, we are going to check to make sure
        // the element has css positioning

        var el = this.getDragEl();
        this.alignElWithMouse(el, iPageX, iPageY);
    },

    /**
     * Sets the element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method alignElWithMouse
     * @param {HTMLElement} el the element to move
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var oCoord = this.getTargetCoord(iPageX, iPageY);

        if (!this.deltaSetXY) {
            var aCoord = [oCoord.x, oCoord.y];
            YAHOO.util.Dom.setXY(el, aCoord);

            var newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            var newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            this.deltaSetXY = [ newLeft - oCoord.x, newTop - oCoord.y ];
        } else {
            YAHOO.util.Dom.setStyle(el, "left", (oCoord.x + this.deltaSetXY[0]) + "px");
            YAHOO.util.Dom.setStyle(el, "top",  (oCoord.y + this.deltaSetXY[1]) + "px");
        }
        
        this.cachePosition(oCoord.x, oCoord.y);
        var self = this;
        setTimeout(function() {
            self.autoScroll.call(self, oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
        }, 0);
    },

    /**
     * Saves the most recent position so that we can reset the constraints and
     * tick marks on-demand.  We need to know this so that we can calculate the
     * number of pixels the element is offset from its original position.
     * @method cachePosition
     * @param iPageX the current x position (optional, this just makes it so we
     * don't have to look it up again)
     * @param iPageY the current y position (optional, this just makes it so we
     * don't have to look it up again)
     */
    cachePosition: function(iPageX, iPageY) {
        if (iPageX) {
            this.lastPageX = iPageX;
            this.lastPageY = iPageY;
        } else {
            var aCoord = YAHOO.util.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
     * Auto-scroll the window if the dragged object has been moved beyond the 
     * visible window boundary.
     * @method autoScroll
     * @param {int} x the drag element's x position
     * @param {int} y the drag element's y position
     * @param {int} h the height of the drag element
     * @param {int} w the width of the drag element
     * @private
     */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            // The client height
            var clientH = this.DDM.getClientHeight();

            // The client width
            var clientW = this.DDM.getClientWidth();

            // The amt scrolled down
            var st = this.DDM.getScrollTop();

            // The amt scrolled right
            var sl = this.DDM.getScrollLeft();

            // Location of the bottom of the element
            var bot = h + y;

            // Location of the right of the element
            var right = w + x;

            // The distance from the cursor to the bottom of the visible area, 
            // adjusted so that we don't scroll if the cursor is beyond the
            // element drag constraints
            var toBot = (clientH + st - y - this.deltaY);

            // The distance from the cursor to the right of the visible area
            var toRight = (clientW + sl - x - this.deltaX);


            // How close to the edge the cursor must be before we scroll
            // var thresh = (document.all) ? 100 : 40;
            var thresh = 40;

            // How many pixels to scroll per autoscroll op.  This helps to reduce 
            // clunky scrolling. IE is more sensitive about this ... it needs this 
            // value to be higher.
            var scrAmt = (document.all) ? 80 : 30;

            // Scroll down if we are near the bottom of the visible page and the 
            // obj extends below the crease
            if ( bot > clientH && toBot < thresh ) { 
                window.scrollTo(sl, st + scrAmt); 
            }

            // Scroll up if the window is scrolled down and the top of the object
            // goes above the top border
            if ( y < st && st > 0 && y - st < thresh ) { 
                window.scrollTo(sl, st - scrAmt); 
            }

            // Scroll right if the obj is beyond the right border and the cursor is
            // near the border.
            if ( right > clientW && toRight < thresh ) { 
                window.scrollTo(sl + scrAmt, st); 
            }

            // Scroll left if the window has been scrolled to the right and the obj
            // extends past the left border
            if ( x < sl && sl > 0 && x - sl < thresh ) { 
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /*
     * Sets up config options specific to this class. Overrides
     * YAHOO.util.DragDrop, but all versions of this method through the 
     * inheritance chain are called
     */
    applyConfig: function() {
        YAHOO.util.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
     * Event that fires prior to the onMouseDown event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4MouseDown: function(e) {
        this.setStartPosition();
        // this.resetConstraints();
        this.autoOffset(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    /*
     * Event that fires prior to the onDrag event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4Drag: function(e) {
        this.setDragElPos(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    toString: function() {
        return ("DD " + this.id);
    }

    //////////////////////////////////////////////////////////////////////////
    // Debugging ygDragDrop events that can be overridden
    //////////////////////////////////////////////////////////////////////////
    /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
});
/**
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @class DDProxy
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop: 
 *                   resizeFrame, centerFrame, dragElId
 */
YAHOO.util.DDProxy = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
        this.initFrame(); 
    }
};

/**
 * The default drag frame div id
 * @property YAHOO.util.DDProxy.dragElId
 * @type String
 * @static
 */
YAHOO.util.DDProxy.dragElId = "ygddfdiv";

YAHOO.extend(YAHOO.util.DDProxy, YAHOO.util.DD, {

    /**
     * By default we resize the drag frame to be the same size as the element
     * we want to drag (this is to get the frame effect).  We can turn it off
     * if we want a different behavior.
     * @property resizeFrame
     * @type boolean
     */
    resizeFrame: true,

    /**
     * By default the frame is positioned exactly where the drag element is, so
     * we use the cursor offset provided by YAHOO.util.DD.  Another option that works only if
     * you do not have constraints on the obj is to have the drag frame centered
     * around the cursor.  Set centerFrame to true for this effect.
     * @property centerFrame
     * @type boolean
     */
    centerFrame: false,

    /**
     * Creates the proxy element if it does not yet exist
     * @method createFrame
     */
    createFrame: function() {
        var self=this, body=document.body;

        if (!body || !body.firstChild) {
            setTimeout( function() { self.createFrame(); }, 50 );
            return;
        }

        var div=this.getDragEl(), Dom=YAHOO.util.Dom;

        if (!div) {
            div    = document.createElement("div");
            div.id = this.dragElId;
            var s  = div.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;
            s.height     = "25px";
            s.width      = "25px";

            var _data = document.createElement('div');
            Dom.setStyle(_data, 'height', '100%');
            Dom.setStyle(_data, 'width', '100%');
            /**
            * If the proxy element has no background-color, then it is considered to the "transparent" by Internet Explorer.
            * Since it is "transparent" then the events pass through it to the iframe below.
            * So creating a "fake" div inside the proxy element and giving it a background-color, then setting it to an
            * opacity of 0, it appears to not be there, however IE still thinks that it is so the events never pass through.
            */
            Dom.setStyle(_data, 'background-color', '#ccc');
            Dom.setStyle(_data, 'opacity', '0');
            div.appendChild(_data);

            // appendChild can blow up IE if invoked prior to the window load event
            // while rendering a table.  It is possible there are other scenarios 
            // that would cause this to happen as well.
            body.insertBefore(div, body.firstChild);
        }
    },

    /**
     * Initialization for the drag frame element.  Must be called in the
     * constructor of all subclasses
     * @method initFrame
     */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        YAHOO.util.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || YAHOO.util.DDProxy.dragElId);
    },

    /**
     * Resizes the drag frame to the dimensions of the clicked object, positions 
     * it over the object, and finally displays it
     * @method showFrame
     * @param {int} iPageX X click position
     * @param {int} iPageY Y click position
     * @private
     */
    showFrame: function(iPageX, iPageY) {
        var el = this.getEl();
        var dragEl = this.getDragEl();
        var s = dragEl.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2), 
                           Math.round(parseInt(s.height, 10)/2) );
        }

        this.setDragElPos(iPageX, iPageY);

        YAHOO.util.Dom.setStyle(dragEl, "visibility", "visible"); 
    },

    /**
     * The proxy is automatically resized to the dimensions of the linked
     * element when a drag is initiated, unless resizeFrame is set to false
     * @method _resizeProxy
     * @private
     */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var DOM    = YAHOO.util.Dom;
            var el     = this.getEl();
            var dragEl = this.getDragEl();

            var bt = parseInt( DOM.getStyle(dragEl, "borderTopWidth"    ), 10);
            var br = parseInt( DOM.getStyle(dragEl, "borderRightWidth"  ), 10);
            var bb = parseInt( DOM.getStyle(dragEl, "borderBottomWidth" ), 10);
            var bl = parseInt( DOM.getStyle(dragEl, "borderLeftWidth"   ), 10);

            if (isNaN(bt)) { bt = 0; }
            if (isNaN(br)) { br = 0; }
            if (isNaN(bb)) { bb = 0; }
            if (isNaN(bl)) { bl = 0; }


            var newWidth  = Math.max(0, el.offsetWidth  - br - bl);                                                                                           
            var newHeight = Math.max(0, el.offsetHeight - bt - bb);


            DOM.setStyle( dragEl, "width",  newWidth  + "px" );
            DOM.setStyle( dragEl, "height", newHeight + "px" );
        }
    },

    // overrides YAHOO.util.DragDrop
    b4MouseDown: function(e) {
        this.setStartPosition();
        var x = YAHOO.util.Event.getPageX(e);
        var y = YAHOO.util.Event.getPageY(e);
        this.autoOffset(x, y);

        // This causes the autoscroll code to kick off, which means autoscroll can
        // happen prior to the check for a valid drag handle.
        // this.setDragElPos(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4StartDrag: function(x, y) {
        // show the drag frame
        this.showFrame(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4EndDrag: function(e) {
        YAHOO.util.Dom.setStyle(this.getDragEl(), "visibility", "hidden"); 
    },

    // overrides YAHOO.util.DragDrop
    // By default we try to move the element to the last location of the frame.  
    // This is so that the default behavior mirrors that of YAHOO.util.DD.  
    endDrag: function(e) {
        var DOM = YAHOO.util.Dom;
        var lel = this.getEl();
        var del = this.getDragEl();

        // Show the drag frame briefly so we can get its position
        // del.style.visibility = "";
        DOM.setStyle(del, "visibility", ""); 

        // Hide the linked element before the move to get around a Safari 
        // rendering bug.
        //lel.style.visibility = "hidden";
        DOM.setStyle(lel, "visibility", "hidden"); 
        YAHOO.util.DDM.moveToEl(lel, del);
        //del.style.visibility = "hidden";
        DOM.setStyle(del, "visibility", "hidden"); 
        //lel.style.visibility = "";
        DOM.setStyle(lel, "visibility", ""); 
    },

    toString: function() {
        return ("DDProxy " + this.id);
    }
/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

});
/**
 * A DragDrop implementation that does not move, but can be a drop 
 * target.  You would get the same result by simply omitting implementation 
 * for the event callbacks, but this way we reduce the processing cost of the 
 * event listener and the callbacks.
 * @class DDTarget
 * @extends YAHOO.util.DragDrop 
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in 
 *                 DragDrop: 
 *                    none
 */
YAHOO.util.DDTarget = function(id, sGroup, config) {
    if (id) {
        this.initTarget(id, sGroup, config);
    }
};

// YAHOO.util.DDTarget.prototype = new YAHOO.util.DragDrop();
YAHOO.extend(YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
    toString: function() {
        return ("DDTarget " + this.id);
    }
});
YAHOO.register("dragdrop", YAHOO.util.DragDropMgr, {version: "2.9.0", build: "2800"});
(function ($){
  
  $.timeSheetManagerCmp = {
    /**
     * JQuery Object
     */
    _oId : null,
    
    /**
     * Internal Id
     */
    _internalId : 'DivTimeSheetManager',
    
    /**
     * Calendar Header Id
     */
    _calendarHeaderId : 'DivTimeSheetCalendarHeader',
    
    _oCalendarHeader : null,
    
    /**
     * Label List Id
     */
    _labelListId : 'DivTimeSheetLabelList',
    
    _oLabelList : null,
    
    /**
     * Grid List Id
     */
    _gridListId : 'DivTimeSheetGridList',
    
    _oGridList : null,
    
    /**
     * Task Metric List Id
     */
    _taskMetricListId : 'DivTimeSheetMetricList',
    
    _oTaskMetricList : null,
    
    /**
     * Calendar Metric list Id
     */
    _calMetricListId : 'DivTimeSheetTotalDailyList',
    
    _oCalMetricList : null,
    
    /**
     * Global Metric Id
     */
    _globalMetricId : 'DivTimeSheetTotalWeeklyGlobal',
    
    _oGlobalMetric : null,
    
    /**
     * Selected Date Object
     */
    _selectedDateId : '',
    
    _oSelectedDate : null,
    
    /**
     * Manager Filter Object
     */
    _managerFilterId : '',
    
    _oManagerFilter : null,
    
    /**
     * Support Person Filter Object
     */
    _supportPersonFilterId : '',
    
    _oSupportPersonFilter : null,
    
    /**
     * Start Date Filter Object
     */
    _startDateFilterId : '',
    
    _oStartDateFilter : null,
    
    /**
     * End Date Filter Object
     */
    _endDateFilterId : '',
    
    _oEndDateFilter : null,
    
    /**
     * Serialized List of Hidden Header column number ("pipe" | separator)
     */
    _sHiddenHdColNumber : '',
    
    /**
     * Ids of Components which manage edition of Elapsed Time Comment
     */
    _commentElpsdTmeDivId : 'DivTimeSheetComElpsdTme',
    
    _commentElpsdTmeTxtId : 'TxtTimeSheetComElpsdTme',
    
    /**
     * List of Percent Complete 
     */
    _aPctCompleteObj : [],
    
    /**
     * List of Task Metric
     */
    _aTaskMetricObj : [],
    
    /**
     * List of Calendar Metric
     */
    _aCalMetricObj : [],
    
    /**
     * @private Synchronise Date Limit Filter
     */
    _syncDateLimitFilter : function() {
      /* Get Hidden Params */
      var _oHiddenCalStartDate = $("#ts_cal_start_date");
      var _oHiddenCalEndDate = $("#ts_cal_end_date");
      /* Sync Start Date Filter */
      this._oStartDateFilter = $("#" + this._startDateFilterId);
      //this._oStartDateFilter.html(_oHiddenStartDate.val());
      this._oStartDateFilter.val(_oHiddenCalStartDate.val());
      /* Sync End Date Filter */
      this._oEndDateFilter = $("#" + this._endDateFilterId);
      this._oEndDateFilter.val(_oHiddenCalEndDate.val());
    },

    /**
     * @private Initialize Calendar Navigation
     */
    _initCalendarNavigation : function (){
      /* Previous Week Button Goto */
      var _oBtnPrevWeek = $("#ts_cal_prev_week");
      _oBtnPrevWeek.bind('click', function() {
        $.timeSheetManagerCmp.gotoCalendarWeek('prev');
        //alert('Previous Week !!');
      });
      /* Next Week Button Goto */
      var _oBtnNextWeek = $("#ts_cal_next_week");
      _oBtnNextWeek.bind('click', function() {
        $.timeSheetManagerCmp.gotoCalendarWeek('next');
        //alert('Next Week !!');
      });
    },
    
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    /******************************************************************************************************************/
    
    /**
     * Constructor
     */
    init : function (sSelectedDateId, sManagerFilterId, sSupportPersonFilterId, sStartDateFilterId, sEndDateFilterId, sHiddenHdColNumber){
      /* Parameter : Selected Date  */
      this._selectedDateId = sSelectedDateId;
      
      // Test binding des events
      this._oSelectedDate = $("#" + this._selectedDateId);
      this._oSelectedDate.change( function() {
        var bRes = dlg_checkdate($.timeSheetManagerCmp._selectedDateId);
        if (bRes == true) $.timeSheetManagerCmp.changeSelectedDate();
      });
      
      /* Parameter : Manager Filter*/
      this._managerFilterId = sManagerFilterId;

      /* Parameter : Support Person Filter */
      this._supportPersonFilterId = sSupportPersonFilterId;
      
      /* Parameter : Start Date  */
      this._startDateFilterId = sStartDateFilterId;
      
      // Test binding des events
      this._oStartDateFilter = $("#" + this._startDateFilterId);
      this._oStartDateFilter.change( function() {
        var bRes = dlg_checkdate($.timeSheetManagerCmp._startDateFilterId);
        if (bRes == true) $.timeSheetManagerCmp.changeTaskParamFilter();
      });
      
      /* Parameter : End Date  */
      this._endDateFilterId = sEndDateFilterId;
      
      // Test binding des events
      this._oEndDateFilter = $("#" + this._endDateFilterId);
      this._oEndDateFilter.change( function() {
        var bRes = dlg_checkdate($.timeSheetManagerCmp._endDateFilterId);
        if (bRes == true) $.timeSheetManagerCmp.changeTaskParamFilter();
      });
      
      /* Display : Serialized List of Hidden Header column number  */
      this._sHiddenHdColNumber = sHiddenHdColNumber;
      
      //alert('Init');
    },
    
    /**
     * Create a TimeSheet Manager Container
     */
    create : function (){
      if ($("#" + this._internalId).length == 0)
      {        
        /* TimeSheet Manager Creation */
        $("#BODY_GENERAL").append('<div id="' + this._internalId + '"></div>');
        $("#" + this._internalId).css("width", "1250px");
        this._oId = $("#" + this._internalId);

        /* Call Ajax */
        var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=init&hide_col_num=" + this._sHiddenHdColNumber;
        this._oId.load(urlLoadContent, function() {
          // CallBack Function
          $.timeSheetManagerCmp.changeSelectedDate();
          //alert('Loaded');
        });
      }
      
      /* TimeSheet Component to Edit Elapsed Time Comment */
      $('body').append('<div id="' + this._commentElpsdTmeDivId + '" style="display: none;"><textarea id="' + this._commentElpsdTmeTxtId + '" rows="2" cols="20"></textarea></div>');
    },
    
    /**
     * Initialization of Elapsed Time Task Components
     */
    initElapsedTimeCmp : function(sElapsedTimeID, sCommentImgID, oParam) {
      var _oElapsedTimeCmp = $("#" + sElapsedTimeID);
      var _oCommentImg = $("#" + sCommentImgID);
      
      if (_oElapsedTimeCmp == null || _oCommentImg == null)
      {
        alert('Function Error "initElapsedTimeCmp"');
        return;
      }
      
      /* Focus Event Affectation */
      _oElapsedTimeCmp.focus(function() {
        this.select();
      });
      
      /* Change Event Affectation */
      _oElapsedTimeCmp.change(function() {
        //alert('oParam : ' + oParam);
        $.timeSheetManagerCmp.updateTimeSheet(oParam);
      });
      
      /* On Click Event Affectation */
      _oCommentImg.click(function() {
        //alert('click event => sElapsedTimeID : ' + sElapsedTimeID + ' sCommentID : ' + oParam.commentTime + ' oParam : ' + oParam);
        if (_oElapsedTimeCmp.val() != '')
          $.timeSheetManagerCmp.initCommentElpsdTmeCmp(sElapsedTimeID, oParam.commentTime, oParam);
      });
    },
    
    /**
     * Show Edit Component for Elapsed Time Comment
     */
    initCommentElpsdTmeCmp : function (sParentDivCmp, sLinkedInputCmp, oParam) {
      /* Get Components */
      var oDivElpsdTmeCom = $("#" + this._commentElpsdTmeDivId);
      var oTxtElpsdTmeCom = $("#" + this._commentElpsdTmeTxtId);
      var oParentDivCmp = $("#" + sParentDivCmp);
      var oLinkedInputCmp = $("#" + sLinkedInputCmp);
      
      if (oDivElpsdTmeCom == null || oTxtElpsdTmeCom == null || oParentDivCmp == null || oLinkedInputCmp == null)
      {
        alert('Function Error "initCommentElpsdTmeCmp"');
        return;
      }
      
      /* Get Parent Div Position */
      var oParentPos = oParentDivCmp.offset();
      var iHeight = oParentDivCmp.outerHeight();
      var left = oParentPos.left;
      var top = (oParentPos.top + iHeight);
      
      /* Apply CSS */
      oDivElpsdTmeCom.css({
        position: 'absolute',
        zIndex: 5000,
        left: left, 
        top: top
      });
      
      /* Apply Default Value */
      var sTxt = oLinkedInputCmp.val();
      oTxtElpsdTmeCom.val(sTxt);
      
      /* Set Events */
      oTxtElpsdTmeCom.blur( function() {
        //alert('Save : ' + oTxtElpsdTmeCom.val());
        /* Get Comment */
        var sTxt = oTxtElpsdTmeCom.val();
        /* Sync with Related Hidden Component */
        oLinkedInputCmp.val(sTxt);
        /* Trigger Update */
        $.timeSheetManagerCmp.updateTimeSheet(oParam);
        /* Hide Component */
        oDivElpsdTmeCom.hide();
      });
      
      /* Display Component */
      oDivElpsdTmeCom.show();
      
      /* Set Focus On Textarea */
      oTxtElpsdTmeCom.focus();
    },
    
    /**
     * Initialization of Percent Complete Task Component
     */
    initPctComplete : function(iProjectID, iTaskID, sPctComplCmpId, sActionCmpId) {
      var _oPctComplete = $("#" + sPctComplCmpId);
      var _oActionID = $("#" + sActionCmpId);
      
      if (_oPctComplete == null || _oActionID == null)
      {
        alert('Function Error "initPctComplete"');
        return;
      }
      
      /* Save Definition into Array */
      this._aPctCompleteObj.push({
        'project_id': iProjectID,
        'task_id': iTaskID,
        'div_action_id': sActionCmpId,
        'div_pct_complete': sPctComplCmpId
      });
      
      if (_oActionID.val() == '' || _oActionID.val() == '0')
      {
        // On interdit la modification de la Valeur
        _oPctComplete.attr("disabled", true);
        //_oPctComplete.attr("readonly", true);
      }
      else
      {
        /* Focus Event Affectation */
        _oPctComplete.focus(function() {
          this.select();
        });
      
        /* Change Event Affectation */
        _oPctComplete.change(function() {
          //alert('_oPctComplete : ' + _oPctComplete + ' _oActionID : ' + _oActionID);
          /* RegExp pattern which accept percent format */
          var bValid = (_oPctComplete.val().match("^[0-9]{0,2}$|^(100)$")) ? true : false;
          if (bValid === false)
          {
            /* Change Background color Component */
            _oPctComplete.css('backgroundColor', 'yellow');
            /* Call Ajax Data Format Error */
            var urlGetErrorMsg = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=getErrorMsg&labelId=ERROR_MSG_PCT_COMPL_FORMAT";
            $.get(urlGetErrorMsg, function (xml) {
              /* Callback */
              alert(xml);
            });
            
            return;
          }
          /* Update Component Attributes */
          _oPctComplete.css('backgroundColor', '');
          /* Call Ajax Data Format Valid */
          var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=updatePctComplete&action_id=" + _oActionID.val() + "&pct_complete=" + _oPctComplete.val();
          $.get(urlLoadContent, function (xml) {
            /* Callback */
          });
        });
      }
    },
    
    /**
     * Refresh Percent Complete Task Component
     */
    refreshPctComplete : function(sPctComplCmpId, sPctComplCmpVal, sActionCmpId, sActionCmpVal) {
      var _oPctComplete = null;
      var _oActionID = null;
      
      /* Updating Percent Complete Component Value */
      if (sPctComplCmpId != '')
      {
        var _oPctComplete = $("#" + sPctComplCmpId);
        _oPctComplete.val(sPctComplCmpVal);
      }
      
      /* Updating Last Action ID Component Value */
      if (sActionCmpId != '')
      {
        var _oActionID = $("#" + sActionCmpId);
        _oActionID.val(sActionCmpVal);
        if (sActionCmpVal == '' || sActionCmpVal == '0')
        {
          // No Action ID to Update => set component R/O
          _oPctComplete.attr("disabled", true);
        }
        else if (_oPctComplete != null)
        {
          // Action ID to Update => set component Writable
          _oPctComplete.removeAttr("disabled");
          _oPctComplete.change(function() {
            /* Call Ajax */
            var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=updatePctComplete&action_id=" + _oActionID.val() + "&pct_complete=" + _oPctComplete.val();
            $.get(urlLoadContent, function (xml) {
              /* Callback */
            });
          });
        }
      }
    },
    
    /**
     * Initialization of Metric Task Component
     */
    initTaskMetric : function(sMetricTaskDivId, iProjectID, iTaskID, iSupportPersonID) {
      var _oMetricTask = $("#" + sMetricTaskDivId);
      
      if (_oMetricTask == null)
      {
        alert('Function Error "initTaskMetric"');
        return;
      }
      
      this._aTaskMetricObj.push({
        'div_metric_task' : sMetricTaskDivId,
        'project_id' : iProjectID,
        'task_id' : iTaskID,
        'support_person_id' : iSupportPersonID
      });
    },
    
    /**
     * Refresh Task Metric Component
     */
    refreshTaskMetric : function(iProjectID, iTaskID, iSupportPersonID) {
      var _oMetricTask = null;
      /* Search Component reference */
      for (var i = 0; i < this._aTaskMetricObj.length; i++)
      {
        if (this._aTaskMetricObj[i].task_id == iTaskID && this._aTaskMetricObj[i].support_person_id == iSupportPersonID)
        {
          _oMetricTask = $("#" + this._aTaskMetricObj[i].div_metric_task);
          break;
        }
      }
      
      if (_oMetricTask == null)
      {
        alert('Function Error "refreshTaskMetric"');
        return;
      }
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=refreshTaskMetric&project_id=" + iProjectID + "&task_id=" + iTaskID + "&support_person_id=" + iSupportPersonID;
      _oMetricTask.load(urlLoadContent, function() {
        /* CallBack Function */
        //alert('Metric Updated !!!');
      });
    },
    
    /**
     * Initialization of Metric Calendar Component
     */
    initCalMetric : function(sMetricCalDivId, sCalMetricID) {
      var _oMetricCal = $("#" + sMetricCalDivId);
      
      if (_oMetricCal == null)
      {
        alert('Function Error "initCalMetric"');
        return;
      }
      
      this._aCalMetricObj.push({
        'div_metric_cal' : sMetricCalDivId,
        'cal_day' : sCalMetricID
      });
    },
    
    /**
     * Refresh Calendar Metric Component
     */
    refreshCalMetric : function(sCalMetricID) {
      var _oMetricCal = null;
      /* Search Component reference */
      for (var i = 0; i < this._aCalMetricObj.length; i++)
      {
        if (this._aCalMetricObj[i].cal_day == sCalMetricID)
        {
          _oMetricCal = $("#" + this._aCalMetricObj[i].div_metric_cal);
          break;
        }
      }
      
      if (_oMetricCal == null || this._oSupportPersonFilter == null)
      {
        alert('Function Error "refreshCalMetric"');
        return;
      }
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=refreshCalMetric&task_list_id=&support_person_list_id=" + this._oSupportPersonFilter.val()+ "&cal_metric_id=" + sCalMetricID;
      _oMetricCal.load(urlLoadContent, function() {
        /* CallBack Function */
        //alert('Metric Updated !!!');
      });
    },
    
    /**
     * Refresh Global Metric Component
     */
    refreshGlobalMetric : function() {
      this._oGlobalMetric = $("#" + this._globalMetricId);
      
      if (this._oGlobalMetric == null || this._oSupportPersonFilter == null)
      {
        alert('Function Error "refreshGlobalMetric"');
        return;
      }
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=refreshGlobalMetric&task_list_id=&support_person_list_id=" + this._oSupportPersonFilter.val();
      this._oGlobalMetric.load(urlLoadContent, function() {
        /* CallBack Function */
        //alert('Metric Updated !!!');
      });
    },
    
    /**
     * Change TimeSheet Manager Content By Date Select Update
     */
    changeSelectedDate : function (){
      /* get parameters values */
      this._oSelectedDate = $("#" + this._selectedDateId);
      this._oCalendarHeader = $("#" + this._calendarHeaderId);
      
      if (this._oCalendarHeader == null || this._oSelectedDate == null)
      {
        return;
      }

      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=loadCalendarHeader" + "&selected_date=" + this._oSelectedDate.val();
      //alert(this._oCalendarHeader);
      this._oCalendarHeader.load(urlLoadContent, function() {
        /* CallBack Function */
        $.timeSheetManagerCmp._syncDateLimitFilter();
        $.timeSheetManagerCmp._initCalendarNavigation();
        $.timeSheetManagerCmp.changeTaskParamFilter();
      });
    },
    
    /**
     * Change TimeSheet Manager Content By Filter Parameter Update
     */
    changeTaskParamFilter : function (){
      this._aPctCompleteObj = [];
      this._aTaskMetricObj = [];
      this._aCalMetricObj = [];
      this._oLabelList = $("#" + this._labelListId);
      this._oGridList = $("#" + this._gridListId);
      this._oTaskMetricList = $("#" + this._taskMetricListId);
      this._oCalMetricList = $("#" + this._calMetricListId);
      this._oGlobalMetric = $("#" + this._globalMetricId);
      
      if (this._oLabelList == null || this._oGridList == null || this._oTaskMetricList == null || this._oCalMetricList == null || this._oGlobalMetric == null)
      {
        alert('Function Error "changeTaskParamFilter"');
        return;
      }
      
      /* get parameters values */
      this._oSelectedDate = $("#" + this._selectedDateId);
      this._oManagerFilter = $("#" + this._managerFilterId);
      this._oSupportPersonFilter = $("#" + this._supportPersonFilterId);
      this._oStartDateFilter = $("#" + this._startDateFilterId);
      this._oEndDateFilter = $("#" + this._endDateFilterId);
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=loadTaskGrid" + "&manager_filter=" + this._oManagerFilter.val()  + "&support_person_filter=" + this._oSupportPersonFilter.val() + "&start_date_filter=" + this._oStartDateFilter.val() + "&end_date_filter=" + this._oEndDateFilter.val();
      this._oGridList.load(urlLoadContent, function() {
        /* CallBack Function */
        /* Load Label Task List */
        var urlLoadContentLabel = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=loadTaskLabel&hide_col_num=" + $.timeSheetManagerCmp._sHiddenHdColNumber;
        $.timeSheetManagerCmp._oLabelList.load(urlLoadContentLabel, function() {
          /* CallBack Function */
        });
        /* Load Metric Task List */
        var urlLoadContentTaskMetric = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=loadTaskMetric&task_list_id=&support_person_list_id=" + $.timeSheetManagerCmp._oSupportPersonFilter.val();
        $.timeSheetManagerCmp._oTaskMetricList.load(urlLoadContentTaskMetric, function() {
          /* CallBack Function */
        });
        /* Load Metric Calendar List */
        var urlLoadContentCalMetric = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=loadCalMetric&task_list_id=&support_person_list_id=" + $.timeSheetManagerCmp._oSupportPersonFilter.val();
        $.timeSheetManagerCmp._oCalMetricList.load(urlLoadContentCalMetric, function() {
          /* CallBack Function */
        });
        /* Load Metric Global */
        var urlLoadContentGlobalMetric = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=refreshGlobalMetric&task_list_id=&support_person_list_id=" + $.timeSheetManagerCmp._oSupportPersonFilter.val();
        $.timeSheetManagerCmp._oGlobalMetric.load(urlLoadContentGlobalMetric, function() {
          /* CallBack Function */
        });
      });
    },
    
    /**
     * Go to Previous Week Calendar
     */
    gotoCalendarWeek : function (sType){
      /* Get Current Week Start Date Object */
      var _oHiddenCalStartDate = $("#ts_cal_start_date");

      if ((sType != 'prev' && sType != 'next' ) || _oHiddenCalStartDate == null)
      {
        alert('Function Error "gotoCalendarWeek"');
        return;
      }
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=gotoCalendarWeek&type=" + sType + "&start_date=" + _oHiddenCalStartDate.val();
      $.get(urlLoadContent, function(xml) {
        // CallBack Function
        $.timeSheetManagerCmp._oSelectedDate.val(xml);
        $.timeSheetManagerCmp.changeSelectedDate();
      }); 
    },
    
    /**
     * Update TimeSheet Cell Content into DB
     */
    updateTimeSheet : function(oParam) {
      var _oProjectID = $("#" + oParam.projectID);
      var _oTaskID = $("#" + oParam.taskID);
      var _oActionID = $("#" + oParam.actionID);
      var _oCreationDateID = $("#" + oParam.creationDate);
      var _oElapsedTimeID = $("#" + oParam.elapsedTime);
      var _oCommentID = $("#" + oParam.commentTime);
      var _oDoneByID = $("#" + oParam.doneByID);
      
      if (_oCreationDateID == null || _oElapsedTimeID == null || _oProjectID == null || _oTaskID == null || _oActionID == null || _oCommentID == null || _oDoneByID == null)
      {
        alert('Function Error "updateTimeSheet"');
        return;
      }
      
      /* RegExp pattern which accept Elapsed Time format */      
      var sVal = validDuration(_oElapsedTimeID.val(), true);
      if (sVal === false) 
      {
        /* Change Background color Component */
        _oElapsedTimeID.css('backgroundColor', 'yellow');
        /* Call Ajax Data Format Error */
        var urlGetErrorMsg = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=getErrorMsg&labelId=ERROR_MSG_ELPSD_TME_FORMAT";
        $.get(urlGetErrorMsg, function (xml) {
          /* Callback */
          alert(xml);
        });
        
        return;
      }
      /* Update Component Attributes */
      _oElapsedTimeID.css('backgroundColor', '');
      _oElapsedTimeID.val(sVal);
      
      /* Variable Definition */
      var iTaskID = _oTaskID.val();
      var sLastActionID = '';
      var sLastActionDivID = '';
      var sPctComplete = '';
      var sPctCompleteDivID = '';
      /* Search into Array Percent Complete Informations */
      for (var i = 0; i < this._aPctCompleteObj.length; i++)
      {
        if (this._aPctCompleteObj[i].task_id == iTaskID)
        {
          sLastActionDivID = this._aPctCompleteObj[i].div_action_id;
          var _oLastActionID = $("#" + sLastActionDivID);
          sPctCompleteDivID = this._aPctCompleteObj[i].div_pct_complete;
          var _oPctComplete = $("#" + sPctCompleteDivID);
          if (_oLastActionID != null && _oPctComplete != null)
          {
            sLastActionID = _oLastActionID.val();
            sPctComplete = _oPctComplete.val();
          }
          break;
        }
      }
      
      /* Call Ajax */
      var urlLoadContent = get_main_directory() + "ajax_timesheet.php?session_id=" + get_session_id() + "&lng=" + get_lng() + "&uniqid=" + get_session_uniqid() + "&ajax_action=updateTimeSheet&project_id=" + _oProjectID.val() + "&task_id=" + _oTaskID.val() + "&action_id=" + _oActionID.val() + "&creation_date=" + _oCreationDateID.val() + "&elapsed_time=" + _oElapsedTimeID.val() + "&comment=" + _oCommentID.val() + "&done_by_id=" + _oDoneByID.val() + '&div_action_id=' + oParam.actionID + '&div_elapsed_time=' + oParam.elapsedTime + '&last_action_id=' + sLastActionID + '&div_last_action_id=' + sLastActionDivID + '&pct_complete=' + sPctComplete + '&div_pct_complete=' + sPctCompleteDivID;
      $.get(urlLoadContent, function (data) {
        /* CallBack Function */
        var xmlDoc = data;
        
        if (!window.DOMParser)
        {
          /* Cas particulier d'IE 7 et 8 qui ne reconnait pas le chaîne comme un XML */
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = "false";
          xmlDoc.loadXML(data); 
        }
        
        var iProjectID = $(xmlDoc).find('project_id').text();
        var iTaskID = $(xmlDoc).find('task_id').text();
        var iSupportPersonID = $(xmlDoc).find('support_person_id').text();
        var sCreationDate = $(xmlDoc).find('creation_date').text();
        var sDivId = $(xmlDoc).find('div_action_id').text();
        var oDivId = $("#" + sDivId);
        var sText = $(xmlDoc).find('action_id').text();
        /* on stocke la valeur dans la composant */
        oDivId.val(sText);
        /* Get Percent Complete Value From XML */
        var sPctComplDivId = $(xmlDoc).find('div_pct_complete').text();
        var sPctComplTxt = $(xmlDoc).find('pct_complete').text();
        /* Get Percent Complete Action From XML */
        var sLastActDivId = $(xmlDoc).find('div_last_action_id').text();
        var sLastActTxt = $(xmlDoc).find('last_action_id').text();
        /* Call Updating Task Percent Complete Component Method */
        $.timeSheetManagerCmp.refreshPctComplete(sPctComplDivId, sPctComplTxt, sLastActDivId, sLastActTxt);
        /* Call Updating Task Metric Component Method */
        $.timeSheetManagerCmp.refreshTaskMetric(iProjectID, iTaskID, iSupportPersonID);
        /* Call Updating Calendar Metric Component Method */
        $.timeSheetManagerCmp.refreshCalMetric(sCreationDate);
        /* Call Updating Global Metric Component Method */
        $.timeSheetManagerCmp.refreshGlobalMetric();
        /* DEBUG */
        /*alert(xml); 
        alert('sDivId: ' + sDivId);
        alert('sText: ' + sText);*/
      });
    }
  }
  
})(jQuery);
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/list_double/list_double.js $
// Revision: 12264 $

var arr_list_double = [];

function list_double1(session, root, left_target, left_target_show, right_target, right_target_show, left_name, right_name)
{
	// assing methods
	this.popup              = list_double_popup1;
  this.change_popup_name  = list_double_popup_name1;
	this.change_separator   = list_double_separator1;

	// validate input parameters
	if (!left_target || !right_target || !left_target_show || !right_target_show)
		return list_double_error("Unable to load component : No target control specified");
	if (left_target.value == null || right_target.value == null || left_target_show.value == null || right_target_show.value == null)
		return list_double_error("Unable to load component : Parameter specified is not a valid target control");

	// text
  this.left_target = left_target;
	this.right_target = right_target;
  this.left_target_show = left_target_show;
	this.right_target_show = right_target_show;
  this.left_name = list_double_escape_ezv(left_name);
	this.right_name = list_double_escape_ezv(right_name);
	
	// Main directory
	this.root = root;
	
	this.session = session;
	
	// Nom de la popup
	this.popup_name = 'Popup_js_list_dbl';
	
  // Séparateur de valeur
  this.separator = "";
  
	// register in global collections
	this.id = arr_list_double.length;
	arr_list_double[this.id] = this;
}

// -- Fonction d'échappement des caractères en javascript
function list_double_escape_ezv(str)
{
  str = encodeURIComponent(str);
  
  /*while (str.indexOf("+") != -1)
  {
    str = str.replace("+", "%2B");
  }*/

  return (str);
}

// -- Changement du nom de la popup
function list_double_popup_name1(name)
{
  this.popup_name = name;
}

// -- Changement du séparateur
function list_double_separator1(separator)
{
  this.separator = separator;
}

// -- Affichage de la popup
function list_double_popup1 () 
{
	var obj_list_doublewindow = window.open(
		this.root + 'include/javascript/staff/list_double/list_double.php?id=' + this.id + '&' + this.session +
    '&left_name=' + this.left_name + '&right_name=' + this.right_name + '&separator=' + this.separator, 
    this.popup_name, 'width=600,height=600,scrollbars=yes,status=no,resizable=yes,top=25,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_list_doublewindow.opener = window;
	obj_list_doublewindow.focus();
}

// -- Gestion des erreurs
function list_double_error (str_message) 
{
	alert ("list_double : "+ str_message);
	return null;
}// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/list_double/list_double_profils.js $
// Revision: 12122 $
//
//

/**
 * Gestion des listes de profils
 * 
 * Pré requis : 
 *  - Les éléments suivants :
 *    - input list_double_visible : Id des profils visibles
 *    - input list_double_visible_show : Nom des profils visibles
 *    - input list_double_invisible : Id des profils non visibles
 *    - input list_double_invisible_show : Nom des profils non visibles
 *    - image img_cadenas : Image du cadenas
 * */


/**
 * Création de l'objet "list_double"
 * 
 * @param sVisibleLbl Libellé associé à la zone de gauche de la liste
 * @param sInvisibleLbl Libellé associé à la zone de droite de la liste
 * @return L'objet créé
 */
function create_list_profil(sVisibleLbl, sInvisibleLbl)
{
  var oList = new list_double1(get_session_name() + "=" + get_session_id(), get_main_directory(), 
    document.getElementById("list_double_visible"), document.getElementById("list_double_visible_show"), 
    document.getElementById("list_double_invisible"), document.getElementById("list_double_invisible_show"), 
    sVisibleLbl, sInvisibleLbl);

  return (oList);
}
              
/**
 * Changement de l'image associé au cadenas
 * */
function change_list_double_invisible_show()
{
  if (document.getElementById("img_cadenas") == null)
    return;
    
  if (document.getElementById("list_double_visible").value == "")
  {
    document.getElementById("img_cadenas").src = get_main_directory() + get_atmosphere() + "/Cadenas.png";
  }
  else if (document.getElementById("list_double_invisible").value == "")
  {
    document.getElementById("img_cadenas").src = get_main_directory() + get_atmosphere() + "/Cadenas.png";
  }
  else
  {
    document.getElementById("img_cadenas").src = get_main_directory() + get_atmosphere() + "/CadenasOuvert.png";
  }
}
/**
 * Décide du type de changement
 * */
function change_list_double()
{
  // Par défaut, on rend le menu visible par tous
  if (document.getElementById("list_double_invisible").value != "")
  set_list_double_visible();
  else
  set_list_double_invisible();
  
  // On met à jour les infos
  change_list_double_invisible_show();
}

/**
 * On rend le menu invisible pour tout le monde
 * */
function set_list_double_invisible()
{
  str_visible = document.getElementById("list_double_visible").value;
  str_visible_show = document.getElementById("list_double_visible_show").value;
  str_invisible = document.getElementById("list_double_invisible").value;
  str_invisible_show = document.getElementById("list_double_invisible_show").value;
  
  if (str_visible != "" && str_invisible != "")
  {
    // Ajout du séparateur
    str_invisible += "@@//@@" + str_visible;
    str_invisible_show += "@@//@@" + str_visible_show;
  }
  else if (str_visible != "")
  {
    // Tous les profils voyaient le menu
    str_invisible = str_visible;
    str_invisible_show = str_visible_show;
  }
  
  // On efface la partie Visible
  str_visible = "";
  str_visible_show = "";
  
  document.getElementById("list_double_visible").value = str_visible;
  document.getElementById("list_double_visible_show").value = str_visible_show;
  document.getElementById("list_double_invisible").value = str_invisible;
  document.getElementById("list_double_invisible_show").value = str_invisible_show;
}

/**
 * On rend le menu visible pour tout le monde
 * */
function set_list_double_visible()
{
  str_visible = document.getElementById("list_double_visible").value;
  str_visible_show = document.getElementById("list_double_visible_show").value;
  str_invisible = document.getElementById("list_double_invisible").value;
  str_invisible_show = document.getElementById("list_double_invisible_show").value;
  
  if (str_visible != "" && str_invisible != "")
  {
    // Ajout du séparateur
    str_visible += "@@//@@" + str_invisible;
    str_visible_show += "@@//@@" + str_invisible_show;
  }
  else if (str_invisible != "")
  {
    // Tous les profils voyaient le menu
    str_visible = str_invisible;
    str_visible_show = str_invisible_show;
  }
  
  // On efface la partie Visible
  str_invisible = "";
  str_invisible_show = "";
  
  document.getElementById("list_double_visible").value = str_visible;
  document.getElementById("list_double_visible_show").value = str_visible_show;
  document.getElementById("list_double_invisible").value = str_invisible;
  document.getElementById("list_double_invisible_show").value = str_invisible_show;
}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/list/list.js $
// Revision: 12122 $

var lists = [];

function list1(obj_target, obj_target_hide, table, field, field_hide, is_int, session, root)
{
	// assing methods
	this.popup               = lst_popup1;
	this.change_popup_name   = lst_popup_name1;
	this.set_theme           = lst_set_theme;

	// validate input parameters
	if (!obj_target)
		return lst_error("Unable to load component : No target control specified");
	if (obj_target.value == null)
		return lst_error("Unable to load component : Parameter specified is not a valid target control");

	// text
	this.target = obj_target;
	this.target_hide = obj_target_hide;
	
	// Main directory
	this.root = root;
	
	this.table = table;
	this.field = field;
	this.field_hide = field_hide;
	
	this.session = session;
	
	this.is_int = is_int;
	
	this.theme = '';
	
	// Nom de la popup
	this.popup_name = 'Popup_js_list';
	
	// register in global collections
	this.id = lists.length;
	lists[this.id] = this;
}

// -- Changement du nom de la popup
function lst_popup_name1(name)
{
  this.popup_name = name;
}

// -- Passage du thème dans l'URL
function lst_set_theme(theme)
{
  this.theme = theme;
}

function lst_popup1 ()
{
  var tmp = '';
  if (this.theme != '')
  {
    tmp = '&theme=' + this.theme;
  }

	var obj_lstwindow = window.open(
		this.root + 'include/javascript/staff/list/list.php?table=' + this.table + '&field=' + this.field + 
		'&is_int=' + this.is_int + '&key=' + this.field_hide +'&value=' + this.target_hide.value + 
		'&id=' + this.id + '&' + this.session + tmp,
		this.popup_name, 'width=600,height=300'+
		',scrollbars=yes,status=no,resizable=yes,top=200,left=200,dependent=yes,alwaysRaised=yes'
	);
	obj_lstwindow.opener = window;
	obj_lstwindow.focus();
}

function lst_error (str_message) {
	alert ("List : " + str_message);
	return null;
}
/*
 * jQuery File Upload Plugin 3.8.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://creativecommons.org/licenses/MIT/
 */

/*jslint browser: true */
/*global File, FileReader, FormData, unescape, jQuery */

(function ($) {

    var defaultNamespace = 'file_upload',
        undef = 'undefined',
        func = 'function',
        num = 'number',
        FileUpload,
        methods,

        MultiLoader = function (callBack, numberComplete) {
            var loaded = 0;
            this.complete = function () {
                loaded += 1;
                if (loaded === numberComplete) {
                    callBack();
                }
            };
        };
        
    FileUpload = function (container) {
        var fileUpload = this,
            uploadForm,
            fileInput,
            settings = {
                namespace: defaultNamespace,
                uploadFormFilter: function (index) {
                    return true;
                },
                fileInputFilter: function (index) {
                    return true;
                },
                cssClass: defaultNamespace,
                dragDropSupport: true,
                dropZone: container,
                url: function (form) {
                    return form.attr('action');
                },
                method: function (form) {
                    return form.attr('method');
                },
                fieldName: function (input) {
                    return input.attr('name');
                },
                formData: function (form) {
                    return form.serializeArray();
                },
                multipart: true,
                multiFileRequest: false,
                withCredentials: false,
                forceIframeUpload: false
            },
            documentListeners = {},
            dropZoneListeners = {},
            protocolRegExp = /^http(s)?:\/\//,
            optionsReference,

            isXHRUploadCapable = function () {
                return typeof XMLHttpRequest !== undef && typeof File !== undef && (
                    !settings.multipart || typeof FormData !== undef || typeof FileReader !== undef
                );
            },

            initEventHandlers = function () {
                if (settings.dragDropSupport) {
                    if (typeof settings.onDocumentDragEnter === func) {
                        documentListeners['dragenter.' + settings.namespace] = function (e) {
                            settings.onDocumentDragEnter(e);
                        };
                    }
                    if (typeof settings.onDocumentDragLeave === func) {
                        documentListeners['dragleave.' + settings.namespace] = function (e) {
                            settings.onDocumentDragLeave(e);
                        };
                    }
                    documentListeners['dragover.'   + settings.namespace] = fileUpload.onDocumentDragOver;
                    documentListeners['drop.'       + settings.namespace] = fileUpload.onDocumentDrop;
                    $(document).bind(documentListeners);
                    if (typeof settings.onDragEnter === func) {
                        dropZoneListeners['dragenter.' + settings.namespace] = function (e) {
                            settings.onDragEnter(e);
                        };
                    }
                    if (typeof settings.onDragLeave === func) {
                        dropZoneListeners['dragleave.' + settings.namespace] = function (e) {
                            settings.onDragLeave(e);
                        };
                    }
                    dropZoneListeners['dragover.'   + settings.namespace] = fileUpload.onDragOver;
                    dropZoneListeners['drop.'       + settings.namespace] = fileUpload.onDrop;
                    settings.dropZone.bind(dropZoneListeners);
                }
                fileInput.bind('change.' + settings.namespace, fileUpload.onChange);
            },

            removeEventHandlers = function () {
                $.each(documentListeners, function (key, value) {
                    $(document).unbind(key, value);
                });
                $.each(dropZoneListeners, function (key, value) {
                    settings.dropZone.unbind(key, value);
                });
                fileInput.unbind('change.' + settings.namespace);
            },

            initUploadEventHandlers = function (files, index, xhr, settings) {
                if (typeof settings.onProgress === func) {
                    xhr.upload.onprogress = function (e) {
                        settings.onProgress(e, files, index, xhr, settings);
                    };
                }
                if (typeof settings.onLoad === func) {
                    xhr.onload = function (e) {
                        settings.onLoad(e, files, index, xhr, settings);
                    };
                }
                if (typeof settings.onAbort === func) {
                    xhr.onabort = function (e) {
                        settings.onAbort(e, files, index, xhr, settings);
                    };
                }
                if (typeof settings.onError === func) {
                    xhr.onerror = function (e) {
                        settings.onError(e, files, index, xhr, settings);
                    };
                }
            },

            getUrl = function (settings) {
                if (typeof settings.url === func) {
                    return settings.url(settings.uploadForm || uploadForm);
                }
                return settings.url;
            },
            
            getMethod = function (settings) {
                if (typeof settings.method === func) {
                    return settings.method(settings.uploadForm || uploadForm);
                }
                return settings.method;
            },
            
            getFieldName = function (settings) {
                if (typeof settings.fieldName === func) {
                    return settings.fieldName(settings.fileInput || fileInput);
                }
                return settings.fieldName;
            },

            getFormData = function (settings) {
                var formData;
                if (typeof settings.formData === func) {
                    return settings.formData(settings.uploadForm || uploadForm);
                } else if ($.isArray(settings.formData)) {
                    return settings.formData;
                } else if (settings.formData) {
                    formData = [];
                    $.each(settings.formData, function (name, value) {
                        formData.push({name: name, value: value});
                    });
                    return formData;
                }
                return [];
            },

            isSameDomain = function (url) {
                if (protocolRegExp.test(url)) {
                    var host = location.host,
                        indexStart = location.protocol.length + 2,
                        index = url.indexOf(host, indexStart),
                        pathIndex = index + host.length;
                    if ((index === indexStart || index === url.indexOf('@', indexStart) + 1) &&
                            (url.length === pathIndex || $.inArray(url.charAt(pathIndex), ['/', '?', '#']) !== -1)) {
                        return true;
                    }
                    return false;
                }
                return true;
            },

            setRequestHeaders = function (xhr, settings, sameDomain) {
                if (sameDomain) {
                    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                } else if (settings.withCredentials) {
                    xhr.withCredentials = true;
                }
                if ($.isArray(settings.requestHeaders)) {
                    $.each(settings.requestHeaders, function (index, header) {
                        xhr.setRequestHeader(header[0], header[1]);
                    });
                } else if (settings.requestHeaders) {
                    $.each(settings.requestHeaders, function (name, value) {
                        xhr.setRequestHeader(name, value);
                    });
                }
            },

            nonMultipartUpload = function (file, xhr, sameDomain) {
                if (sameDomain) {
                    xhr.setRequestHeader('X-File-Name', unescape(encodeURIComponent(file.name)));
                }
                xhr.setRequestHeader('Content-Type', file.type);
                xhr.send(file);
            },

            formDataUpload = function (files, xhr, settings) {
                var formData = new FormData(),
                    i;
                $.each(getFormData(settings), function (index, field) {
                    formData.append(field.name, field.value);
                });
                for (i = 0; i < files.length; i += 1) {
                    formData.append(getFieldName(settings), files[i]);
                }
                xhr.send(formData);
            },

            loadFileContent = function (file, callBack) {
                var fileReader = new FileReader();
                fileReader.onload = function (e) {
                    file.content = e.target.result;
                    callBack();
                };
                fileReader.readAsBinaryString(file);
            },

            buildMultiPartFormData = function (boundary, files, filesFieldName, fields) {
                var doubleDash = '--',
                    crlf     = '\r\n',
                    formData = '';
                $.each(fields, function (index, field) {
                    formData += doubleDash + boundary + crlf +
                        'Content-Disposition: form-data; name="' +
                        unescape(encodeURIComponent(field.name)) +
                        '"' + crlf + crlf +
                        unescape(encodeURIComponent(field.value)) + crlf;
                });
                $.each(files, function (index, file) {
                    formData += doubleDash + boundary + crlf +
                        'Content-Disposition: form-data; name="' +
                        unescape(encodeURIComponent(filesFieldName)) +
                        '"; filename="' + unescape(encodeURIComponent(file.name)) + '"' + crlf +
                        'Content-Type: ' + file.type + crlf + crlf +
                        file.content + crlf;
                });
                formData += doubleDash + boundary + doubleDash + crlf;
                return formData;
            },
            
            fileReaderUpload = function (files, xhr, settings) {
                var boundary = '----MultiPartFormBoundary' + (new Date()).getTime(),
                    loader,
                    i;
                xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);
                loader = new MultiLoader(function () {
                    xhr.sendAsBinary(buildMultiPartFormData(
                        boundary,
                        files,
                        getFieldName(settings),
                        getFormData(settings)
                    ));
                }, files.length);
                for (i = 0; i < files.length; i += 1) {
                    loadFileContent(files[i], loader.complete);
                }
            },

            upload = function (files, index, xhr, settings) {
                var url = getUrl(settings),
                    sameDomain = isSameDomain(url),
                    filesToUpload;
                initUploadEventHandlers(files, index, xhr, settings);
                xhr.open(getMethod(settings), url, true);
                setRequestHeaders(xhr, settings, sameDomain);
                if (!settings.multipart) {
                    nonMultipartUpload(files[index], xhr, sameDomain);
                } else {
                    if (typeof index === num) {
                        filesToUpload = [files[index]];
                    } else {
                        filesToUpload = files;
                    }
                    if (typeof FormData !== undef) {
                        formDataUpload(filesToUpload, xhr, settings);
                    } else if (typeof FileReader !== undef) {
                        fileReaderUpload(filesToUpload, xhr, settings);
                    } else {
                        $.error('Browser does neither support FormData nor FileReader interface');
                    }
                }
            },

            handleUpload = function (event, files, input, form, index) {
                var xhr = new XMLHttpRequest(),
                    uploadSettings = $.extend({}, settings);
                uploadSettings.fileInput = input;
                uploadSettings.uploadForm = form;
                if (typeof uploadSettings.initUpload === func) {
                    uploadSettings.initUpload(
                        event,
                        files,
                        index,
                        xhr,
                        uploadSettings,
                        function () {
                            upload(files, index, xhr, uploadSettings);
                        }
                    );
                } else {
                    upload(files, index, xhr, uploadSettings);
                }
            },

            handleFiles = function (event, files, input, form) {
                var i;
                if (settings.multiFileRequest) {
                    handleUpload(event, files, input, form);
                } else {
                    for (i = 0; i < files.length; i += 1) {
                        handleUpload(event, files, input, form, i);
                    }
                }
            },

            legacyUploadFormDataInit = function (input, form, settings) {
                var formData = getFormData(settings);
                form.find(':input').not(':disabled')
                    .attr('disabled', true)
                    .addClass(settings.namespace + '_disabled');
                $.each(formData, function (index, field) {
                    $('<input type="hidden"/>')
                        .attr('name', field.name)
                        .val(field.value)
                        .addClass(settings.namespace + '_form_data')
                        .appendTo(form);
                });
                input
                    .attr('name', getFieldName(settings))
                    .appendTo(form);
            },

            legacyUploadFormDataReset = function (input, form, settings) {
                input.detach();
                form.find('.' + settings.namespace + '_disabled')
                    .removeAttr('disabled')
                    .removeClass(settings.namespace + '_disabled');
                form.find('.' + settings.namespace + '_form_data').remove();
            },

            legacyUpload = function (input, form, iframe, settings) {
                var originalAction = form.attr('action'),
                    originalMethod = form.attr('method'),
                    originalTarget = form.attr('target');
                iframe
                    .unbind('abort')
                    .bind('abort', function (e) {
                        iframe.readyState = 0;
                        // javascript:false as iframe src prevents warning popups on HTTPS in IE6
                        // concat is used here to prevent the "Script URL" JSLint error:
                        iframe.unbind('load').attr('src', 'javascript'.concat(':false;'));
                        if (typeof settings.onAbort === func) {
                            settings.onAbort(e, [{name: input.val(), type: null, size: null}], 0, iframe, settings);
                        }
                    })
                    .unbind('load')
                    .bind('load', function (e) {
                        iframe.readyState = 4;
                        if (typeof settings.onLoad === func) {
                            settings.onLoad(e, [{name: input.val(), type: null, size: null}], 0, iframe, settings);
                        }
                        // Fix for IE endless progress bar activity bug (happens on form submits to iframe targets):
                        $('<iframe src="javascript:false;" style="display:none"></iframe>').appendTo(form).remove();
                    });
                form
                    .attr('action', getUrl(settings))
                    .attr('method', getMethod(settings))
                    .attr('target', iframe.attr('name'));
                legacyUploadFormDataInit(input, form, settings);
                iframe.readyState = 2;
                form.get(0).submit();
                legacyUploadFormDataReset(input, form, settings);
                form
                    .attr('action', originalAction)
                    .attr('method', originalMethod)
                    .attr('target', originalTarget);
            },

            handleLegacyUpload = function (event, input, form) {
                // javascript:false as iframe src prevents warning popups on HTTPS in IE6:
                var iframe = $('<iframe src="javascript:false;" style="display:none" name="iframe_' +
                    settings.namespace + '_' + (new Date()).getTime() + '"></iframe>'),
                    uploadSettings = $.extend({}, settings);
                uploadSettings.fileInput = input;
                uploadSettings.uploadForm = form;
                iframe.readyState = 0;
                iframe.abort = function () {
                    iframe.trigger('abort');
                };
                iframe.bind('load', function () {
                    iframe.unbind('load');
                    if (typeof uploadSettings.initUpload === func) {
                        uploadSettings.initUpload(
                            event,
                            [{name: input.val(), type: null, size: null}],
                            0,
                            iframe,
                            uploadSettings,
                            function () {
                                legacyUpload(input, form, iframe, uploadSettings);
                            }
                        );
                    } else {
                        legacyUpload(input, form, iframe, uploadSettings);
                    }
                }).appendTo(form);
            },
            
            initUploadForm = function () {
                uploadForm = (container.is('form') ? container : container.find('form'))
                    .filter(settings.uploadFormFilter);
            },
            
            initFileInput = function () {
                fileInput = uploadForm.find('input:file')
                    .filter(settings.fileInputFilter);
            },
            
            replaceFileInput = function (input) {
                var inputClone = input.clone(true);
                $('<form/>').append(inputClone).get(0).reset();
                input.after(inputClone).detach();
                initFileInput();
            };

        this.onDocumentDragOver = function (e) {
            if (typeof settings.onDocumentDragOver === func &&
                    settings.onDocumentDragOver(e) === false) {
                return false;
            }
            e.preventDefault();
        };
        
        this.onDocumentDrop = function (e) {
            if (typeof settings.onDocumentDrop === func &&
                    settings.onDocumentDrop(e) === false) {
                return false;
            }
            e.preventDefault();
        };

        this.onDragOver = function (e) {
            if (typeof settings.onDragOver === func &&
                    settings.onDragOver(e) === false) {
                return false;
            }
            var dataTransfer = e.originalEvent.dataTransfer;
            if (dataTransfer && dataTransfer.files) {
                dataTransfer.dropEffect = dataTransfer.effectAllowed = 'copy';
                e.preventDefault();
            }
        };

        this.onDrop = function (e) {
            if (typeof settings.onDrop === func &&
                    settings.onDrop(e) === false) {
                return false;
            }
            var dataTransfer = e.originalEvent.dataTransfer;
            if (dataTransfer && dataTransfer.files && isXHRUploadCapable()) {
                handleFiles(e, dataTransfer.files);
            }
            e.preventDefault();
        };
        
        this.onChange = function (e) {
            if (typeof settings.onChange === func &&
                    settings.onChange(e) === false) {
                return false;
            }
            var input = $(e.target),
                form = $(e.target.form);
            if (form.length === 1) {
                input.data(defaultNamespace + '_form', form);
                replaceFileInput(input);
            } else {
                form = input.data(defaultNamespace + '_form');
            }
            if (!settings.forceIframeUpload && e.target.files && isXHRUploadCapable()) {
                handleFiles(e, e.target.files, input, form);
            } else {
                handleLegacyUpload(e, input, form);
            }
        };

        this.init = function (options) {
            if (options) {
                $.extend(settings, options);
                optionsReference = options;
            }
            initUploadForm();
            initFileInput();
            if (container.data(settings.namespace)) {
                $.error('FileUpload with namespace "' + settings.namespace + '" already assigned to this element');
                return;
            }
            container
                .data(settings.namespace, fileUpload)
                .addClass(settings.cssClass);
            settings.dropZone.not(container).addClass(settings.cssClass);
            initEventHandlers();
        };

        this.options = function (options) {
            var oldCssClass,
                oldDropZone,
                uploadFormFilterUpdate,
                fileInputFilterUpdate;
            if (typeof options === undef) {
                return $.extend({}, settings);
            }
            if (optionsReference) {
                $.extend(optionsReference, options);
            }
            removeEventHandlers();
            $.each(options, function (name, value) {
                switch (name) {
                case 'namespace':
                    $.error('The FileUpload namespace cannot be updated.');
                    return;
                case 'uploadFormFilter':
                    uploadFormFilterUpdate = true;
                    fileInputFilterUpdate = true;
                    break;
                case 'fileInputFilter':
                    fileInputFilterUpdate = true;
                    break;
                case 'cssClass':
                    oldCssClass = settings.cssClass;
                    break;
                case 'dropZone':
                    oldDropZone = settings.dropZone;
                    break;
                }
                settings[name] = value;
            });
            if (uploadFormFilterUpdate) {
                initUploadForm();
            }
            if (fileInputFilterUpdate) {
                initFileInput();
            }
            if (typeof oldCssClass !== undef) {
                container
                    .removeClass(oldCssClass)
                    .addClass(settings.cssClass);
                (oldDropZone ? oldDropZone : settings.dropZone).not(container)
                    .removeClass(oldCssClass);
                settings.dropZone.not(container).addClass(settings.cssClass);
            } else if (oldDropZone) {
                oldDropZone.not(container).removeClass(settings.cssClass);
                settings.dropZone.not(container).addClass(settings.cssClass);
            }
            initEventHandlers();
        };
        
        this.option = function (name, value) {
            var options;
            if (typeof value === undef) {
                return settings[name];
            }
            options = {};
            options[name] = value;
            fileUpload.options(options);
        };
        
        this.destroy = function () {
            removeEventHandlers();
            container
                .removeData(settings.namespace)
                .removeClass(settings.cssClass);
            settings.dropZone.not(container).removeClass(settings.cssClass);
        };
    };

    methods = {
        init : function (options) {
            return this.each(function () {
                (new FileUpload($(this))).init(options);
            });
        },
        
        option: function (option, value, namespace) {
            namespace = namespace ? namespace : defaultNamespace;
            var fileUpload = $(this).data(namespace);
            if (fileUpload) {
                if (typeof option === 'string') {
                    return fileUpload.option(option, value);
                }
                return fileUpload.options(option);
            } else {
                $.error('No FileUpload with namespace "' + namespace + '" assigned to this element');
            }
        },
                
        destroy : function (namespace) {
            namespace = namespace ? namespace : defaultNamespace;
            return this.each(function () {
                var fileUpload = $(this).data(namespace);
                if (fileUpload) {
                    fileUpload.destroy();
                } else {
                    $.error('No FileUpload with namespace "' + namespace + '" assigned to this element');
                }
            });

        }
    };
    
    $.fn.fileUpload = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.fileUpload');
        }
    };
    
}(jQuery));/*
 * jQuery File Upload User Interface Plugin 3.7.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://creativecommons.org/licenses/MIT/
 */

/*jslint browser: true */
/*global jQuery, FileReader, URL */

(function ($) {

    var undef = 'undefined',
        func = 'function',
        UploadHandler,
        methods,

        LocalImage = function (file, imageTypes) {
            var img,
                fileReader;
            if (!imageTypes.test(file.type)) {
                return null;
            }
            img = document.createElement('img');
            if (typeof URL !== undef && typeof URL.createObjectURL === func) {
                img.src = URL.createObjectURL(file);
                img.onload = function () {
                    URL.revokeObjectURL(this.src);
                };
                return img;
            }
            if (typeof FileReader !== undef) {
                fileReader = new FileReader();
                if (typeof fileReader.readAsDataURL === func) {
                    fileReader.onload = function (e) {
                        img.src = e.target.result;
                    };
                    fileReader.readAsDataURL(file);
                    return img;
                }
            }
            return null;
        };
        
    UploadHandler = function (container, options) {
        var uploadHandler = this,
            dragOverTimeout,
            isDropZoneEnlarged;
        
        this.requestHeaders = {'Accept': 'application/json, text/javascript, */*; q=0.01'};
        this.dropZone = container;
        this.imageTypes = /^image\/(gif|jpeg|png)$/;
        this.previewSelector = '.file_upload_preview';
        this.progressSelector = '.file_upload_progress div';
        this.cancelSelector = '.file_upload_cancel button';
        this.cssClassSmall = 'file_upload_small';
        this.cssClassLarge = 'file_upload_large';
        this.cssClassHighlight = 'file_upload_highlight';
        this.dropEffect = 'highlight';
        this.uploadTable = this.downloadTable = null;
        
        this.buildUploadRow = this.buildDownloadRow = function () {
            return null;
        };

        this.addNode = function (parentNode, node, callBack) {
            if (node) {
                node.css('display', 'none').appendTo(parentNode).fadeIn(function () {
                    if (typeof callBack === func) {
                        try {
                            callBack();
                        } catch (e) {
                            // Fix endless exception loop:
                            $(this).stop();
                            throw e;
                        }
                    }
                });
            } else if (typeof callBack === func) {
                callBack();
            }
        };

        this.removeNode = function (node, callBack) {
            if (node) {
                node.fadeOut(function () {
                    $(this).remove();
                    if (typeof callBack === func) {
                        try {
                            callBack();
                        } catch (e) {
                            // Fix endless exception loop:
                            $(this).stop();
                            throw e;
                        }
                    }
                });
            } else if (typeof callBack === func) {
                callBack();
            }
        };

        this.onAbort = function (event, files, index, xhr, handler) {
            handler.removeNode(handler.uploadRow);
        };
        
        this.cancelUpload = function (event, files, index, xhr, handler) {
            var readyState = xhr.readyState;
            xhr.abort();
            // If readyState is below 2, abort() has no effect:
            if (isNaN(readyState) || readyState < 2) {
                handler.onAbort(event, files, index, xhr, handler);
            }
        };
        
        this.initProgressBar = function (node, value) {
            if (typeof node.progressbar === func) {
                return node.progressbar({
                    value: value
                });
            } else {
                var progressbar = $('<progress value="' + value + '" max="100"/>').appendTo(node);
                progressbar.progressbar = function (key, value) {
                    progressbar.attr('value', value);
                };
                return progressbar;
            }
        };
        
        this.initUploadRow = function (event, files, index, xhr, handler, callBack) {
            var uploadRow = handler.uploadRow = handler.buildUploadRow(files, index, handler);
            if (uploadRow) {
                handler.progressbar = handler.initProgressBar(
                    uploadRow.find(handler.progressSelector),
                    0
                );
                uploadRow.find(handler.cancelSelector).click(function (e) {
                    handler.cancelUpload(e, files, index, xhr, handler);
                });
                uploadRow.find(handler.previewSelector).each(function () {
                    $(this).append(new LocalImage(files[index], handler.imageTypes));
                });
            }
            handler.addNode(
                (typeof handler.uploadTable === func ? handler.uploadTable(handler) : handler.uploadTable),
                uploadRow,
                callBack
            );
        };
        
        this.initUploadProgress = function (xhr, handler) {
            if (!xhr.upload) {
                handler.progressbar.progressbar(
                    'value',
                    100 // indeterminate progress displayed by a full animated progress bar
                );
            }
        };
        
        this.initUpload = function (event, files, index, xhr, handler, callBack) {
            handler.initUploadRow(event, files, index, xhr, handler, function () {
                if (typeof handler.beforeSend === func) {
                    handler.beforeSend(event, files, index, xhr, handler, function () {
                        handler.initUploadProgress(xhr, handler);
                        callBack();
                    });
                } else {
                    handler.initUploadProgress(xhr, handler);
                    callBack();
                }
            });
        };
        
        this.onProgress = function (event, files, index, xhr, handler) {
            if (handler.progressbar) {
                handler.progressbar.progressbar(
                    'value',
                    parseInt(event.loaded / event.total * 100, 10)
                );
            }
        };
        
        this.parseResponse = function (xhr) {
            if (typeof xhr.responseText !== undef) {
                return $.parseJSON(xhr.responseText);
            } else {
                // Instead of an XHR object, an iframe is used for legacy browsers:
                return $.parseJSON(xhr.contents().text());
            }
        };
        
        this.initDownloadRow = function (event, files, index, xhr, handler, callBack) {
            var json, downloadRow;
            try {
                json = handler.response = handler.parseResponse(xhr);
                downloadRow = handler.downloadRow = handler.buildDownloadRow(json, handler);
                handler.addNode(
                    (typeof handler.downloadTable === func ? handler.downloadTable(handler) : handler.downloadTable),
                    downloadRow,
                    callBack
                );
            } catch (e) {
                if (typeof handler.onError === func) {
                    handler.originalEvent = event;
                    handler.onError(e, files, index, xhr, handler);
                } else {
                    throw e;
                }
            }
        };
        
        this.onLoad = function (event, files, index, xhr, handler) {
            handler.removeNode(handler.uploadRow, function () {
                handler.initDownloadRow(event, files, index, xhr, handler, function () {
                    if (typeof handler.onComplete === func) {
                        handler.onComplete(event, files, index, xhr, handler);
                    }
                });
            });
        };

        this.dropZoneEnlarge = function () {
            if (!isDropZoneEnlarged) {
                if (typeof uploadHandler.dropZone.switchClass === func) {
                    uploadHandler.dropZone.switchClass(
                        uploadHandler.cssClassSmall,
                        uploadHandler.cssClassLarge
                    );
                } else {
                    uploadHandler.dropZone.addClass(uploadHandler.cssClassLarge);
                    uploadHandler.dropZone.removeClass(uploadHandler.cssClassSmall);
                }
                isDropZoneEnlarged = true;
            }
        };
        
        this.dropZoneReduce = function () {
            if (typeof uploadHandler.dropZone.switchClass === func) {
                uploadHandler.dropZone.switchClass(
                    uploadHandler.cssClassLarge,
                    uploadHandler.cssClassSmall
                );
            } else {
                uploadHandler.dropZone.addClass(uploadHandler.cssClassSmall);
                uploadHandler.dropZone.removeClass(uploadHandler.cssClassLarge);
            }
            isDropZoneEnlarged = false;
        };

        this.onDocumentDragEnter = function (event) {
            uploadHandler.dropZoneEnlarge();
        };
        
        this.onDocumentDragOver = function (event) {
            if (dragOverTimeout) {
                clearTimeout(dragOverTimeout);
            }
            dragOverTimeout = setTimeout(function () {
                uploadHandler.dropZoneReduce();
            }, 200);
        };
        
        this.onDragEnter = this.onDragLeave = function (event) {
            uploadHandler.dropZone.toggleClass(uploadHandler.cssClassHighlight);
        };
        
        this.onDrop = function (event) {
            if (dragOverTimeout) {
                clearTimeout(dragOverTimeout);
            }
            if (uploadHandler.dropEffect && typeof uploadHandler.dropZone.effect === func) {
                uploadHandler.dropZone.effect(uploadHandler.dropEffect, function () {
                    uploadHandler.dropZone.removeClass(uploadHandler.cssClassHighlight);
                    uploadHandler.dropZoneReduce();
                });
            } else {
                uploadHandler.dropZone.removeClass(uploadHandler.cssClassHighlight);
                uploadHandler.dropZoneReduce();
            }
        };

        $.extend(this, options);
    };

    methods = {
        init : function (options) {
            return this.each(function () {
                $(this).fileUpload(new UploadHandler($(this), options));
            });
        },
        
        option: function (option, value, namespace) {
            if (typeof option === undef || (typeof option === 'string' && typeof value === undef)) {
                return $(this).fileUpload('option', option, value, namespace);
            }
            return this.each(function () {
                $(this).fileUpload('option', option, value, namespace);
            });
        },
            
        destroy : function (namespace) {
            return this.each(function () {
                $(this).fileUpload('destroy', namespace);
            });
        }
    };
    
    $.fn.fileUploadUI = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.fileUploadUI');
        }
    };
    
}(jQuery));/*
 * // HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/extern/jquery/jquery.comboBox-ui/jquery.comboBox-ui.js $
 * // Revision: 15512 $
 *
 * jQuery UI Autocomplete ComboBox
 *
 * Modified version of (http://jqueryui.com/demos/autocomplete/combobox.html)
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 *  jquery.ui.autocomplete.js
 */
 
$.fn.textWidth = function(){
	var calc = '<span style="display:none">' + $(this).text() + '</span>';
	$('body').append(calc);
	var width = $('body').find('span:last').width();
	$('body').find('span:last').remove();
	return width;
}; 
 
 (function( $ ) {
	$.widget( "ui.combobox", {
		_create: function() {
			var isInitialized = this.element.prop( "combobox-ui" ) ? true : false;
			var isListBox = ( this.element.attr("size")>1 ) ? true : false;
			if (isInitialized || isListBox) return; else this.element.prop( "combobox-ui", true );
			
			var self = this,
				autoresize = this.autoresize = false,
				select = this.element.hide(),
				selected = select.children( ":selected" ),
				selectWidth = ( select.width() == 0 ) ? 100 : select.width(),
				value = ( selected.val() || selected.text() ) ? selected.text() : "",
				title = selected.attr("title") ? selected.attr("title") : value,
				spanText = $("<span>").addClass("form_combo").html(value),
				inputWidth = ( spanText.textWidth() < selectWidth && this.autoresize ) ? spanText.textWidth() + $(".imgDown_searchBox").width() : selectWidth;
			
			var layout = this.layout = $( "<span>" )
				.insertAfter( select )
				.addClass( "searchBoxFields" )
				.append( $( "<a>" ) );
			
			var input = this.input = $( "<input>" )
				.appendTo( layout.children( "a" ).first() )
				.val( value )
				.width( inputWidth )
				.attr("title", title)
				.autocomplete({
					delay: 0,
					minLength: 0,
					source: function( request, response ) {
						var matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term), "i" );
						response( select.children( "option" ).map(function() {
							var text = $( this ).text();
							//-- Manage empty value/text
							if ( ( $.trim(this.value) == "" || $.trim(text) == "" ) && ( !request.term || matcher.test(text) ) )
								return {
									label: text.replace(
										new RegExp(
											"(?![^&;]+;)(?!<[^<>]*)(" +
											$.ui.autocomplete.escapeRegex(request.term) +
											")(?![^<>]*>)(?![^&;]+;)", "gi"
										), "<span class=\"charSelected\">$1</span>&nbsp;" ),
									value: text,
									title: $( this ).attr("title") ? $( this ).attr("title") : text,
									option: this
								};
							//-- Default code
							if ( this.value && ( !request.term || matcher.test(text) ) )
								return {
									label: text.replace(
										new RegExp(
											"(?![^&;]+;)(?!<[^<>]*)(" +
											$.ui.autocomplete.escapeRegex(request.term) +
											")(?![^<>]*>)(?![^&;]+;)", "gi"
										), "<span class=\"charSelected\">$1</span>" ),
									value: text,
									title: $( this ).attr("title") ? $( this ).attr("title") : text,
									option: this
								};
						}) );
					},
					select: function( event, ui ) {
						ui.item.option.selected = true;
						self._trigger( "selected", event, {
							item: ui.item.option
						});
						selectWidth = ( select.width() == 0 ) ? 100 : select.width();
						spanText = $("<span>").addClass("form_combo").html(ui.item.value);
						inputWidth = ( spanText.textWidth() < selectWidth && self.autoresize ) ? spanText.textWidth() + $(".imgDown_searchBox").width() : selectWidth;
						input.attr("title", ui.item.title)
							.width( inputWidth );
						select.trigger("change");
					},
					change: function( event, ui ) {
						if ( !ui.item ) {
							var matcher = new RegExp( "^" + $.ui.autocomplete.escapeRegex( $(this).val() ) + "$", "i" ),
								valid = false;
							select.children( "option" ).each(function() {
								if ( $( this ).text().match( matcher ) ) {
									this.selected = valid = true;
									return false;
								}
							});
							if ( !valid ) {
								// remove invalid value, as it didn't match anything
								//$( this ).val( "" );
								//select.val( "" );
								
								//-- set previous selected
								selected = select.children( ":selected" );
								$(this).val( selected.text() );
								
								input.data( "autocomplete" ).term = "";
								return false;
							}
						}
					}
				})
				/*.blur(function() {
					$(this).val( $(this).attr( "title" ) );
				})*/
				.click(function() {
					$(this).select();
					self.button.click();
				})
				.addClass( "searchBoxAliasSelected form_combo" );

			input.data( "autocomplete" )._renderItem = function( ul, item ) {
				return $( "<li></li>" )
					.data( "item.autocomplete", item )
					.append( "<a>" + item.label + "</a>" )
					.appendTo( ul );
			};

			this.button = $( "<span></span>" )
				.attr( "tabIndex", -1 )
				.addClass("imgDown_searchBox")
				.insertAfter( input )
				.click(function() {
					// close if already visible
					if ( input.autocomplete( "widget" ).is( ":visible" ) ) {
						input.autocomplete( "close" );
						return;
					}

					// work around a bug (likely same cause as #5265)
					$( this ).blur();

					// pass empty string as value to search for, displaying all results
					input.autocomplete( "search", "" );
					input.focus();
				});
		},
		
		selectItemByIndex: function(index, stopPropagation) {
			var stopPropagation = (typeof(stopPropagation) == "undefined" || stopPropagation == true) ? true : false;
			select = this.element;
			select[0].selectedIndex = index;
			selected = select.children( ":selected" );
			selectWidth = ( select.width() == 0 ) ? 100 : select.width();
			value = ( selected.val() || selected.text() ) ? selected.text() : "";
			title = selected.attr("title") ? selected.attr("title") : value;
			spanText = $("<span>").addClass("form_combo").html(value);
			inputWidth = ( spanText.textWidth() < selectWidth && this.autoresize ) ? spanText.textWidth() + $(".imgDown_searchBox").width() : selectWidth;
			input = this.input
				.val( value )
				.width( inputWidth )
				.attr("title", title);
			if ( !stopPropagation ) select.trigger("change");
		},

		destroy: function() {
			this.input.remove();
			this.button.remove();
			this.layout.remove();
			this.element.show();
			$.Widget.prototype.destroy.call( this );
		}
	});
})( jQuery );// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/extern/progressbar/xp_progress.js $
// Revision: 14129 $

// xp_progressbar
// Copyright 2004 Brian Gosselin of ScriptAsylum.com
//
// v1.0 - Initial release
// v1.1 - Added ability to pause the scrolling action (requires you to assign
//        the bar to a unique arbitrary variable).
//      - Added ability to specify an action to perform after a x amount of
//      - bar scrolls. This requires two added arguments.
// v1.2 - Added ability to hide/show each bar (requires you to assign the bar
//        to a unique arbitrary variable).

// var xyz = createBar(
// total_width,
// total_height,
// background_color,
// border_width,
// border_color,
// block_color,
// scroll_speed,
// block_count,
// scroll_count,
// action_to_perform_after_scrolled_n_times
// )

var w3c=(document.getElementById)?true:false;
var ie=(document.all)?true:false;
var N=-1;

function createBar(w,h,bgc,brdW,brdC,blkC,speed,blocks,count,action){
if(ie||w3c){
var t='<div id="_xpbar'+(++N)+'" style="visibility:visible; position:relative; overflow:hidden; width:'+w+'px; height:'+h+'px; background-color:'+bgc+'; border-color:'+brdC+'; border-width:'+brdW+'px; border-style:solid; font-size:1px;">';
t+='<span id="blocks'+N+'" style="left:-'+(h*2+1)+'px; position:absolute; font-size:1px">';
for(i=0;i<blocks;i++){
t+='<span style="background-color:'+blkC+'; left:-'+((h*i)+i)+'px; font-size:1px; position:absolute; width:'+h+'px; height:'+h+'px; '
t+=(ie)?'filter:alpha(opacity='+(100-i*(100/blocks))+')':'-Moz-opacity:'+((100-i*(100/blocks))/100);
t+='"></span>';
}
t+='</span></div>';
document.write(t);
var bA=(ie)?document.all['blocks'+N]:document.getElementById('blocks'+N);
bA.bar=(ie)?document.all['_xpbar'+N]:document.getElementById('_xpbar'+N);
bA.blocks=blocks;
bA.N=N;
bA.w=w;
bA.h=h;
bA.speed=speed;
bA.ctr=0;
bA.count=count;
bA.action=action;
bA.togglePause=togglePause;
bA.showBar=function(){
this.bar.style.visibility="visible";
}
bA.hideBar=function(){
this.bar.style.visibility="hidden";
}
bA.tid=setInterval('startBar('+N+')',speed);
return bA;
}}

function startBar(bn){
var t=(ie)?document.all['blocks'+bn]:document.getElementById('blocks'+bn);
if(parseInt(t.style.left)+t.h+1-(t.blocks*t.h+t.blocks)>t.w){
t.style.left=-(t.h*2+1)+'px';
t.ctr++;
if(t.ctr>=t.count){
eval(t.action);
t.ctr=0;
}}else t.style.left=(parseInt(t.style.left)+t.h+1)+'px';
}

function togglePause(){
if(this.tid==0){
this.tid=setInterval('startBar('+this.N+')',this.speed);
}else{
clearInterval(this.tid);
this.tid=0;
}}
// HeadURL: https://idefix.staffandline.local/svn/Staff/Easyvista/branches/Easyvista%202012.1/EVO_UNIX/include/javascript/staff/decisioncenter.js $
// Revision: 12122 $

    /*************************************************************************/
   /*                                                                       */
  /*    Fichier Javascript associé à l'éditeur du thème Decision Center    */
 /*                                                                       */
/*************************************************************************/

// -- Sélection de la checkbox
function dc_change(frm_name, line, nb, name)
{
  var Items;
  var Links;
  eval("var frm = document." + frm_name + ";");
  
  if (frm[name + line].checked == true)
  {
    for (i = 0; i < nb; i++)
    {
      Items = document.getElementById(name + "check_" + i);
      Links = document.getElementById(name + "link_" + i);
      
      if (i != line)
      {
        Items.style.display = "none";
        Links.style.display = "block";
      }
      else
      {
        Items.style.display = "block";
        Links.style.display = "none";
      }
    }
  }
  else
  {
    for (i = 0; i < nb; i++)
    {
      Items = document.getElementById(name + "check_" + i);
      Links = document.getElementById(name + "link_" + i);

      Items.style.display = "block";
      Links.style.display = "none";
    }
  }
}

// -- Inversion des champs
function dc_insert(frm_name, line, nb, name)
{
  eval("var frm = document." + frm_name + ";");
  for (i = 0; i < nb; i++)
  {
    if (i != line && frm[name + i].checked == true)
    {
      dc_submit_frm(frm_name, name + "list_" + i + "_" + line);
      break;
    }
  }
}

// -- On supprime un élément de la liste
function dc_submit_frm_txt(frm_name, action, text)
{
  var agree;
  eval("var frm = document." + frm_name + ";");
  
  if (text != "")
  agree = confirm(text);
  else
  agree = confirm("Are you sure ?");
  
  if (agree)
  {
    frm.action += "&action=" + action;
    frm.submit();
    
    // on ferme la popup
    if (typeof(window.Popup_js) != "undefined" && !window.Popup_js.closed)
    window.Popup_js.close();
  }
}

// -- On soumet le formulaire
function dc_submit_frm(frm_name, action)
{
  eval("var frm = document." + frm_name + ";");

  frm.action += "&action=" + action;
  frm.submit();

  // on ferme la popup
  if (typeof(window.Popup_js) != "undefined" && !window.Popup_js.closed)
  window.Popup_js.close();
}

// -- Déplacement des éléments
function dc_move_selection(move_type)
{
  if (move_type.substr(0, 5) == 'right')
  {
    len = document.getElementById("left_selection").options.length;
    for (i = len - 1; i >= 0; i--)
    {
      if (move_type == 'right_all' || document.getElementById("left_selection").options[i].selected)
      {
        Opt = document.getElementById("left_selection").options[i];
        document.getElementById("left_selection").options[i] = null;
        
        if (Opt.value != '')
        document.getElementById("right_selection").options[document.getElementById("right_selection").options.length] = Opt;
      }
    }
  }
  else
  {
    len = document.getElementById("right_selection").options.length;
    for (i = len - 1; i >= 0; i--)
    {
      if (move_type == 'left_all' || document.getElementById("right_selection").options[i].selected)
      {
        Opt = document.getElementById("right_selection").options[i];
        document.getElementById("right_selection").options[i] = null;
        
        if (Opt.value != '')
        document.getElementById("left_selection").options[document.getElementById("left_selection").options.length] = Opt;
      }
    }
  }
}

// -- Sauvegarde de la liste des profils
function dc_save_profil(frm_name, strSeparator)
{
  document.getElementById("profils_authorized").value = "";
  document.getElementById("profils_forbidden").value = "";
  for (intI = 0; intI < document.getElementById("left_selection").options.length; intI++)
  {
    document.getElementById("profils_authorized").value += document.getElementById("left_selection").options[intI].value + strSeparator;
  }
  
  for (intI = 0; intI < document.getElementById("right_selection").options.length; intI++)
  {
    document.getElementById("profils_forbidden").value += document.getElementById("right_selection").options[intI].value + strSeparator;
  }
  
  dc_submit_frm(frm_name, "save_profil");
}(function ($){

  /**
   * Manage EZV Dialog Studio
   */
  $.dialogstudio = {
    /**
     * Indicates if object reverts 
     */
    _bRevert : true,
    
    /**
     * Init Component
     */
    init : function(){
      if (!window.opener || !new RegExp("(DialogStudio[.]php[?])").test(window.opener.location.href))
        maximise_window();
      $.dialogstudio._initDivFields();
      $.dialogstudio._initDivTable();
      $.dialogstudio._initDragAndDrop();
    },
    
    /**
     * Manage labels
     */
    switchLbl : function(){
      var o = $('#div_fields .fieldsLabel');
      for (i = o.length - 1; i >= 0; i--) $(o[i]).css('min-width', '1px').toggle();
      $.dialogstudio._initDivFields();
      var o = $('#div_table .fieldAlias');
      for (i = o.length - 1; i >= 0; i--) $(o[i]).css('min-width', '1px').toggle();
      $.dialogstudio._initDivTable();
    },
    
    /**
     * @private Init div_fields part
     */
    _initDivFields : function(){
      $('#div_fields').width($(window).width() - 80);
      var oFields = $('#div_fields span:not(.fieldsList)');
      oFields.css('min-width', 1);
      var maxWidth = 0;
      for (i = oFields.length - 1; i >= 0; i--){
        var obj = $(oFields[i]);
        if (!obj.is(':visible'))
          continue;
        var children = obj.children();
        var iWidthTmp = 0;
        for (j = children.length - 1; j >= 0; j--){
          var obj2 = $(children[j]);
          if (obj2.is(':visible'))
            iWidthTmp += obj2.width();
        }
        if (iWidthTmp > maxWidth)
          maxWidth = iWidthTmp;
      }
      oFields.css('min-width', maxWidth + 20);
      
      var oFields = $('#div_fields span:.fieldsLabel');
      oFields.css('min-width', 1);
      var maxWidth = 0;
      for (i = oFields.length - 1; i >= 0; i--){
        var obj = $(oFields[i]);
        if (!obj.is(':visible'))
          continue;
        var iWidthTmp = obj.width();
        if (iWidthTmp > maxWidth)
          maxWidth = iWidthTmp;
      }
      oFields.css('min-width', maxWidth + 20);
    },
    
    /**
     * @private Init div_table part
     */
    _initDivTable : function(){
      var oDesignColspan = $('#div_table tr td.field');
      for (i = oDesignColspan.length - 1; i >= 0; i--){
        var td = $(oDesignColspan[i]);
        var iWidth = 0;
        var children = td.children();
        for (j = children.length - 1; j >= 0; j--){
          var obj = $(children[j]);
          if (obj.is(':visible'))
            iWidth += obj.width();
        }
        td.css('min-width', iWidth + 20);
      }
      
      oDesignColspan = $('#div_table tr td.fieldButton');
      for (i = oDesignColspan.length - 1; i >= 0; i--){
        var td = $(oDesignColspan[i]);
        var iWidth = 0;
        var children = td.children();
        for (j = children.length - 1; j >= 0; j--){
          var obj = $(children[j]);
          if (obj.is(':visible'))
            iWidth += obj.width();
        }
        td.css('min-width', iWidth + 10);
      }
    },
    
    /**
     * Initialize Drag&Drop
     */
    _initDragAndDrop : function(){
      // Move Row
      var tbody = $('#div_table tbody'); 
      tbody.disableSelection();
      tbody.sortable({ 
        handle: ".moveRow",
        axis : "y",
        forcePlaceholderSize : true,
        start: $.dialogstudio._startDraggingRow,
        stop: $.dialogstudio._stopDraggingRow,
        change: $.dialogstudio._changeDraggingRow
      });
      // Move col
      $("#div_table td:has(.moveCol)").draggable({
        handle : ".moveCol",
        helper : "clone",
        revert : $.dialogstudio._revert,
        start: function(event, ui){
          $.dialogstudio._startInsertMoveCol(event, ui);
          $(ui.helper).addClass('left').addClass('right').addClass('top');
        },
        stop: $.dialogstudio._stopInsertMoveCol
      });
      // Insert col
      $("#div_fields span.ui-widget-content").draggable({
        handle : ".moveCol",
        helper : "clone",
        revert : $.dialogstudio._revert,
        start: $.dialogstudio._startInsertMoveCol,
        stop: $.dialogstudio._stopInsertMoveCol
      });
      // Insert/Move Col
      $("#div_table .insertCol").droppable({
        accept: "#div_table td, #div_fields span:not(.line)",
        over : function (event, ui){ $(event.target).addClass('over'); },
        out : function (event, ui){ $(event.target).removeClass('over'); },
        drop : function (event, ui){ 
          setTimeout( function() {
            $.dialogstudio._insertMoveCol(ui.draggable, $(event.target).parentsUntil('tr')); 
          }, 1); 
        }
      });
      // Insert/Move Col in a new line
      $("#div_table .insertLine").droppable({
        accept: "#div_table td, #div_fields span",
        over : function (event, ui){ $(event.target).addClass('over'); },
        out : function (event, ui){ $(event.target).removeClass('over'); },
        drop : function (event, ui){ 
          setTimeout( function() {
            $.dialogstudio._insertMoveCol(ui.draggable, $(event.target).parentsUntil('tr')); 
          }, 1); 
        }
      });
      $("#div_table .field").droppable({
        accept: "#div_table td, #div_fields span:not(.line)",
        over : function (event, ui){ $(event.target).addClass('over'); },
        out : function (event, ui){ $(event.target).removeClass('over'); },
        drop : function (event, ui){ 
          setTimeout( function() {
            $.dialogstudio._insertMoveCol(ui.draggable, $(event.target)); 
          }, 1); 
        }
      });
    },
    
    /**
     * @private revert Action
     */
    _revert : function (dropped){
      $.dialogstudio._bRevert = !dropped;
      return $.dialogstudio._bRevert;
    },
    
    /**
     * @private Insert/Move Col
     */
    _insertMoveCol : function (draggable, target){
      var tr = target.parent();
      if (tr.hasClass('newline')){
        var toRow = -1;
        var toCol = 0;
      }
      else{
        var toRow = tr.find('span.rowNo').html();
        var toCol = target.find('span.colNo').html();
        if (toCol == null) toCol = -1;
      }
      if (draggable.parent().get(0) == $("#div_fields").get(0)){
        $.dialogstudio._addFieldInDesign(draggable.attr('id'), toRow, toCol);
      }
      else{
        var fromRow = draggable.parent().find('span.rowNo').html();
        var fromCol = draggable.find('span.colNo').html();
        $.dialogstudio._moveFieldInDesign(fromRow, fromCol, toRow, toCol);
      }
    },
    
    /**
     * @private Start Insert/Move Col
     */
    _startInsertMoveCol : function(event, ui){
      var helper = $(ui.helper);
      var children = helper.children();
      iWidth = 0; 
      for (i = children.length - 1; i >= 0; i--){
        var obj = $(children[i]);
        obj.css('min-width', 1);
        if (obj.is(':visible'))
          iWidth += obj.width();
      }
      helper.css('min-width', iWidth + 10);
      $(event.target).hide();
    },
    
    /**
     * @private Stop Insert/Move Col
     */
    _stopInsertMoveCol : function(event, ui){
      var target = $(event.target);
      if (parseInt(target.attr('id')) < 0 || $.dialogstudio._bRevert)
        target.show();
    },
    
    /**
     * @private Start moving a line
     */
    _startDraggingRow : function(event, ui) {
      $(ui.helper).find("td.bottom:not(.top)").addClass('top');
      $(".ui-sortable-placeholder").next().find("td.bottom:not(.top)").addClass('top');
    },
    
    /**
     * @private Moving a line
     */
    _changeDraggingRow : function(event, ui) {
      $("#div_table tr td.top").removeClass('top');
      $("#div_table tr:first").find("td.bottom:not(.top)").addClass('top');
      $(ui.helper).find("td.bottom:not(.top)").addClass('top');
      $(".ui-sortable-placeholder").next().find("td.bottom:not(.top)").addClass('top');
    },
    
    /**
     * @private Stop moving a line
     */
    _stopDraggingRow : function(event, ui) {
      var table = $(event.target);
      table.find("tr td.top").removeClass('top');
      table.find(":first-child td.bottom").addClass('top');
      var tr = $(ui.item);
      var previousTr = tr.prev();
      var to = previousTr.length == 0 ? -1 : parseInt(previousTr.find('.rowNo').html());
      var from = parseInt(tr.find('.rowNo').html());
      if (from > to)
        to++;
      if (from != to){
        var url = window.location.href.replace('#', '');
        url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
        url += '&ActionDesign=MoveRow&RowSelected=' + from + '&RowDest=' + to;
        $.dialogstudio._syncAjax(url, "#div_table");
      }
    },
    
    /**
     * @private Add Field in Design
     */
    _addFieldInDesign : function (idx, toRow, toCol){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=AddNewField_' + idx + '_' + toRow + '_' + toCol;
      var js = "if (parseInt('" + idx + "') >= 0) $('#div_fields #" + idx + "').css('display', '').addClass('invisible').removeClass('visible');";
      $.dialogstudio._syncAjax(url, "#div_table", js);
    },
    
    /**
     * @private Move Field in Design
     */
    _moveFieldInDesign : function (fromRow, fromCol, toRow, toCol){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=MoveField_' + fromRow + '_' + fromCol + '_' + toRow + '_' + toCol;
      $.dialogstudio._syncAjax(url, "#div_table");
    },

    /**
     * Del Field in the Design
     * @param row Row where is the field
     * @param col Col where is the field
     * @param idx Id of the deleted field
     */
    delFieldInDesign : function (row, col, idx){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=DelColWithField_' + row + '_' + col;
      var js = "if (parseInt('" + idx + "') >= 0) $('#div_fields #" + idx + "').css('display', '').addClass('visible').removeClass('invisible');";
      $.dialogstudio._syncAjax(url, "#div_table", js);
    },
    
    /**
     * Refresh Design
     */
    refresh : function (){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=Refresh';
      $.dialogstudio._syncAjax(url, "#div_table");
    },
    
    /**
     * Refresh Design And Fields List
     */
    refreshAll : function (){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=RefreshAll';
      $.dialogstudio._syncAjax(url, "#htmlPreview");
    },

    /**
     * Add a new Field to the available fields list
     */    
    addFieldFromDb : function (table, field){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=AddField&table=' + table + '&field=' + field;
      $.dialogstudio._syncAjax(url, "#div_fields");
    },
    
    /**
     * Delete a Field From the available fields list
     */    
    delFieldFromDb : function (table, field){
      var url = window.location.href.replace('#', '');
      url = $.dialogstudio._delete_param_url(url, 'ActionDesign');
      url += '&ActionDesign=DelField&table=' + table + '&field=' + field;
      $.dialogstudio._syncAjax(url, "#htmlPreview");
    },
    
    /**
     * @private Delete a parameter in an URL
     */
    _delete_param_url : function(url, param){
      var reg = new RegExp("([?]" + param + "=[^&]*&*)", "g");
      url = url.replace(reg, "?");
      reg = new RegExp("(&" + param + "=[^&]*)", "g");
      while (url.match(reg)){ url = url.replace(reg, ""); }
      return (url);
    },
    
    /**
     * @private Ajax Treatment
     * @param url URL to Load
     * @param div Div (selector) to update
     * @param js JS to execute after
     */
    _syncAjax : function (url, div, js){
      $.ajax({
        url: url,
        async : false,
        context: document.body,
        complete: function(data, textStatus, jqXHR){
          if (div != "undefined")
            $(div).html(data.responseText);
          if (js != "undefined")
            eval(js);
          $.dialogstudio.init();
        }
      });
    }
  }
  
 })(jQuery);
 

(function ($){

  /**
   * Login EZV
   */
  $.login = {
    
    /**
     * @private Form Component
     */
    _oFrm : null,
    
    /**
     * @private Current Password Display Component
     */
    _oPwd : null,
    
    /**
     * @private Password #1 Display Component
     */
    _oPwd1 : null,
    
    /**
     * @private Password #2 Display Component
     */
    _oPwd2 : null,
    
    /**
     * @private New Password Required Error Message
     */
    _sNewPwdReqMsg : '',
    
    /**
     * @private No Match Password Error Message
     */
    _sNoMatchMsg : '',
    
    /**
     * @private Regular Expression to match with
     */
    _oRegExp : null,
    
    /**
     * @private Regular Expression Error Message
     */
    _sRegExpMsg : '',
    
    /**
     * @private Forgotten Password Mode Display Component
     */
    _oFPwdMode : null,
    
    /**
     * @private Login Display Component
     */
    _oLogin : null,
    
    /**
     * @private Email Display Component
     */
    _oEmail : null,
    
    /**
     * @private Error Message to show
     */
    _oErrorMsg : null,
    
    /**
     * Public initialization method of this class
     */
    init : function(sFrmID, sPwdID, sPwd1ID, sPwd2ID, sNewPwdReqMsg, sNoMatchMsg) {
      //$(document).ready(function(){ $.fiche._init(); });
      this._oFrm = $("#" + sFrmID);
      this._oPwd = $("#" + sPwdID);
      
      if (this._oFrm == null)
      {
        alert('Init Function Error');
        return;
      }
      
      this._oFrm.submit(function(){
        /* Override onSumbit Event */
        var res = true;
        if ($.login._oPwd1 != null && $.login._oPwd2 != null)
        {
          // Check Password change
          res = $.login.checkPwdChange();
        }
        
        return res;
      });
      
      if (sPwd1ID != '')
        this._oPwd1 = $("#" + sPwd1ID);
      if (sPwd2ID != '')
        this._oPwd2 = $("#" + sPwd2ID);
        
      this._sNewPwdReqMsg = sNewPwdReqMsg;
      this._sNoMatchMsg = sNoMatchMsg;
    },
    
    /**
     * @public Add constraint to a Component (Password for example)
     */
    addCmpConstraint : function (sRegExpr, sMsg){
      if (sRegExpr != null && sRegExpr != '')
      {
        this._oRegExp = new RegExp(sRegExpr, "g");
        this._sRegExpMsg = sMsg;
      }
    },
    
    /**
     * @public Check Password change
     */
    checkPwdChange : function (){
      // Check Cmp
      if (this._oPwd == null)
      {
        alert('Function Error "Password Field undefined"');
        return;
      }
      
      if (this._oPwd1 == null)
      {
        alert('Function Error "Password Field #1 undefined"');
        return;
      }
      
      if (this._oPwd2 == null)
      {
        alert('Function Error "Password Field #2 undefined"');
        return;
      }
      
      var sPwdVal = this._oPwd.val();
      var sPwd1Val = this._oPwd1.val();
      var sPwd2Val = this._oPwd2.val();
      
      if (sPwdVal == sPwd1Val)
      {
        alert(this._sNewPwdReqMsg);
        this._oPwd1.select();
        return false;
      }
      
      if (this._oRegExp != null && !sPwd1Val.match(this._oRegExp))
      {
        alert(this._sRegExpMsg);
        this._oPwd1.select();
        return false;
      }
      
      if (sPwd1Val != sPwd2Val)
      {
        alert(this._sNoMatchMsg);
        this._oPwd1.select();
        return false;
      }
      
      return true;
    },
    
    /**
     * @public Form Submit
     */
    submitForm : function (){
      // Send Form
      this._oFrm.submit();
    },
    
    /**
     * @public Get Link Forgotten Password Interface
     */
    getLinkForgottenPwd : function (sRoot, sSessionID){
      window.open(sRoot + 'forgotten_password.php?PHPSESSID=' + sSessionID, 'ForgottenPassword', 'scrollbars=yes,status=no,width=500,height=250,top=120,left=120,resizable=yes');
    },
    
    /**
     * @public Init Forgotten Password Interface
     */
    initForgottenPwd : function (sFrmID, sModeID, sLoginID, sEmailID, oErrorMsg){
      // Init Cmp
      this._oErrorMsg = oErrorMsg;
      this._oFrm = $("#" + sFrmID);
      this._oFrm.submit(function(){
        /* Override onSumbit Event */
        var res = true;
        var sModeID = $.login._oFPwdMode.attr('id');
        if ($("input[name=" + sModeID + "]:checked").val() == null)
        {
          alert($.login._oErrorMsg.modeReq);
          res = false;
        }
        else if ($("input[name=" + sModeID + "]:checked").val() == 'login')
        {
          var sLoginVal = $.login._oLogin.val();
          
          if (sLoginVal == '')
          {
            alert($.login._oErrorMsg.loginReq);
            $.login._oLogin.select();
            res = false;
          }
        }
        else if ($("input[name=" + sModeID + "]:checked").val() == 'email')
        {
          var sEmailVal = $.login._oEmail.val();
          
          if (sEmailVal == '')
          {
            alert($.login._oErrorMsg.emailReq);
            $.login._oEmail.select();
            res = false;
          }
          else if (!sEmailVal.match($.login._oRegExp))
          {
            alert($.login._sRegExpMsg);
            $.login._oEmail.select();
            res = false;
          }
        }
        else
        {
          alert('Function Error');
          res = false;
        }
        
        return res;
      });
      
      this._oFPwdMode = $("input[name=" + sModeID + "]:radio");
      this._oLogin = $("#" + sLoginID);
      if ($("input[name=" + sModeID + "]:checked").val() != 'login')
        this._oLogin.attr("disabled", "disabled");
      else
        this._oLogin.select();
      this._oEmail = $("#" + sEmailID);
      if ($("input[name=" + sModeID + "]:checked").val() != 'email')
        this._oEmail.attr("disabled", "disabled");
      else
        this._oEmail.select();
      
      this._oFPwdMode.click(function (){
        if ($(this).val() == 'login')
        {
          //alert($(this).val());
          $.login._oLogin.removeAttr("disabled");
          $.login._oLogin.select();
          $.login._oEmail.val('');
          $.login._oEmail.attr("disabled", "disabled");
        }
        else
        {
          //alert($(this).val());
          $.login._oEmail.removeAttr("disabled");
          $.login._oEmail.select();
          $.login._oLogin.val('');
          $.login._oLogin.attr("disabled", "disabled");
        }
      });
      
      // Cmp Default Checked
      //$("input[value='login']").attr("checked", "checked");
    }
  }
 })(jQuery);(function ($){

  /**
   * Manage EZV Fiche (Discovery)
   */
  $.fiche = {
    
    /**
     * @private Hint Component Array
     */
    _aHintCmp : [],
    
    /**
     * @private Hint Display Default Value
     */
    _bDispVisible : false,
    
    /**
     * @private Image path
     */
    _sStylePath : '',
    
    /**
     * Public initialization method of this class
     */
    init : function() {
      //$(document).ready(function(){ $.fiche._init(); });
      this._sStylePath = get_atmosphere();
    },
    
    /**
     * @private init Fiche
     */
    /*_init : function (){
      this._sStylePath = get_atmosphere();
      alert('tata');
    },*/
    
    /**
     * @public Add Hint Object into Array
     */
    addHintCmp : function (sDivHintID, sDivBtnID){
      /* Get Components */
      var _oDivHint = $("#" + sDivHintID);
      var _oDivBtn = $("#" + sDivBtnID);
      
      if (_oDivHint == null || _oDivBtn == null)
      {
        alert('Function Error "addHintCmp"');
        return;
      }
      
      /* Save Object Definition into Array */
      this._aHintCmp.push({
        'div_hint_id': sDivHintID,
        'div_btn_id': sDivBtnID
      });
      
      if (this._bDispVisible == false)
      {
        this.hideHintCmp(sDivHintID, sDivBtnID);
      }
      else
      {
        this.showHintCmp(sDivHintID, sDivBtnID);
      }
    },
    
    /**
     * @public Show Hint Object
     */
    showHintCmp : function (sDivHintID, sDivBtnID)
    {
      /* Get Components */
      var _oDivHint = $("#" + sDivHintID);
      var _oDivBtn = $("#" + sDivBtnID);
      
      if (_oDivHint == null || _oDivBtn == null)
      {
        alert('Function Error "showHintCmp"');
        return;
      }
      
      var oParent = _oDivHint.parent();
      if (oParent != null && oParent.width() > 0)
      {
        /* Resize Hint with parent width */
        var iWidth = oParent.width();
        var iDelta = _oDivHint.outerWidth() - _oDivHint.width();
        _oDivHint.width(iWidth-iDelta);
      }
      
      /* Show Hint */
      _oDivHint.show();
      /* Replace HTML Show Button by Hide Button */
      _oDivBtn.html('<a onclick="$.fiche.hideHintCmp(\'' + sDivHintID + '\', \'' + sDivBtnID + '\');" style="cursor: pointer;"><img src="' + this._sStylePath + '/collapse.gif" style="width: 16px; height: 16px;" align="left" border="0" /></a>');
    },
    
    /**
     * @public Hide Hint Object
     */
    hideHintCmp : function (sDivHintID, sDivBtnID)
    {
      /* Get Components */
      var _oDivHint = $("#" + sDivHintID);
      var _oDivBtn = $("#" + sDivBtnID);
      
      if (_oDivHint == null || _oDivBtn == null)
      {
        alert('Function Error "showHintCmp"');
        return;
      }
      
      /* Hide Hint */
      _oDivHint.hide();
      /* Replace HTML Hide Button by Show Button */
      _oDivBtn.html('<a onclick="$.fiche.showHintCmp(\'' + sDivHintID + '\', \'' + sDivBtnID + '\');" style="cursor: pointer;"><img src="' + this._sStylePath + '/expand.gif" style="width: 16px; height: 16px;" align="left" border="0" /></a>');
    },
    
    /**
     * @public Show All Hint Object
     */
    showAllHintCmp : function ()
    {
      for (var i = 0; i < this._aHintCmp.length; i++)
      {
        this.showHintCmp(this._aHintCmp[i].div_hint_id, this._aHintCmp[i].div_btn_id);
      }
      
      return true;
    },
    
    /**
     * @public Hide All Hint Object
     */
    hideAllHintCmp : function ()
    {
      for (var i = 0; i < this._aHintCmp.length; i++)
      {
        this.hideHintCmp(this._aHintCmp[i].div_hint_id, this._aHintCmp[i].div_btn_id);
      }
      
      return true;
    },
    
    /**
     * @public Show Link All Hint Object
     */
    showLinkAllHintCmp : function (sDivLinkID)
    {
      /* Get Components */
      var oDivLink = $("#" + sDivLinkID);
      
      if (oDivLink != null)
      {
        oDivLink.show();
      }
    }
  }
 })(jQuery);/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/

var Base64 = {

	// private property
	_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode : function (input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	},

	// public method for decoding
	decode : function (input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode : function (string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode : function (utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while ( i < utftext.length ) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	}

}
}